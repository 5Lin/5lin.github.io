[{"content":" 多线程与反射 前面我们已经讲解了JavaSE的大部分核心内容，最后一章，我们还将继续学习JavaSE中提供的各种高级特性。这些高级特性对于我们之后的学习，会有着举足轻重的作用。\n多线程 **注意：**本章节会涉及到 操作系统 相关知识。\n在了解多线程之前，让我们回顾一下操作系统中提到的进程概念：\n进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。\n在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？\n后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。\n在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行main()方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程：\npublic static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); } } 关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。\n线程的创建和启动 通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：\n@FunctionalInterface public interface Runnable { /** * When an object implementing interface \u0026lt;code\u0026gt;Runnable\u0026lt;/code\u0026gt; is used * to create a thread, starting the thread causes the object\u0026#39;s * \u0026lt;code\u0026gt;run\u0026lt;/code\u0026gt; method to be called in that separately executing * thread. * \u0026lt;p\u0026gt; * The general contract of the method \u0026lt;code\u0026gt;run\u0026lt;/code\u0026gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } 创建好后，通过调用start()方法来运行此线程：\npublic static void main(String[] args) { Thread t = new Thread(() -\u0026gt; { //直接编写逻辑 System.out.println(\u0026#34;我是另一个线程！\u0026#34;); }); t.start(); //调用此方法来开始执行此线程 } 可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果：\npublic static void main(String[] args) { Thread t = new Thread(() -\u0026gt; { System.out.println(\u0026#34;我是线程：\u0026#34;+Thread.currentThread().getName()); System.out.println(\u0026#34;我正在计算 0-10000 之间所有数的和...\u0026#34;); int sum = 0; for (int i = 0; i \u0026lt;= 10000; i++) { sum += i; } System.out.println(\u0026#34;结果：\u0026#34;+sum); }); t.start(); System.out.println(\u0026#34;我是主线程！\u0026#34;); } 我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果：\npublic static void main(String[] args) { Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;我是一号线程：\u0026#34;+i); } }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;我是二号线程：\u0026#34;+i); } }); t1.start(); t2.start(); } 我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！\n注意：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！\n实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间：\npublic static void main(String[] args) throws InterruptedException { System.out.println(\u0026#34;l\u0026#34;); Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s System.out.println(\u0026#34;b\u0026#34;); Thread.sleep(1000); System.out.println(\u0026#34;w\u0026#34;); Thread.sleep(1000); System.out.println(\u0026#34;nb!\u0026#34;); } 我们也可以使用stop()方法来强行终止此线程：\npublic static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -\u0026gt; { Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;打印:\u0026#34;+i); if(i == 20) me.stop(); //此方法会直接终止此线程 } }); t.start(); } 虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。\n思考：猜猜以下程序输出结果：\nprivate static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) value++; System.out.println(\u0026#34;线程1完成\u0026#34;); }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) value++; System.out.println(\u0026#34;线程2完成\u0026#34;); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。\n线程的休眠和中断 我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况：\n当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。 当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。 当线程出现异常或错误 / 被stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。 而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：\npublic static void main(String[] args) { Thread t = new Thread(() -\u0026gt; { try { System.out.println(\u0026#34;l\u0026#34;); Thread.sleep(1000); //sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个） System.out.println(\u0026#34;b\u0026#34;); //调用sleep后，线程会直接进入到等待状态，直到时间结束 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start(); } 通过调用sleep()方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？\npublic static void main(String[] args) { Thread t = new Thread(() -\u0026gt; { try { Thread.sleep(10000); //休眠10秒 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 我们发现，每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：\npublic static void main(String[] args) { Thread t = new Thread(() -\u0026gt; { System.out.println(\u0026#34;线程开始运行！\u0026#34;); while (true){ //无限循环 if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 break; //响应中断 } } System.out.println(\u0026#34;线程被中断了！\u0026#34;); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：\npublic static void main(String[] args) { Thread t = new Thread(() -\u0026gt; { System.out.println(\u0026#34;线程开始运行！\u0026#34;); while (true){ if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 System.out.println(\u0026#34;发现中断信号，复位，继续运行...\u0026#34;); Thread.interrupted(); //复位中断标记（返回值是当前是否有中断标记，这里不用管） } } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？\npublic static void main(String[] args) { Thread t = new Thread(() -\u0026gt; { System.out.println(\u0026#34;线程开始运行！\u0026#34;); Thread.currentThread().suspend(); //暂停此线程 System.out.println(\u0026#34;线程继续运行！\u0026#34;); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.resume(); //恢复此线程 } catch (InterruptedException e) { e.printStackTrace(); } } 虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。\n线程的优先级 实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：\nMIN_PRIORITY 最低优先级 MAX_PRIORITY 最高优先级 NOM_PRIORITY 常规优先级 public static void main(String[] args) { Thread t = new Thread(() -\u0026gt; { System.out.println(\u0026#34;线程开始运行！\u0026#34;); }); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级 } 优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！\n线程的礼让和加入 我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程：\npublic static void main(String[] args) { Thread t1 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;线程1开始运行！\u0026#34;); for (int i = 0; i \u0026lt; 50; i++) { if(i % 5 == 0) { System.out.println(\u0026#34;让位！\u0026#34;); Thread.yield(); } System.out.println(\u0026#34;1打印：\u0026#34;+i); } System.out.println(\u0026#34;线程1结束！\u0026#34;); }); Thread t2 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;线程2开始运行！\u0026#34;); for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;2打印：\u0026#34;+i); } }); t1.start(); t2.start(); } 观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。\n当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入：\npublic static void main(String[] args) { Thread t1 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;线程1开始运行！\u0026#34;); for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;1打印：\u0026#34;+i); } System.out.println(\u0026#34;线程1结束！\u0026#34;); }); Thread t2 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;线程2开始运行！\u0026#34;); for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;2打印：\u0026#34;+i); if(i == 10){ try { System.out.println(\u0026#34;线程1加入到此线程！\u0026#34;); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } 我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看：\npublic static void main(String[] args) { Thread t1 = new Thread(() -\u0026gt; { System.out.println(Thread.currentThread().getName()+\u0026#34;开始运行！\u0026#34;); for (int i = 0; i \u0026lt; 50; i++) { System.out.println(Thread.currentThread().getName()+\u0026#34;打印：\u0026#34;+i); } System.out.println(\u0026#34;线程1结束！\u0026#34;); }); Thread t2 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;线程2开始运行！\u0026#34;); for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;2打印：\u0026#34;+i); if(i == 10){ try { System.out.println(\u0026#34;线程1加入到此线程！\u0026#34;); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } 实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。\n线程锁和线程同步 在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理：\n线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制：\n高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。\n实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！\n比如我们可以来看看下面这个问题：\nprivate static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) value++; System.out.println(\u0026#34;线程1完成\u0026#34;); }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) value++; System.out.println(\u0026#34;线程2完成\u0026#34;); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！\n通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块：\nprivate static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) { synchronized (Main.class){ //使用synchronized关键字创建同步代码块 value++; } } System.out.println(\u0026#34;线程1完成\u0026#34;); }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\u0026#34;线程2完成\u0026#34;); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！\n当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC篇视频教程中我们还会讲到乐观锁，如CAS算法）\n那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？\nprivate static int value = 0; public static void main(String[] args) throws InterruptedException { Main main1 = new Main(); Main main2 = new Main(); Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) { synchronized (main1){ value++; } } System.out.println(\u0026#34;线程1完成\u0026#34;); }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) { synchronized (main2){ value++; } } System.out.println(\u0026#34;线程2完成\u0026#34;); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。\nsynchronized关键字也可以作用于方法上，调用此方法时也会获取锁：\nprivate static int value = 0; private static synchronized void add(){ value++; } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) add(); System.out.println(\u0026#34;线程1完成\u0026#34;); }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) add(); System.out.println(\u0026#34;线程2完成\u0026#34;); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。\n死锁 其实死锁的概念在操作系统中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：\n我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：\npublic static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -\u0026gt; { synchronized (o1){ try { Thread.sleep(1000); synchronized (o2){ System.out.println(\u0026#34;线程1\u0026#34;); } } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -\u0026gt; { synchronized (o2){ try { Thread.sleep(1000); synchronized (o1){ System.out.println(\u0026#34;线程2\u0026#34;); } } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); t2.start(); } 所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程：\nnagocoler@NagodeMacBook-Pro ~ % jps 51592 Launcher 51690 Jps 14955 51693 Main nagocoler@NagodeMacBook-Pro ~ % jstack 51693 ... Java stack information for the threads listed above: =================================================== \u0026#34;Thread-1\u0026#34;: at com.test.Main.lambda$main$1(Main.java:46) - waiting to lock \u0026lt;0x000000076ad27fc0\u0026gt; (a java.lang.Object) - locked \u0026lt;0x000000076ad27fd0\u0026gt; (a java.lang.Object) at com.test.Main$$Lambda$2/1867750575.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) \u0026#34;Thread-0\u0026#34;: at com.test.Main.lambda$main$0(Main.java:34) - waiting to lock \u0026lt;0x000000076ad27fd0\u0026gt; (a java.lang.Object) - locked \u0026lt;0x000000076ad27fc0\u0026gt; (a java.lang.Object) at com.test.Main$$Lambda$1/396873410.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) Found 1 deadlock. jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息，同样的，使用jconsole也可以进行监测。\n因此，前面说不推荐使用 suspend()去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。\nwait和notify方法 其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()，他们其实是需要配合synchronized来使用的（实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了）当然，只有在同步代码块中才能使用这些方法，正常情况下会报错，我们来看看他们的作用是什么：\npublic static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Thread t1 = new Thread(() -\u0026gt; { synchronized (o1){ try { System.out.println(\u0026#34;开始等待\u0026#34;); o1.wait(); //进入等待状态并释放锁 System.out.println(\u0026#34;等待结束！\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -\u0026gt; { synchronized (o1){ System.out.println(\u0026#34;开始唤醒！\u0026#34;); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i \u0026lt; 50; i++) { System.out.println(i); } //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 } }); t1.start(); Thread.sleep(1000); t2.start(); } 我们可以发现，对象的wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！\nnotifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。\nThreadLocal的使用 既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？\n我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。\npublic static void main(String[] args) throws InterruptedException { ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -\u0026gt; { local.set(\u0026#34;lbwnb\u0026#34;); //将变量的值给予ThreadLocal System.out.println(\u0026#34;变量值已设定！\u0026#34;); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -\u0026gt; { System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); t1.start(); Thread.sleep(3000); //间隔三秒 t2.start(); } 上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容：\npublic static void main(String[] args) throws InterruptedException { ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -\u0026gt; { local.set(\u0026#34;lbwnb\u0026#34;); //将变量的值给予ThreadLocal System.out.println(\u0026#34;线程1变量值已设定！\u0026#34;); try { Thread.sleep(2000); //间隔2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;线程1读取变量值：\u0026#34;); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -\u0026gt; { local.set(\u0026#34;yyds\u0026#34;); //将变量的值给予ThreadLocal System.out.println(\u0026#34;线程2变量值已设定！\u0026#34;); }); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start(); } 我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。\n我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量：\npublic static void main(String[] args) { ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); Thread t = new Thread(() -\u0026gt; { local.set(\u0026#34;lbwnb\u0026#34;); new Thread(() -\u0026gt; { System.out.println(local.get()); }).start(); }); t.start(); } 我们可以使用InheritableThreadLocal来解决：\npublic static void main(String[] args) { ThreadLocal\u0026lt;String\u0026gt; local = new InheritableThreadLocal\u0026lt;\u0026gt;(); Thread t = new Thread(() -\u0026gt; { local.set(\u0026#34;lbwnb\u0026#34;); new Thread(() -\u0026gt; { System.out.println(local.get()); }).start(); }); t.start(); } 在InheritableThreadLocal存放的内容，会自动向子线程传递。\n定时器 我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用Thread.sleep()来实现：\npublic static void main(String[] args) { new TimerTask(() -\u0026gt; System.out.println(\u0026#34;我是定时任务！\u0026#34;), 3000).start(); //创建并启动此定时任务 } static class TimerTask{ Runnable task; long time; public TimerTask(Runnable runnable, long time){ this.task = runnable; this.time = time; } public void start(){ new Thread(() -\u0026gt; { try { Thread.sleep(time); task.run(); //休眠后再运行 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } 我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？\npublic static void main(String[] args) { new TimerLoopTask(() -\u0026gt; System.out.println(\u0026#34;我是定时任务！\u0026#34;), 3000).start(); //创建并启动此定时任务 } static class TimerLoopTask{ Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime){ this.task = runnable; this.loopTime = loopTime; } public void start(){ new Thread(() -\u0026gt; { try { while (true){ //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 } } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } 现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。\n但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务：\npublic static void main(String[] args) { Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() { //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() { System.out.println(Thread.currentThread().getName()); //打印当前线程名称 } }, 1000); //执行一个延时任务 } 我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：\npublic class Timer { /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they\u0026#39;re obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ... } TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：\npublic Timer(String name) { thread.setName(name); thread.start(); } 而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：\npublic void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } } } /** * The main timer loop. (See class comment.) */ private void mainLoop() { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() \u0026amp;\u0026amp; newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ... } newTasksMayBeScheduled实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用cancel()方法来关闭它的工作线程：\npublic void cancel() { synchronized(queue) { thread.newTasksMayBeScheduled = false; queue.clear(); queue.notify(); //唤醒wait使得工作线程结束 } } 因此，我们可以在使用完成后，调用Timer的cancel()方法以正常退出我们的程序：\npublic static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 } }, 1000); } 守护线程 不要把操作系统重的守护进程和守护线程相提并论！\n守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂：\npublic static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -\u0026gt; { while (true){ try { System.out.println(\u0026#34;程序正常运行中...\u0026#34;); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i \u0026lt; 5; i++) { Thread.sleep(1000); } } 在守护线程中产生的新线程也是守护的：\npublic static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -\u0026gt; { Thread it = new Thread(() -\u0026gt; { while (true){ try { System.out.println(\u0026#34;程序正常运行中...\u0026#34;); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); it.start(); }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i \u0026lt; 5; i++) { Thread.sleep(1000); } } 再谈集合类 集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个spliterator()方法用于获取可拆分迭代器。\n其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：\ndefault Stream\u0026lt;E\u0026gt; parallelStream() { return StreamSupport.stream(spliterator(), true); //parallelStream就是利用了可拆分迭代器进行多线程操作 } 并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -\u0026gt; System.out.println(Thread.currentThread().getName()+\u0026#34; -\u0026gt; \u0026#34;+i)); } 我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEachOrdered(System.out::println); } 我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法：\npublic static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr)); } 更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！\npublic static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSetAll(arr, i -\u0026gt; { System.out.println(Thread.currentThread().getName()); return arr[i]; }); System.out.println(Arrays.toString(arr)); } 因为多线程的加入，我们之前认识的集合类都废掉了：\npublic static void main(String[] args) throws InterruptedException { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { list.add(i); //两个线程同时操作集合类进行插入操作 } }).start(); new Thread(() -\u0026gt; { for (int i = 1000; i \u0026lt; 2000; i++) { list.add(i); } }).start(); Thread.sleep(2000); System.out.println(list.size()); } 我们发现，有些时候运气不好，得到的结果并不是2000个元素，而是：\n因为之前的集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题：\npublic boolean add(E e) { ensureCapacityInternal(size + 1); // 当数组容量更好还差一个满的时候，这个时候两个线程同时走到了这里，因为都判断为没满，所以说没有进行扩容，但是实际上两个线程都要插入一个元素进来 elementData[size++] = e; //当两个线程同时在这里插入元素，直接导致越界访问 return true; } 当然，在Java早期的时候，还有一些老的集合类，这些集合类都是线程安全的：\npublic static void main(String[] args) throws InterruptedException { Vector\u0026lt;Integer\u0026gt; list = new Vector\u0026lt;\u0026gt;(); //我们可以使用Vector代替List使用 //Hashtable\u0026lt;Integer, String\u0026gt; 也可以使用Hashtable来代替Map new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { list.add(i); } }).start(); new Thread(() -\u0026gt; { for (int i = 1000; i \u0026lt; 2000; i++) { list.add(i); } }).start(); Thread.sleep(1000); System.out.println(list.size()); } 因为这些集合类中的每一个方法都加了锁，所以说不会出现多线程问题，但是这些老的集合类现在已经不再使用了，我们会在JUC篇视频教程中介绍专用于并发编程的集合类。\n通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！\n实战：生产者与消费者 所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。\n通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。\n反射 **注意：**本章节涉及到JVM相关底层原理，难度会有一些大。\n反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。\n简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！\nJava类加载机制 在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的：\n在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！\n为了方便各位小伙伴理解，你们就直接理解为默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。\nClass类详解 通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式：\npublic static void main(String[] args) throws ClassNotFoundException { Class\u0026lt;String\u0026gt; clazz = String.class; //使用class关键字，通过类名获取 Class\u0026lt;?\u0026gt; clazz2 = Class.forName(\u0026#34;java.lang.String\u0026#34;); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class\u0026lt;?\u0026gt; Class\u0026lt;?\u0026gt; clazz3 = new String(\u0026#34;cpdd\u0026#34;).getClass(); //通过实例对象获取 } 注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了?通配符作为返回值，但是实际上都和第一个返回的是同一个对象：\nClass\u0026lt;String\u0026gt; clazz = String.class; //使用class关键字，通过类名获取 Class\u0026lt;?\u0026gt; clazz2 = Class.forName(\u0026#34;java.lang.String\u0026#34;); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class\u0026lt;?\u0026gt; Class\u0026lt;?\u0026gt; clazz3 = new String(\u0026#34;cpdd\u0026#34;).getClass(); System.out.println(clazz == clazz2); System.out.println(clazz == clazz3); 通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题：\npublic static void main(String[] args) { Class\u0026lt;?\u0026gt; clazz = int.class; //基本数据类型有Class对象吗？ System.out.println(clazz); } 迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的：\n/** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static final Class\u0026lt;Integer\u0026gt; TYPE = (Class\u0026lt;Integer\u0026gt;) Class.getPrimitiveClass(\u0026#34;int\u0026#34;); /* * Return the Virtual Machine\u0026#39;s Class object for the named * primitive type */ static native Class\u0026lt;?\u0026gt; getPrimitiveClass(String name); //C++实现，并非Java定义 每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。\npublic static void main(String[] args) { Class\u0026lt;?\u0026gt; clazz = int.class; System.out.println(Integer.TYPE == int.class); } 通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？\npublic static void main(String[] args) { System.out.println(Integer.TYPE == Integer.class); } 我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象：\npublic static void main(String[] args) { Class\u0026lt;String[]\u0026gt; clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(\u0026#34;10\u0026#34;))); //强制类型转换 } 下节课，我们将开始对Class对象的使用进行讲解。\nClass对象与多态 正常情况下，我们使用instanceof进行类型比较：\npublic static void main(String[] args) { String str = \u0026#34;\u0026#34;; System.out.println(str instanceof String); } 它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型：\npublic static void main(String[] args) { String str = \u0026#34;\u0026#34;; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型 } 如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用asSubClass()方法：\npublic static void main(String[] args) { Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常 } 通过getSuperclass()方法，我们可以获取到父类的Class对象：\npublic static void main(String[] args) { Integer i = 10; System.out.println(i.getClass().getSuperclass()); } 也可以通过getGenericSuperclass()获取父类的原始类型的Type：\npublic static void main(String[] args) { Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class); } 我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。\n同理，我们也可以像上面这样获取父接口：\npublic static void main(String[] args) { Integer i = 10; for (Class\u0026lt;?\u0026gt; anInterface : i.getClass().getInterfaces()) { System.out.println(anInterface.getName()); } for (Type genericInterface : i.getClass().getGenericInterfaces()) { System.out.println(genericInterface.getTypeName()); } } 是不是感觉反射功能很强大？几乎类的所有信息都可以通过反射获得。\n创建类对象 既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象：\npublic static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u0026lt;Student\u0026gt; clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public void test(){ System.out.println(\u0026#34;萨日朗\u0026#34;); } } 通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？\npublic static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u0026lt;Student\u0026gt; clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public Student(String text){ } public void test(){ System.out.println(\u0026#34;萨日朗\u0026#34;); } } 当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。\npublic static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u0026lt;Student\u0026gt; clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ private Student(){} public void test(){ System.out.println(\u0026#34;萨日朗\u0026#34;); } } 当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用newInstance()方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象：\npublic static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u0026lt;Student\u0026gt; clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\u0026#34;what\u0026#39;s up\u0026#34;); student.test(); } static class Student{ public Student(String str){} public void test(){ System.out.println(\u0026#34;萨日朗\u0026#34;); } } 通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用getConstructor()方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？\npublic static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u0026lt;Student\u0026gt; clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\u0026#34;what\u0026#39;s up\u0026#34;); student.test(); } static class Student{ private Student(String str){} public void test(){ System.out.println(\u0026#34;萨日朗\u0026#34;); } } 我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？\nClass\u0026lt;Student\u0026gt; clazz = Student.class; Constructor\u0026lt;Student\u0026gt; constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); //修改访问权限 Student student = constructor.newInstance(\u0026#34;what\u0026#39;s up\u0026#34;); student.test(); 使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）\n调用类方法 我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类：\npackage com.test; public class Student { public void test(String str){ System.out.println(\u0026#34;萨日朗\u0026#34;+str); } } 这次我们通过forName(String)来找到这个类并创建一个新的对象：\npublic static void main(String[] args) throws ReflectiveOperationException { Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.test.Student\u0026#34;); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getMethod(\u0026#34;test\u0026#34;, String.class); //通过方法名和形参类型获取类中的方法 method.invoke(instance, \u0026#34;what\u0026#39;s up\u0026#34;); //通过Method对象的invoke方法来调用方法 } 通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。\n我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。\n同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将test()方法的权限修饰符改为private：\npublic static void main(String[] args) throws ReflectiveOperationException { Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.test.Student\u0026#34;); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getDeclaredMethod(\u0026#34;test\u0026#34;, String.class); //通过方法名和形参类型获取类中的方法 method.setAccessible(true); method.invoke(instance, \u0026#34;what\u0026#39;s up\u0026#34;); //通过Method对象的invoke方法来调用方法 } Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息：\npublic static void main(String[] args) throws ReflectiveOperationException { Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.test.Student\u0026#34;); Method method = clazz.getDeclaredMethod(\u0026#34;test\u0026#34;, String.class); //通过方法名和形参类型获取类中的方法 System.out.println(method.getName()); //获取方法名称 System.out.println(method.getReturnType()); //获取返回值类型 } 当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：\nMethod method = clazz.getDeclaredMethod(\u0026#34;test\u0026#34;, String[].class); 反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。\n修改类的属性 我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段：\npublic static void main(String[] args) throws ReflectiveOperationException { Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.test.Student\u0026#34;); Object instance = clazz.newInstance(); Field field = clazz.getField(\u0026#34;i\u0026#34;); //获取类的成员字段i field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\u0026#34;test\u0026#34;); method.invoke(instance); } 在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问：\npublic static void main(String[] args) throws ReflectiveOperationException { Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.test.Student\u0026#34;); Object instance = clazz.newInstance(); Field field = clazz.getDeclaredField(\u0026#34;i\u0026#34;); //获取类的成员字段i field.setAccessible(true); field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\u0026#34;test\u0026#34;); method.invoke(instance); } 现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段i前面添加final关键字，我们再来看看效果：\nprivate final int i = 10; 这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值：\npublic static void main(String[] args) throws ReflectiveOperationException { Integer i = 10; Field field = Integer.class.getDeclaredField(\u0026#34;value\u0026#34;); Field modifiersField = Field.class.getDeclaredField(\u0026#34;modifiers\u0026#34;); //这里要获取Field类的modifiers字段进行修改 modifiersField.setAccessible(true); modifiersField.setInt(field,field.getModifiers()\u0026amp;~Modifier.FINAL); //去除final标记 field.setAccessible(true); field.set(i, 100); //强行设置值 System.out.println(i); } 我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型：\npublic static void main(String[] args) throws ReflectiveOperationException { List\u0026lt;String\u0026gt; i = new ArrayList\u0026lt;\u0026gt;(); Field field = ArrayList.class.getDeclaredField(\u0026#34;size\u0026#34;); field.setAccessible(true); field.set(i, 10); i.add(\u0026#34;测试\u0026#34;); //只添加一个元素 System.out.println(i.size()); //大小直接变成11 i.remove(10); //瞎移除都不带报错的，淦 } 实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！\n再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！\n类加载器 我们接着来介绍一下类加载器，实际上类加载器就是用于加载一个类的，但是类加载器并不是只有一个。\n**思考：**既然说Class对象和加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，JVM会加载这个类吗？\npackage java.lang; public class String { //JDK提供的String类也是 public static void main(String[] args) { System.out.println(\u0026#34;我姓🐴，我叫🐴nb\u0026#34;); } } 我们发现，会出现以下报错：\n错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) 但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行：\n实际上类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader加载的，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了。\npublic class Main { public static void main(String[] args) { System.out.println(Main.class.getClassLoader()); //查看当前类的类加载器 System.out.println(Main.class.getClassLoader().getParent()); //父加载器 System.out.println(Main.class.getClassLoader().getParent().getParent()); //爷爷加载器 System.out.println(String.class.getClassLoader()); //String类的加载器 } } 由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。\n既然通过ClassLoader就可以加载类，那么我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：\npackage com.test; public class Test { public String text; public void test(String str){ System.out.println(text+\u0026#34; \u0026gt; 我是测试方法！\u0026#34;+str); } } 通过javac命令，手动编译一个.class文件：\nnagocoler@NagodeMacBook-Pro HelloWorld % javac src/main/java/com/test/Test.java 编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自定义的来让它支持：\n//定义一个自己的ClassLoader static class MyClassLoader extends ClassLoader{ public Class\u0026lt;?\u0026gt; defineClass(String name, byte[] b){ return defineClass(name, b, 0, b.length); //调用protected方法，支持载入外部class文件 } } public static void main(String[] args) throws IOException { MyClassLoader classLoader = new MyClassLoader(); FileInputStream stream = new FileInputStream(\u0026#34;Test.class\u0026#34;); byte[] bytes = new byte[stream.available()]; stream.read(bytes); Class\u0026lt;?\u0026gt; clazz = classLoader.defineClass(\u0026#34;com.test.Test\u0026#34;, bytes); //类名必须和我们定义的保持一致 System.out.println(clazz.getName()); //成功加载外部class文件 } 现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法：\ntry { Object obj = clazz.newInstance(); Method method = clazz.getMethod(\u0026#34;test\u0026#34;, String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \u0026#34;哥们这瓜多少钱一斤？\u0026#34;); }catch (Exception e){ e.printStackTrace(); } 我们来试试看修改成员字段之后，再来调用此方法：\ntry { Object obj = clazz.newInstance(); Field field = clazz.getField(\u0026#34;text\u0026#34;); //获取成员变量 String text; field.set(obj, \u0026#34;华强\u0026#34;); Method method = clazz.getMethod(\u0026#34;test\u0026#34;, String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \u0026#34;哥们这瓜多少钱一斤？\u0026#34;); }catch (Exception e){ e.printStackTrace(); } 通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。\n注解 **注意：**注解跟我们之前讲解的注释完全不是一个概念，不要搞混了。\n其实我们在之前就接触到注解了，比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。\n注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。\n预设注解 JDK预设了以下注解，作用于代码：\n@Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时） @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 元注解 元注解是作用于注解上的注解，用于我们编写自定义的注解：\n@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看@Override是如何定义的：\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } 该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。\n既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { } 这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：\n@Test public class Main { @Test public static void main(String[] args) { } } 这样，一个最简单的注解就被我们创建了。\n注解的使用 我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：\n@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value(); } 默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：\n@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String test(); } public class Main { @Test(test = \u0026#34;\u0026#34;) public static void main(String[] args) { } } 我们也可以使用default关键字来为这些属性指定默认值：\n@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value() default \u0026#34;都看到这里了，给个三连吧！\u0026#34;; } 当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？\n@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } 当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：\n@Test(\u0026#34;关注点了吗\u0026#34;) public static void main(String[] args) { } public class Main { @Test({\u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;}) //多个值时就使用花括号括起来 public static void main(String[] args) { } } 反射获取注解 既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：\npublic static void main(String[] args) { Class\u0026lt;Student\u0026gt; clazz = Student.class; for (Annotation annotation : clazz.getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } 通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：\npublic static void main(String[] args) throws NoSuchMethodException { Class\u0026lt;Student\u0026gt; clazz = Student.class; for (Annotation annotation : clazz.getMethod(\u0026#34;test\u0026#34;).getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } 无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。\n所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段作为初学者，还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，相信各位就能感受到注解带来的魅力了。\n结束语 Java的学习对你来说可能是枯燥的，可能是漫长的，也有可能是有趣的，无论如何，你终于是完成了全部内容的学习，可喜可贺。\n实际上很多人一开始跟着你们一起在进行学习，但是他们因为各种原因，最后还是没有走完这条路。坚持不一定会成功，但坚持到别人坚持不下去，那么你至少已经成功了一半了，坚持到最后的人运气往往都不会太差。\n希望各位小伙伴能够在之后的学习中砥砺前行！\n","permalink":"https://blog.l50.top/posts/javase%E7%AC%94%E8%AE%B0%E4%B8%83%E9%87%8D%E5%88%B6%E7%89%88/","summary":"多线程与反射 前面我们已经讲解了JavaSE的大部分核心内容，最后一章，我们还将继续学习JavaSE中提供的各种高级特性。这些高级特性对于我们之后的学习，会有着举足轻重的作用。\n多线程 **注意：**本章节会涉及到 操作系统 相关知识。\n在了解多线程之前，让我们回顾一下操作系统中提到的进程概念：\n进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。\n在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？\n后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。\n在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行main()方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程：\npublic static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); } } 关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。\n线程的创建和启动 通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：\n@FunctionalInterface public interface Runnable { /** * When an object implementing interface \u0026lt;code\u0026gt;Runnable\u0026lt;/code\u0026gt; is used * to create a thread, starting the thread causes the object\u0026#39;s * \u0026lt;code\u0026gt;run\u0026lt;/code\u0026gt; method to be called in that separately executing * thread.","title":"JavaSE笔记（七）重制版"},{"content":" 集合类与IO 前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。\n集合类 集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。\n集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。\n集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：\n它们都是容器，都能够容纳一组元素。 不同之处：\n数组的大小是固定的，集合的大小是可变的。 数组可以存放基本数据类型，但集合只能存放对象。 数组存放的类型只能是一种，但集合可以有不同种类的元素。 集合根接口 Java中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：\nimport java.util.ArrayList; //集合类基本都是在java.util包下定义的 public class Main { public static void main(String[] args) { ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;树脂666\u0026#34;); } } 当然，我们会在这一部分中认识大部分Java为我们提供的集合类。所有的集合类最终都是实现自集合根接口的，比如我们下面就会讲到的ArrayList类，它的祖先就是Collection接口：\n这个接口定义了集合类的一些基本操作，我们来看看有哪些方法：\npublic interface Collection\u0026lt;E\u0026gt; extends Iterable\u0026lt;E\u0026gt; { //-------这些是查询相关的操作---------- //获取当前集合中的元素数量 int size(); //查看当前集合是否为空 boolean isEmpty(); //查询当前集合中是否包含某个元素 boolean contains(Object o); //返回当前集合的迭代器，我们会在后面介绍 Iterator\u0026lt;E\u0026gt; iterator(); //将集合转换为数组的形式 Object[] toArray(); //支持泛型的数组转换，同上 \u0026lt;T\u0026gt; T[] toArray(T[] a); //-------这些是修改相关的操作---------- //向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求， //这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false boolean add(E e); //从集合中移除某个元素，同样的，移除成功返回true，否则false boolean remove(Object o); //-------这些是批量执行的操作---------- //查询当前集合是否包含给定集合中所有的元素 //从数学角度来说，就是看给定集合是不是当前集合的子集 boolean containsAll(Collection\u0026lt;?\u0026gt; c); //添加给定集合中所有的元素 //从数学角度来说，就是将当前集合变成当前集合与给定集合的并集 //添加成功返回true，否则返回false boolean addAll(Collection\u0026lt;? extends E\u0026gt; c); //移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素 //从数学角度来说，就是求当前集合与给定集合的差集 //移除成功返回true，否则false boolean removeAll(Collection\u0026lt;?\u0026gt; c); //Java8新增方法，根据给定的Predicate条件进行元素移除操作 default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator\u0026lt;E\u0026gt; each = iterator(); //这里用到了迭代器，我们会在后面进行介绍 while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } //只保留当前集合中在给定集合中出现的元素，其他元素一律移除 //从数学角度来说，就是求当前集合与给定集合的交集 //移除成功返回true，否则false boolean retainAll(Collection\u0026lt;?\u0026gt; c); //清空整个集合，删除所有元素 void clear(); //-------这些是比较以及哈希计算相关的操作---------- //判断两个集合是否相等 boolean equals(Object o); //计算当前整个集合对象的哈希值 int hashCode(); //与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍 @Override default Spliterator\u0026lt;E\u0026gt; spliterator() { return Spliterators.spliterator(this, 0); } //生成当前集合的流，我们会在后面进行讲解 default Stream\u0026lt;E\u0026gt; stream() { return StreamSupport.stream(spliterator(), false); } //生成当前集合的并行流，我们会在下一章多线程部分中进行介绍 default Stream\u0026lt;E\u0026gt; parallelStream() { return StreamSupport.stream(spliterator(), true); } } 可以看到，在这个接口中对于集合相关的操作，还是比较齐全的，那么我们接着就来看看它的实现类。\nList列表 首先我们需要介绍的是List列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。首先介绍ArrayList，我们已经知道，它的底层是用数组实现的，内部维护的是一个可动态进行扩容的数组，也就是我们之前所说的顺序表，跟我们之前自己写的ArrayList相比，它更加的规范，并且功能更加强大，同时实现自List接口。\nList是集合类型的一个分支，它的主要特性有：\n是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置 列表中允许存在重复元素 在List接口中，定义了列表类型需要支持的全部操作，List直接继承自前面介绍的Collection接口，其中很多地方重新定义了一次Collection接口中定义的方法，这样做是为了更加明确方法的具体功能，当然，为了直观，我们这里就省略掉：\n//List是一个有序的集合类，每个元素都有一个自己的下标位置 //List中可插入重复元素 //针对于这些特性，扩展了Collection接口中一些额外的操作 public interface List\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { ... //将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的） boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c); ... //Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果 default void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) { Objects.requireNonNull(operator); final ListIterator\u0026lt;E\u0026gt; li = this.listIterator(); //这里同样用到了迭代器 while (li.hasNext()) { li.set(operator.apply(li.next())); } } //对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了 @SuppressWarnings({\u0026#34;unchecked\u0026#34;, \u0026#34;rawtypes\u0026#34;}) default void sort(Comparator\u0026lt;? super E\u0026gt; c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator\u0026lt;E\u0026gt; i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } ... //-------- 这些是List中独特的位置直接访问操作 -------- //获取对应下标位置上的元素 E get(int index); //直接将对应位置上的元素替换为给定元素 E set(int index, E element); //在指定位置上插入元素，就跟我们之前的顺序表插入是一样的 void add(int index, E element); //移除指定位置上的元素 E remove(int index); //------- 这些是List中独特的搜索操作 ------- //查询某个元素在当前列表中的第一次出现的下标位置 int indexOf(Object o); //查询某个元素在当前列表中的最后一次出现的下标位置 int lastIndexOf(Object o); //------- 这些是List的专用迭代器 ------- //迭代器我们会在下一个部分讲解 ListIterator\u0026lt;E\u0026gt; listIterator(); //迭代器我们会在下一个部分讲解 ListIterator\u0026lt;E\u0026gt; listIterator(int index); //------- 这些是List的特殊转换 ------- //返回当前集合在指定范围内的子集 List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex); ... } 可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作。而在ArrayList中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多：\npublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { //默认的数组容量 private static final int DEFAULT_CAPACITY = 10; ... //存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途 transient Object[] elementData; //记录当前数组元素数的 private int size; //这是ArrayList的其中一个构造方法 public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { this.elementData = new Object[initialCapacity]; //根据初始化大小，创建当前列表 } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } ... public boolean add(E e) { ensureCapacityInternal(size + 1); // 这里会判断容量是否充足，不充足需要扩容 elementData[size++] = e; return true; } ... //默认的列表最大长度为Integer.MAX_VALUE - 8 //JVM都C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长 //度，所以这个8就是存了数组_length字段（这个只做了解就行） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); //扩容规则跟我们之前的是一样的，也是1.5倍 if (newCapacity - minCapacity \u0026lt; 0) //要是扩容之后的大小还没最小的大小大，那么直接扩容到最小的大小 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) //要是扩容之后比最大的大小还大，需要进行大小限制 newCapacity = hugeCapacity(minCapacity); //调整为限制的大小 elementData = Arrays.copyOf(elementData, newCapacity); //使用copyOf快速将内容拷贝到扩容后的新数组中并设定为新的elementData底层数组 } } 一般的，如果我们要使用一个集合类，我们会使用接口的引用：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); //使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类 list.add(\u0026#34;科技与狠活\u0026#34;); //使用add添加元素 list.add(\u0026#34;上头啊\u0026#34;); System.out.println(list); //打印集合类，可以得到一个非常规范的结果 } 可以看到，打印集合类的效果，跟我们使用Arrays工具类是一样的：\n集合的各种功能我们都可以来测试一下，特别注意一下，我们在使用Integer时，要注意传参问题：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(10); //添加Integer的值10 list.remove((Integer) 10); //注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象 System.out.println(list); //可以看到，此时元素成功被移除 } 那要是这样写呢？\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new Integer(10)); //添加的是一个对象 list.remove(new Integer(10)); //删除的是另一个对象 System.out.println(list); } 可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用equals方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用equals方法相等，那么集合中就是相同的两个对象：\n//ArrayList源码部分 public boolean remove(Object o) { if (o == null) { ... } else { for (int index = 0; index \u0026lt; size; index++) if (o.equals(elementData[index])) { //这里只是对两个对象进行equals判断 fastRemove(index); return true; //只要判断成功，直接认为就是要删除的对象，删除就完事 } } return false; } 列表中允许存在相同元素，所以说我们可以添加两个一模一样的：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String str = \u0026#34;哟唉嘛干你\u0026#34;; list.add(str); list.add(str); System.out.println(list); } 那要是此时我们删除对象呢，是一起删除还是只删除一个呢？\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String str = \u0026#34;哟唉嘛干你\u0026#34;; list.add(str); list.add(str); list.remove(str); System.out.println(list); } 可以看到，这种情况下，只会删除排在前面的第一个元素。\n集合类是支持嵌套使用的，一个集合中可以存放多个集合，套娃嘛，谁不会：\npublic static void main(String[] args) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); list.add(new LinkedList\u0026lt;\u0026gt;()); //集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的 System.out.println(list.get(0).isEmpty()); } 在Arrays工具类中，我们可以快速生成一个只读的List：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); //非常方便 System.out.println(list); } 注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)); System.out.println(list); } 当然，也可以利用静态代码块：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;() {{ //使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以） add(\u0026#34;A\u0026#34;); add(\u0026#34;B\u0026#34;); add(\u0026#34;C\u0026#34;); }}; System.out.println(list); } 这里我们接着介绍另一个列表实现类，LinkedList同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向：\npublic class LinkedList\u0026lt;E\u0026gt; extends AbstractSequentialList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable { transient int size = 0; //引用首结点 transient Node\u0026lt;E\u0026gt; first; //引用尾结点 transient Node\u0026lt;E\u0026gt; last; //构造方法，很简单，直接创建就行了 public LinkedList() { } ... private static class Node\u0026lt;E\u0026gt; { //内部使用的结点类 E item; Node\u0026lt;E\u0026gt; next; //不仅保存指向下一个结点的引用，还保存指向上一个结点的引用 Node\u0026lt;E\u0026gt; prev; Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } ... } LinkedList的使用和ArrayList的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。\n只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。\n迭代器 我们接着来介绍迭代器，实际上我们的集合类都是支持使用foreach语法的：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); for (String s : list) { //集合类同样支持这种语法 System.out.println(s); } } 但是由于仅仅是语法糖，实际上编译之后：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); Iterator var2 = list.iterator(); //这里使用的是List的迭代器在进行遍历操作 while(var2.hasNext()) { String s = (String)var2.next(); System.out.println(s); } } 那么这个迭代器是一个什么东西呢？我们来研究一下：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); //通过调用iterator方法快速获取当前集合的迭代器 //Iterator迭代器本身也是一个接口，由具体的集合实现类来根据情况实现 Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); } 通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是：\n一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针：\n每一次next操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用next将不能再得到下一个元素。至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。\n我们来看看这个接口的源码定义了哪些操作：\npublic interface Iterator\u0026lt;E\u0026gt; { //看看是否还有下一个元素 boolean hasNext(); //遍历当前元素，并将下一个元素作为待遍历元素 E next(); //移除上一个被遍历的元素（某些集合不支持这种操作） default void remove() { throw new UnsupportedOperationException(\u0026#34;remove\u0026#34;); } //对剩下的元素进行自定义遍历操作 default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } } 在ArrayList和LinkedList中，迭代器的实现也不同，比如ArrayList就是直接按下标访问：\npublic E next() { ... cursor = i + 1; //移动指针 return (E) elementData[lastRet = i]; //直接返回指针所指元素 } LinkedList就是不断向后寻找结点：\npublic E next() { ... next = next.next; //向后继续寻找结点 nextIndex++; return lastReturned.item; //返回结点内部存放的元素 } 虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现，我们该怎么去遍历：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { //每次循环一定要判断是否还有元素剩余 System.out.println(iterator.next()); //如果有就可以继续获取到下一个元素 } } 注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。为了简便，我们可以直接使用foreach语法来快速遍历集合类，效果是完全一样的：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); for (String s : list) { System.out.println(s); } } 在Java8提供了一个支持Lambda表达式的forEach方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); list.forEach(System.out::println); } 这个效果跟上面的写法是完全一样的，因为forEach方法内部本质上也是迭代器在处理，这个方法是在Iterable接口中定义的：\ndefault void forEach(Consumer\u0026lt;? super T\u0026gt; action) { Objects.requireNonNull(action); for (T t : this) { //foreach语法遍历每一个元素 action.accept(t); //调用Consumer的accept来对每一个元素进行消费 } } 那么我们来看一下，Iterable这个接口又是是什么东西？\n我们来看看定义了哪些内容：\n//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了 public interface Iterable\u0026lt;T\u0026gt; { //生成当前集合的迭代器，在Collection接口中重复定义了一次 Iterator\u0026lt;T\u0026gt; iterator(); //Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法 default void forEach(Consumer\u0026lt;? super T\u0026gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } //这个方法会在多线程部分中进行介绍，暂时不做讲解 default Spliterator\u0026lt;T\u0026gt; spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } } 得益于Iterable提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用foreach语法：\npublic class Test implements Iterable\u0026lt;String\u0026gt;{ //这里我们随便写一个类，让其实现Iterable接口 @Override public Iterator\u0026lt;String\u0026gt; iterator() { return new Iterator\u0026lt;String\u0026gt;() { //生成一个匿名的Iterator对象 @Override public boolean hasNext() { //这里随便写的，直接返回true，这将会导致无限循环 return true; } @Override public String next() { //每次就直接返回一个字符串吧 return \u0026#34;测试\u0026#34;; } }; } } 可以看到，直接就支持这种语法了，虽然我们这个是自己写的，并不是集合类：\npublic static void main(String[] args) { Test test = new Test(); for (String s : test) { System.out.println(s); } } 是不是感觉集合类的设计非常巧妙？\n我们这里再来介绍一下ListIterator，这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前：\npublic interface ListIterator\u0026lt;E\u0026gt; extends Iterator\u0026lt;E\u0026gt; { //原本就有的 boolean hasNext(); //原本就有的 E next(); //查看前面是否有已经遍历的元素 boolean hasPrevious(); //跟next相反，这里是倒着往回遍历 E previous(); //返回下一个待遍历元素的下标 int nextIndex(); //返回上一个已遍历元素的下标 int previousIndex(); //原本就有的 void remove(); //将上一个已遍历元素修改为新的元素 void set(E e); //在遍历过程中，插入新的元素到当前待遍历元素之前 void add(E e); } 我们来测试一下吧：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)); ListIterator\u0026lt;String\u0026gt; iterator = list.listIterator(); iterator.next(); //此时得到A iterator.set(\u0026#34;X\u0026#34;); //将A原本位置的上的元素设定为成新的 System.out.println(list); } 这种迭代器因为能够双向遍历，所以说可以反复使用。\nQueue和Deque 通过前面的学习，我们已经了解了List的使用，其中LinkedList除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口：\npublic class LinkedList\u0026lt;E\u0026gt; extends AbstractSequentialList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable { 这个Deque接口是干嘛的呢？我们先来看看它的继承结构：\n我们先来看看队列接口，它扩展了大量队列相关操作：\npublic interface Queue\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { //队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插） //如果插入失败，会直接抛出异常 boolean add(E e); //同样是添加操作，但是插入失败不会抛出异常 boolean offer(E e); //移除队首元素，但是如果队列已经为空，那么会抛出异常 E remove(); //同样是移除队首元素，但是如果队列为空，会返回null E poll(); //仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常 E element(); //同样是仅获取队首元素，但是如果队列为空，会返回null E peek(); } 我们可以直接将一个LinkedList当做一个队列来使用：\npublic static void main(String[] args) { Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); //当做队列使用，还是很方便的 queue.offer(\u0026#34;AAA\u0026#34;); queue.offer(\u0026#34;BBB\u0026#34;); System.out.println(queue.poll()); System.out.println(queue.poll()); } 我们接着来看双端队列，实际上双端队列就是队列的升级版，我们一个普通的队列就是：\n普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作：\n利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用，我们来看看Java中是如何定义的Deque双端队列接口的：\n//在双端队列中，所有的操作都有分别对应队首和队尾的 public interface Deque\u0026lt;E\u0026gt; extends Queue\u0026lt;E\u0026gt; { //在队首进行插入操作 void addFirst(E e); //在队尾进行插入操作 void addLast(E e); //不用多说了吧？ boolean offerFirst(E e); boolean offerLast(E e); //在队首进行移除操作 E removeFirst(); //在队尾进行移除操作 E removeLast(); //不用多说了吧？ E pollFirst(); E pollLast(); //获取队首元素 E getFirst(); //获取队尾元素 E getLast(); //不用多说了吧？ E peekFirst(); E peekLast(); //从队列中删除第一个出现的指定元素 boolean removeFirstOccurrence(Object o); //从队列中删除最后一个出现的指定元素 boolean removeLastOccurrence(Object o); // *** 队列中继承下来的方法操作是一样的，这里就不列出了 *** ... // *** 栈相关操作已经帮助我们定义好了 *** //将元素推向栈顶 void push(E e); //将元素从栈顶出栈 E pop(); // *** 集合类中继承的方法这里也不多种介绍了 *** ... //生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的 Iterator\u0026lt;E\u0026gt; descendingIterator(); } 我们可以来测试一下，比如我们可以直接当做栈来进行使用：\npublic static void main(String[] args) { Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); deque.push(\u0026#34;AAA\u0026#34;); deque.push(\u0026#34;BBB\u0026#34;); System.out.println(deque.pop()); System.out.println(deque.pop()); } 可以看到，得到的顺序和插入顺序是完全相反的，其实只要各位理解了前面讲解的数据结构，就很简单了。我们来测试一下反向迭代器和正向迭代器：\npublic static void main(String[] args) { Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); deque.addLast(\u0026#34;AAA\u0026#34;); deque.addLast(\u0026#34;BBB\u0026#34;); Iterator\u0026lt;String\u0026gt; descendingIterator = deque.descendingIterator(); System.out.println(descendingIterator.next()); Iterator\u0026lt;String\u0026gt; iterator = deque.iterator(); System.out.println(iterator.next()); } 可以看到，正向迭代器和反向迭代器的方向是完全相反的。\n当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了：\npublic static void main(String[] args) { Deque\u0026lt;String\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); //数组实现的栈和队列 Queue\u0026lt;String\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;(); //优先级队列 } 这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序：\npublic static void main(String[] args) { Queue\u0026lt;Integer\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;(); queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } 可以看到，我们的插入顺序虽然是10/4/5，但是出队顺序是按照优先级来的，类似于VIP用户可以优先结束排队。我们也可以自定义比较规则，同样需要给一个Comparator的实现：\npublic static void main(String[] args) { Queue\u0026lt;Integer\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); //按照从大到小顺序出队 queue.offer(10); queue.offer(4); queue.offer(5); System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); } 只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列只能保证出队顺序是按照优先级进行的，我们可以打印一下：\n想要了解优先级队列的具体是原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。\nSet集合 前面我们已经介绍了列表，我们接着来看Set集合，这种集合类型比较特殊，我们先来看看Set的定义：\npublic interface Set\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { // Set集合中基本都是从Collection直接继承过来的方法，只不过对这些方法有更加特殊的定义 int size(); boolean isEmpty(); boolean contains(Object o); Iterator\u0026lt;E\u0026gt; iterator(); Object[] toArray(); \u0026lt;T\u0026gt; T[] toArray(T[] a); //添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败 boolean add(E e); //这个同样是删除指定元素 boolean remove(Object o); boolean containsAll(Collection\u0026lt;?\u0026gt; c); //同样是只能插入那些不重复的元素 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c); boolean retainAll(Collection\u0026lt;?\u0026gt; c); boolean removeAll(Collection\u0026lt;?\u0026gt; c); void clear(); boolean equals(Object o); int hashCode(); //这个方法我们同样会放到多线程中进行介绍 @Override default Spliterator\u0026lt;E\u0026gt; spliterator() { return Spliterators.spliterator(this, Spliterator.DISTINCT); } } 我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过：\n不允许出现重复元素 不支持随机访问（不允许通过下标访问） 首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个HashMap在实现，这个需要我们学习了Map之后再来讨论）我们可以非常高效的从HashSet中存取元素，我们先来测试一下它的特性：\npublic static void main(String[] args) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); System.out.println(set.add(\u0026#34;AAA\u0026#34;)); //这里我们连续插入两个同样的字符串 System.out.println(set.add(\u0026#34;AAA\u0026#34;)); System.out.println(set); //可以看到，最后实际上只有一个成功插入了 } 在Set接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除Set中的某个对象：\npublic static void main(String[] args) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); System.out.println(set.add(\u0026#34;AAA\u0026#34;)); System.out.println(set.remove(\u0026#34;AAA\u0026#34;)); System.out.println(set); } 由于底层采用哈希表实现，所以说无法维持插入元素的顺序：\npublic static void main(String[] args) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.addAll(Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;+\u0026#34;)); System.out.println(set); } 那要是我们就是想要使用维持顺序的Set集合呢？我们可以使用LinkedHashSet，LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。\npublic static void main(String[] args) { Set\u0026lt;String\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.addAll(Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;+\u0026#34;)); System.out.println(set); } 还有一种Set叫做TreeSet，它会在元素插入时进行排序：\npublic static void main(String[] args) { TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); set.add(1); set.add(3); set.add(2); System.out.println(set); } 可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：\npublic static void main(String[] args) { TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); //同样是一个Comparator set.add(1); set.add(3); set.add(2); System.out.println(set); } 目前，Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。\nMap映射 什么是映射？我们在高中阶段其实已经学习过映射（Mapping）了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。\n而Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值，比如现在我们要保存很多学生的信息，而这些学生都有自己的ID，我们可以将其以映射的形式保存，将ID作为键，学生详细信息作为值，这样我们就可以通过学生的ID快速找到对应学生的信息了。\n在Map中，这些映射关系被存储为键值对，我们先来看看Map接口中定义了哪些操作：\n//Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊 //这里需要填写两个泛型参数，其中K就是键的类型，V就是值的类型，比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的 public interface Map\u0026lt;K,V\u0026gt; { //-------- 查询相关操作 -------- //获取当前存储的键值对数量 int size(); //是否为空 boolean isEmpty(); //查看Map中是否包含指定的键 boolean containsKey(Object key); //查看Map中是否包含指定的值 boolean containsValue(Object value); //通过给定的键，返回其映射的值 V get(Object key); //-------- 修改相关操作 -------- //向Map中添加新的映射关系，也就是新的键值对 V put(K key, V value); //根据给定的键，移除其映射关系，也就是移除对应的键值对 V remove(Object key); //-------- 批量操作 -------- //将另一个Map中的所有键值对添加到当前Map中 void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m); //清空整个Map void clear(); //-------- 其他视图操作 -------- //返回Map中存放的所有键，以Set形式返回 Set\u0026lt;K\u0026gt; keySet(); //返回Map中存放的所有值 Collection\u0026lt;V\u0026gt; values(); //返回所有的键值对，这里用的是内部类Entry在表示 Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet(); //这个是内部接口Entry，表示一个键值对 interface Entry\u0026lt;K,V\u0026gt; { //获取键值对的键 K getKey(); //获取键值对的值 V getValue(); //修改键值对的值 V setValue(V value); //判断两个键值对是否相等 boolean equals(Object o); //返回当前键值对的哈希值 int hashCode(); ... } ... } 当然，Map中定义了非常多的方法，尤其是在Java 8之后新增的大量方法，我们会在后面逐步介绍的。\n我们可以来尝试使用一下Map，实际上非常简单，这里我们使用最常见的HashMap，它的底层采用哈希表实现：\npublic static void main(String[] args) { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;小明\u0026#34;); //使用put方法添加键值对，返回值我们会在后面讨论 map.put(2, \u0026#34;小红\u0026#34;); System.out.println(map.get(2)); //使用get方法根据键获取对应的值 } 注意，Map中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的：\npublic static void main(String[] args) { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;小明\u0026#34;); map.put(1, \u0026#34;小红\u0026#34;); //这里的键跟之前的是一样的，这样会导致将之前的键值对覆盖掉 System.out.println(map.get(1)); } 为了防止意外将之前的键值对覆盖掉，我们可以使用：\npublic static void main(String[] args) { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;小明\u0026#34;); map.putIfAbsent(1, \u0026#34;小红\u0026#34;); //Java8新增操作，只有在不存在相同键的键值对时才会存放 System.out.println(map.get(1)); } 还有，我们在获取一个不存在的映射时，默认会返回null作为结果：\npublic static void main(String[] args) { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;小明\u0026#34;); //Map中只有键为1的映射 System.out.println(map.get(3)); //此时获取键为3的值，那肯定是没有的，所以说返回null } 我们也可以为这种情况添加一个预备方案，当Map中不存在时，可以返回一个备选的返回值：\npublic static void main(String[] args) { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;小明\u0026#34;); System.out.println(map.getOrDefault(3, \u0026#34;备胎\u0026#34;)); //Java8新增操作，当不存在对应的键值对时，返回备选方案 } 同样的，因为HashMap底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的：\npublic static void main(String[] args) { Map\u0026lt;String , String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;0\u0026#34;, \u0026#34;十七张\u0026#34;); map.put(\u0026#34;+\u0026#34;, \u0026#34;牌\u0026#34;); map.put(\u0026#34;P\u0026#34;, \u0026#34;你能秒我\u0026#34;); System.out.println(map); System.out.println(map.keySet()); System.out.println(map.values()); } 如果需要维护顺序，我们同样可以使用LinkedHashMap，它的内部对插入顺序进行了维护：\npublic static void main(String[] args) { Map\u0026lt;String , String\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;0\u0026#34;, \u0026#34;十七张\u0026#34;); map.put(\u0026#34;+\u0026#34;, \u0026#34;牌\u0026#34;); map.put(\u0026#34;P\u0026#34;, \u0026#34;你能秒我\u0026#34;); System.out.println(map); System.out.println(map.keySet()); System.out.println(map.values()); } 实际上Map的使用还是挺简单的，我们接着来看看Map的底层是如何实现的，首先是最简单的HashMap，我们前面已经说过了，它的底层采用的是哈希表，首先回顾我们之前学习的哈希表，我们当时说了，哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过连地址法解决这种问题，最后哈希表就长这样了：\n实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是这样的，我们来看看这里面是怎么定义的：\npublic class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable { ... static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { //内部使用结点，实际上就是存放的映射关系 final int hash; final K key; //跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键 V value; Node\u0026lt;K,V\u0026gt; next; ... } ... transient Node\u0026lt;K,V\u0026gt;[] table; //这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是头结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表） final float loadFactor; //负载因子，这个东西决定了HashMap的扩容效果 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; //当我们创建对象时，会使用默认的负载因子，值为0.75 } ... } 可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西：\nHashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板 HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构 我们来研究一下它的put方法：\npublic V put(K key, V value) { //这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果底层哈希表没初始化，先初始化 n = (tab = resize()).length; //通过resize方法初始化底层哈希表，初始容量为16，后续会根据情况扩容，底层哈希表的长度永远是2的n次方 //因为传入的哈希值可能会很大，这里同样是进行取余操作 //(n - 1) \u0026amp; hash 等价于 hash % n 这里的i就是最终得到的下标位置了 if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //如果这个位置上什么都没有，那就直接放一个新的结点 else { //这种情况就是哈希冲突了 Node\u0026lt;K,V\u0026gt; e; K k; if (p.hash == hash \u0026amp;\u0026amp; //如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作 ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; //这里直接将待插入结点等于原本冲突的结点，一会直接覆盖 else if (p instanceof TreeNode) //如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了 e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); //在红黑树中插入新的结点 else { for (int binCount = 0; ; ++binCount) { //普通链表就直接在链表尾部插入 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //找到尾部，直接创建新的结点连在后面 if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) //如果当前链表的长度已经很长了，达到了阈值 treeifyBin(tab, hash);\t//那么就转换为红黑树来存放 break; //直接结束 } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) //同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束，让p等于e一会覆盖就行了 break; p = e; } } if (e != null) { // 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所有直接覆盖就行 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; //覆盖之后，会返回原本的被覆盖值 } } ++modCount; if (++size \u0026gt; threshold) //键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容 resize(); //调用resize进行扩容 afterNodeInsertion(evict); return null; //正常插入键值对返回值为null } 是不是感觉只要前面的数据结构听懂了，这里简直太简单。根据上面的推导，我们在正常插入一个键值对时，会得到null返回值，而冲突时会得到一个被覆盖的值：\npublic static void main(String[] args) { Map\u0026lt;String , String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); System.out.println(map.put(\u0026#34;0\u0026#34;, \u0026#34;十七张\u0026#34;)); System.out.println(map.put(\u0026#34;0\u0026#34;, \u0026#34;慈善家\u0026#34;)); } 现在我们知道，当HashMap的一个链表长度过大时，会自动转换为红黑树：\n但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看resize()方法：\nfinal Node\u0026lt;K,V\u0026gt;[] resize() { Node\u0026lt;K,V\u0026gt;[] oldTab = table; //先把下面这几个旧的东西保存一下 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //这些是新的容量和扩容阈值 if (oldCap \u0026gt; 0) { //如果旧容量大于0，那么就开始扩容 if (oldCap \u0026gt;= MAXIMUM_CAPACITY) { //如果旧的容量已经大于最大限制了，那么直接给到 Integer.MAX_VALUE threshold = Integer.MAX_VALUE; return oldTab; //这种情况不用扩了 } else if ((newCap = oldCap \u0026lt;\u0026lt; 1) \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; oldCap \u0026gt;= DEFAULT_INITIAL_CAPACITY) //新的容量等于旧容量的2倍，同样不能超过最大值 newThr = oldThr \u0026lt;\u0026lt; 1; //新的阈值也提升到原来的两倍 } else if (oldThr \u0026gt; 0) // 旧容量不大于0只可能是还没初始化，这个时候如果阈值大于0，直接将新的容量变成旧的阈值 newCap = oldThr; else { // 默认情况下阈值也是0，也就是我们刚刚无参new出来的时候 newCap = DEFAULT_INITIAL_CAPACITY; //新的容量直接等于默认容量16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); //阈值为负载因子乘以默认容量，负载因子默认为0.75，也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了，反正作为新手，这些都是大佬写出来的，我们用就完事。 } ... threshold = newThr; @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] newTab = (Node\u0026lt;K,V\u0026gt;[])new Node[newCap]; table = newTab; //将底层数组变成新的扩容之后的数组 if (oldTab != null) { //如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去 ... //详细过程就不介绍了 } } 是不是感觉自己有点了解HashMap的运作机制了，其实并不是想象中的那么难，因为这些东西再怎么都是人写的。\n而LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序：\nstatic class Entry\u0026lt;K,V\u0026gt; extends HashMap.Node\u0026lt;K,V\u0026gt; { //LinkedHashMap中的结点实现 Entry\u0026lt;K,V\u0026gt; before, after; //这里多了一个指向前一个结点和后一个结点的引用 Entry(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { super(hash, key, value, next); } } 这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。\n当然还有一种比较特殊的Map叫做TreeMap，就像它的名字一样，就是一个Tree，它的内部直接维护了一个红黑树（没有使用哈希表）因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，直接给予一个比较规则即可，跟之前的TreeSet是一样的：\npublic static void main(String[] args) { Map\u0026lt;Integer , String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); map.put(0, \u0026#34;单走\u0026#34;); map.put(1, \u0026#34;一个六\u0026#34;); map.put(3, \u0026#34;**\u0026#34;); System.out.println(map); } 现在我们倒回来看之前讲解的HashSet集合，实际上它的底层很简单：\npublic class HashSet\u0026lt;E\u0026gt; extends AbstractSet\u0026lt;E\u0026gt; implements Set\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable { private transient HashMap\u0026lt;E,Object\u0026gt; map; //对，你没看错，底层直接用map来做事 // 因为Set只需要存储Key就行了，所以说这个对象当做每一个键值对的共享Value private static final Object PRESENT = new Object(); //直接构造一个默认大小为16负载因子0.75的HashMap public HashSet() { map = new HashMap\u0026lt;\u0026gt;(); } ... //你会发现所有的方法全是替身攻击 public Iterator\u0026lt;E\u0026gt; iterator() { return map.keySet().iterator(); } public int size() { return map.size(); } public boolean isEmpty() { return map.isEmpty(); } } 通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！\n再来看TreeSet，实际上用的就是我们的TreeMap：\npublic class TreeSet\u0026lt;E\u0026gt; extends AbstractSet\u0026lt;E\u0026gt; implements NavigableSet\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable { //底层需要一个NavigableMap，就是自动排序的Map private transient NavigableMap\u0026lt;E,Object\u0026gt; m; //不用我说了吧 private static final Object PRESENT = new Object(); ... //直接使用TreeMap解决问题 public TreeSet() { this(new TreeMap\u0026lt;E,Object\u0026gt;()); } ... } 同理，这里就不多做阐述了。\n我们接着来看看Map中定义的哪些杂七杂八的方法，首先来看看compute方法：\npublic static void main(String[] args) { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;A\u0026#34;); map.put(2, \u0026#34;B\u0026#34;); map.compute(1, (k, v) -\u0026gt; { //compute会将指定Key的值进行重新计算，若Key不存在，v会返回null return v+\u0026#34;M\u0026#34;; //这里返回原来的value+M }); map.computeIfPresent(1, (k, v) -\u0026gt; { //当Key存在时存在则计算并赋予新的值 return v+\u0026#34;M\u0026#34;; //这里返回原来的value+M }); System.out.println(map); } 也可以使用computeIfAbsent，当不存在Key时，计算并将键值对放入Map中：\npublic static void main(String[] args) { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;A\u0026#34;); map.put(2, \u0026#34;B\u0026#34;); map.computeIfAbsent(0, (k) -\u0026gt; { //若不存在则计算并插入新的值 return \u0026#34;M\u0026#34;; //这里返回M }); System.out.println(map); } merge方法用于处理数据：\npublic static void main(String[] args) { List\u0026lt;Student\u0026gt; students = Arrays.asList( new Student(\u0026#34;yoni\u0026#34;, \u0026#34;English\u0026#34;, 80), new Student(\u0026#34;yoni\u0026#34;, \u0026#34;Chiness\u0026#34;, 98), new Student(\u0026#34;yoni\u0026#34;, \u0026#34;Math\u0026#34;, 95), new Student(\u0026#34;taohai.wang\u0026#34;, \u0026#34;English\u0026#34;, 50), new Student(\u0026#34;taohai.wang\u0026#34;, \u0026#34;Chiness\u0026#34;, 72), new Student(\u0026#34;taohai.wang\u0026#34;, \u0026#34;Math\u0026#34;, 41), new Student(\u0026#34;Seely\u0026#34;, \u0026#34;English\u0026#34;, 88), new Student(\u0026#34;Seely\u0026#34;, \u0026#34;Chiness\u0026#34;, 89), new Student(\u0026#34;Seely\u0026#34;, \u0026#34;Math\u0026#34;, 92) ); Map\u0026lt;String, Integer\u0026gt; scoreMap = new HashMap\u0026lt;\u0026gt;(); //merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样： students.forEach(student -\u0026gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum)); scoreMap.forEach((k, v) -\u0026gt; System.out.println(\u0026#34;key:\u0026#34; + k + \u0026#34;总分\u0026#34; + \u0026#34;value:\u0026#34; + v)); } static class Student { private final String name; private final String type; private final int score; public Student(String name, String type, int score) { this.name = name; this.type = type; this.score = score; } public String getName() { return name; } public int getScore() { return score; } public String getType() { return type; } } replace方法可以快速替换某个映射的值：\npublic static void main(String[] args) { Map\u0026lt;Integer , String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, \u0026#34;单走\u0026#34;); map.replace(0, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026#34;); //直接替换为新的 System.out.println(map); } 也可以精准匹配：\npublic static void main(String[] args) { Map\u0026lt;Integer , String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, \u0026#34;单走\u0026#34;); map.replace(0, \u0026#34;巴卡\u0026#34;, \u0026#34;玛卡\u0026#34;); //只有键和值都匹配时，才进行替换 System.out.println(map); } 包括remove方法，也支持键值同时匹配：\npublic static void main(String[] args) { Map\u0026lt;Integer , String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, \u0026#34;单走\u0026#34;); map.remove(0, \u0026#34;单走\u0026#34;); //只有同时匹配时才移除 System.out.println(map); } 是不是感觉学习了Map之后，涨了不少姿势？\nStream流 Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。\n它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;A\u0026#34;); list.add(\u0026#34;B\u0026#34;); list.add(\u0026#34;C\u0026#34;); //移除为B的元素 Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); while (iterator.hasNext()){ if(iterator.next().equals(\u0026#34;B\u0026#34;)) iterator.remove(); } //Stream操作 list = list //链式调用 .stream() //获取流 .filter(e -\u0026gt; !e.equals(\u0026#34;B\u0026#34;)) //只允许所有不是B的元素通过流水线 .collect(Collectors.toList()); //将流水线中的元素重新收集起来，变回List System.out.println(list); } 可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //去重（使用equals判断） .sorted((a, b) -\u0026gt; b - a) //进行倒序排列 .map(e -\u0026gt; e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list); } 当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）\n注意：不能认为每一步是直接依次执行的！我们可以断点测试一下：\nList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //断点 .sorted((a, b) -\u0026gt; b - a) .map(e -\u0026gt; { System.out.println(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;+e); //断点 return e+1; }) .limit(2) //断点 .collect(Collectors.toList()); 实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行，也就是说需要的时候，工厂的机器才会按照预定的流程启动。\n接下来，我们用一堆随机数来进行更多流操作的演示：\npublic static void main(String[] args) { Random random = new Random(); //没想到吧，Random支持直接生成随机数的流 random .ints(-100, 100) //生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -\u0026gt; i \u0026lt; 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印 } 我们可以生成一个统计实例来帮助我们快速进行统计：\npublic static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值 } 普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -\u0026gt; i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics(); } 我们还可以通过flat来对整个流进行进一步细分：\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;A,B\u0026#34;); list.add(\u0026#34;C,D\u0026#34;); list.add(\u0026#34;E,F\u0026#34;); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -\u0026gt; Arrays.stream(e.split(\u0026#34;,\u0026#34;))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果 } 我们也可以只通过Stream来完成所有数字的和，使用reduce方法：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -\u0026gt; a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，通过get方法返回得到的值 System.out.println(sum); } 可能，作为新手来说，一次性无法接受这么多内容，但是在各位以后的开发中，就会慢慢使用到这些东西了。\nCollections工具类 我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。\n既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类，比如我们想快速求得List中的最大值和最小值：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Collections.max(list); Collections.min(list); } 同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现Comparable接口的类）：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Arrays.asList(2, 3, 8, 9, 10, 13); System.out.println(Collections.binarySearch(list, 8)); } 我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1,2,3,4,5)); Collections.fill(list, 6); System.out.println(list); } 如果集合中本身没有元素，那么fill操作不会生效。\n有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用emptyXXX来快速生成一个只读的空集合：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Collections.emptyList(); //Collections.singletonList() 会生成一个只有一个元素的List list.add(10); //不支持，会直接抛出异常 } 我们也可以将一个可修改的集合变成只读的集合：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1,2,3,4,5)); List\u0026lt;Integer\u0026gt; newList = Collections.unmodifiableList(list); newList.add(10); //不支持，会直接抛出异常 } 我们也可以寻找子集合的位置：\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1,2,3,4,5)); System.out.println(Collections.indexOfSubList(list, Arrays.asList(4, 5))); } 得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：\npublic static void main(String[] args) { //使用原始类型接收一个Integer类型的ArrayList List list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1,2,3,4,5)); list.add(\u0026#34;aaa\u0026#34;); //我们惊奇地发现，这玩意居然能存字符串进去 System.out.println(list); } 没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查：\npublic static void main(String[] args) { List list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1,2,3,4,5)); list = Collections.checkedList(list, Integer.class); //这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型 list.add(\u0026#34;aaa\u0026#34;); System.out.println(list); } checkedXXX可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：\n是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。\nJava I/O 注意：这块会涉及到操作系统和计算机组成原理相关内容。\nI/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。\n我们可以大致看一下整个计算机的总线结构：\n常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。\n而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，就可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。\n从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。\n（传统的SATA硬盘就是通过SATA线与电脑主板相连，这样才可以读取到数据）\nJDK提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer的IO框架，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成，而这类IO就是我们所说的BIO，\n字节流一次读取一个字节，也就是一个byte的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个char的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。\n文件字节流 要学习和使用IO，首先就要从最易于理解的读取文件开始说起。\n首先介绍一下FileInputStream，我们可以通过它来获取文件的输入流：\npublic static void main(String[] args) { try { //注意，IO相关操作会有很多影响因素，有可能出现异常，所以需要明确进行处理 FileInputStream inputStream = new FileInputStream(\u0026#34;路径\u0026#34;); //路径支持相对路径和绝对路径 } catch (FileNotFoundException e) { e.printStackTrace(); } } 相对路径是在当前运行目录（就是你在哪个目录运行java命令启动Java程序的）的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用/或是\\\\，但是不能写为\\因为它是转义字符！比如在Windows下：\nC://User/lbw/nb 这个就是一个绝对路径，因为是从盘符开始的 test/test 这个就是一个相对路径，因为并不是从盘符开始的，而是一个直接的路径 在Linux和MacOS下：\n/root/tmp 这个就是一个绝对路径，绝对路径以/开头 test/test 这个就是一个相对路径，不是以/开头的 当然，这个其实还是很好理解的，我们在使用时注意一下就行了。\n在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用：\npublic static void main(String[] args) { FileInputStream inputStream = null; //定义可以先放在try外部 try { inputStream = new FileInputStream(\u0026#34;路径\u0026#34;); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { //建议在finally中进行，因为关闭流是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } 虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法）\npublic static void main(String[] args) { //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(\u0026#34;路径\u0026#34;)) { //直接在try()中定义要在完成之后释放的资源 } catch (IOException e) { //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); } //无需再编写finally语句块，因为在最后自动帮我们调用了close() } 之后为了方便，我们都使用此语法进行教学。\n现在我们拿到了文件的输入流，那么怎么才能读取文件里面的内容呢？我们可以使用read方法：\npublic static void main(String[] args) { //test.txt：a try(FileInputStream inputStream = new FileInputStream(\u0026#34;test.txt\u0026#34;)) { //使用read()方法进行字符读取 System.out.println((char) inputStream.read()); //读取一个字节的数据（英文字母只占1字节，中文占2字节） System.out.println(inputStream.read()); //唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了 }catch (IOException e){ e.printStackTrace(); } } 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：\npublic static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\u0026#34;test.txt\u0026#34;)) { int tmp; while ((tmp = inputStream.read()) != -1){ //通过while循环来一次性读完内容 System.out.println((char)tmp); } }catch (IOException e){ e.printStackTrace(); } } 使用available方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量）\ntry(FileInputStream inputStream = new FileInputStream(\u0026#34;test.txt\u0026#34;)) { System.out.println(inputStream.available()); //查看剩余数量 }catch (IOException e){ e.printStackTrace(); } 当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放：\npublic static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\u0026#34;test.txt\u0026#34;)) { byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 }catch (IOException e){ e.printStackTrace(); } } 也可以控制要读取数量：\nSystem.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 注意：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1\n通过skip()方法可以跳过指定数量的字节：\npublic static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\u0026#34;test.txt\u0026#34;)) { System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 }catch (IOException e){ e.printStackTrace(); } } 注意：FileInputStream是不支持reset()的，虽然有这个方法，但是这里先不提及。\n既然有输入流，那么文件输出流也是必不可少的：\npublic static void main(String[] args) { //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(\u0026#34;output.txt\u0026#34;)) { //注意：若此文件不存在，会直接创建这个文件！ }catch (IOException e){ e.printStackTrace(); } } 输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容：\npublic static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\u0026#34;output.txt\u0026#34;)) { outputStream.write(\u0026#39;c\u0026#39;); //同read一样，可以直接写入内容 outputStream.write(\u0026#34;lbwnb\u0026#34;.getBytes()); //也可以直接写入byte[] outputStream.write(\u0026#34;lbwnb\u0026#34;.getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 }catch (IOException e){ e.printStackTrace(); } } 那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现：\npublic static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\u0026#34;output.txt\u0026#34;, true)) { //true表示开启追加模式 outputStream.write(\u0026#34;lb\u0026#34;.getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } 利用输入流和输出流，就可以轻松实现文件的拷贝了：\npublic static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\u0026#34;output.txt\u0026#34;); FileInputStream inputStream = new FileInputStream(\u0026#34;test.txt\u0026#34;)) { //可以写入多个 byte[] bytes = new byte[10]; //使用长度为10的byte[]做传输媒介 int tmp; //存储本地读取字节数 while ((tmp = inputStream.read(bytes)) != -1){ //直到读取完成为止 outputStream.write(bytes, 0, tmp); //写入对应长度的数据到输出流 } }catch (IOException e){ e.printStackTrace(); } } 文件字符流 字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用：\npublic static void main(String[] args) { try(FileReader reader = new FileReader(\u0026#34;test.txt\u0026#34;)){ reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 }catch (IOException e){ e.printStackTrace(); } } 同理，字符流只支持char[]类型作为存储：\npublic static void main(String[] args) { try(FileReader reader = new FileReader(\u0026#34;test.txt\u0026#34;)){ char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 }catch (IOException e){ e.printStackTrace(); } } 既然有了Reader肯定也有Writer：\npublic static void main(String[] args) { try(FileWriter writer = new FileWriter(\u0026#34;output.txt\u0026#34;)){ writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write(\u0026#39;牛\u0026#39;); writer.append(\u0026#39;牛\u0026#39;); //其实功能和write一样 writer.flush(); //刷新 }catch (IOException e){ e.printStackTrace(); } } 我们发现不仅有write()方法，还有一个append()方法，但是实际上他们效果是一样的，看源码：\npublic Writer append(char c) throws IOException { write(c); return this; } append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。\n练习：尝试一下用Reader和Writer来拷贝纯文本文件。\n这里需要额外介绍一下File类，它是专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。\npublic static void main(String[] args) { File file = new File(\u0026#34;test.txt\u0026#34;); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行 } 通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容：\nFile file = new File(\u0026#34;/\u0026#34;); System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表 for (File f : file.listFiles()){ //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径 } 如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：\nFile file = new File(\u0026#34;test.txt\u0026#34;); try (FileInputStream inputStream = new FileInputStream(file)){ //直接做参数 System.out.println(inputStream.available()); }catch (IOException e){ e.printStackTrace(); } 练习：尝试拷贝文件夹下的所有文件到另一个文件夹\n缓冲流 虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。\n要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：\npublic static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\u0026#34;test.txt\u0026#34;))){ //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 }catch (IOException e){ e.printStackTrace(); } } 实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式，我们会在设计模式篇中详细介绍。我们可以来观察一下它的close方法源码：\npublic void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { //CAS无锁算法，并发会用到，暂时不需要了解 InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() } } 实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。\n我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组：\n/** * The internal buffer array where the data is stored. When necessary, * it may be replaced by another array of * a different size. */ protected volatile byte buf[]; I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持reset()和mark()操作，首先我们来看看mark()方法的介绍：\n/** * Marks the current position in this input stream. A subsequent * call to the \u0026lt;code\u0026gt;reset\u0026lt;/code\u0026gt; method repositions this stream at * the last marked position so that subsequent reads re-read the same bytes. * \u0026lt;p\u0026gt; * The \u0026lt;code\u0026gt;readlimit\u0026lt;/code\u0026gt; argument tells this input stream to * allow that many bytes to be read before the mark position gets * invalidated. * \u0026lt;p\u0026gt; * This method simply performs \u0026lt;code\u0026gt;in.mark(readlimit)\u0026lt;/code\u0026gt;. * * @param readlimit the maximum limit of bytes that can be read before * the mark position becomes invalid. * @see java.io.FilterInputStream#in * @see java.io.FilterInputStream#reset() */ public synchronized void mark(int readlimit) { in.mark(readlimit); } 当调用mark()之后，输入流会以某种方式保留之后读取的readlimit数量的内容，当读取的内容数量超过readlimit则之后的内容不会被保留，当调用reset()之后，会使得当前的读取位置回到mark()调用时的位置。\npublic static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\u0026#34;test.txt\u0026#34;))){ bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } 我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。因此我们限制一下缓冲区大小，再来观察一下结果：\npublic static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\u0026#34;test.txt\u0026#34;), 1)){ //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } 了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作：\npublic static void main(String[] args) { try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(\u0026#34;output.txt\u0026#34;))){ outputStream.write(\u0026#34;lbwnb\u0026#34;.getBytes()); outputStream.flush(); }catch (IOException e) { e.printStackTrace(); } } 操作和FileOutputStream一致，这里就不多做介绍了。\n既然有缓冲字节流，那么肯定也有缓冲字符流，缓冲字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象：\npublic static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;test.txt\u0026#34;))){ System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } 使用和reader也是一样的，内部也包含一个缓存数组：\nprivate char cb[]; 相比Reader更方便的是，它支持按行读取：\npublic static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;test.txt\u0026#34;))){ System.out.println(reader.readLine()); //按行读取 }catch (IOException e) { e.printStackTrace(); } } 读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流：\npublic static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;test.txt\u0026#34;))){ reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); }catch (IOException e) { e.printStackTrace(); } } 它同样也支持mark()和reset()操作：\npublic static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;test.txt\u0026#34;))){ reader.mark(1); System.out.println((char) reader.read()); reader.reset(); System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便：\npublic static void main(String[] args) { try (BufferedWriter reader = new BufferedWriter(new FileWriter(\u0026#34;output.txt\u0026#34;))){ reader.newLine(); //使用newLine进行换行 reader.write(\u0026#34;汉堡做滴彳亍不彳亍\u0026#34;); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 }catch (IOException e) { e.printStackTrace(); } } 合理使用缓冲流，可以大大提高我们程序的运行效率，只不过现在初学阶段，很少会有机会接触到实际的应用场景。\n转换流 有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？\npublic static void main(String[] args) { try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\u0026#34;test.txt\u0026#34;))){ //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(\u0026#34;lbwnb\u0026#34;); //以操作Writer的样子写入OutputStream }catch (IOException e){ e.printStackTrace(); } } 同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现：\npublic static void main(String[] args) { try(InputStreamReader reader = new InputStreamReader(new FileInputStream(\u0026#34;test.txt\u0026#34;))){ //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); }catch (IOException e){ e.printStackTrace(); } } InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。\n打印流 打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。\npublic final static PrintStream out = null; 可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：\npublic static void main(String[] args) { try(PrintStream stream = new PrintStream(new FileOutputStream(\u0026#34;test.txt\u0026#34;))){ stream.println(\u0026#34;lbwnb\u0026#34;); //其实System.out就是一个PrintStream }catch (IOException e){ e.printStackTrace(); } } 我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。\n因此实际上内部还包含这两个内容：\n/** * Track both the text- and character-output streams, so that their buffers * can be flushed without flushing the entire stream. */ private BufferedWriter textOut; private OutputStreamWriter charOut; 与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。\n而我们之前使用的Scanner，使用的是系统提供的输入流：\npublic static void main(String[] args) { Scanner scanner = new Scanner(System.in); //系统输入流，默认是接收控制台输入 } 我们也可以使用Scanner来扫描其他的输入流：\npublic static void main(String[] args) throws FileNotFoundException { Scanner scanner = new Scanner(new FileInputStream(\u0026#34;秘制小汉堡.txt\u0026#34;)); //将文件内容作为输入流进行扫描 } 相当于直接扫描文件中编写的内容，同样可以读取。\n数据流 数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：\npublic static void main(String[] args) { try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(\u0026#34;test.txt\u0026#34;))){ System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 }catch (IOException e) { e.printStackTrace(); } } 用于写入基本数据类型：\npublic static void main(String[] args) { try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(\u0026#34;output.txt\u0026#34;))){ dataOutputStream.writeBoolean(false); }catch (IOException e) { e.printStackTrace(); } } 注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。\n对象流 既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。\npublic static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;output.txt\u0026#34;)); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;output.txt\u0026#34;))){ People people = new People(\u0026#34;lbw\u0026#34;); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ //必须实现Serializable接口才能被序列化 String name; public People(String name){ this.name = name; } } 在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：\nstatic class People implements Serializable{ private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name){ this.name = name; } } 当发生版本不匹配时，会无法反序列化为对象：\njava.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID = 123456, local class serialVersionUID = 1234567 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2003) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1850) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2160) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1667) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:503) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:461) at com.test.Main.main(Main.java:27) 如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字：\npublic static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;output.txt\u0026#34;)); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;output.txt\u0026#34;))){ People people = new People(\u0026#34;lbw\u0026#34;); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ private static final long serialVersionUID = 1234567; transient String name; public People(String name){ this.name = name; } } 其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。\n实战：图书管理系统 要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。\n","permalink":"https://blog.l50.top/posts/javase%E7%AC%94%E8%AE%B0%E5%85%AD%E9%87%8D%E5%88%B6%E7%89%88/","summary":"集合类与IO 前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。\n集合类 集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。\n集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。\n集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：\n它们都是容器，都能够容纳一组元素。 不同之处：\n数组的大小是固定的，集合的大小是可变的。 数组可以存放基本数据类型，但集合只能存放对象。 数组存放的类型只能是一种，但集合可以有不同种类的元素。 集合根接口 Java中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：\nimport java.util.ArrayList; //集合类基本都是在java.util包下定义的 public class Main { public static void main(String[] args) { ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;树脂666\u0026#34;); } } 当然，我们会在这一部分中认识大部分Java为我们提供的集合类。所有的集合类最终都是实现自集合根接口的，比如我们下面就会讲到的ArrayList类，它的祖先就是Collection接口：\n这个接口定义了集合类的一些基本操作，我们来看看有哪些方法：\npublic interface Collection\u0026lt;E\u0026gt; extends Iterable\u0026lt;E\u0026gt; { //-------这些是查询相关的操作---------- //获取当前集合中的元素数量 int size(); //查看当前集合是否为空 boolean isEmpty(); //查询当前集合中是否包含某个元素 boolean contains(Object o); //返回当前集合的迭代器，我们会在后面介绍 Iterator\u0026lt;E\u0026gt; iterator(); //将集合转换为数组的形式 Object[] toArray(); //支持泛型的数组转换，同上 \u0026lt;T\u0026gt; T[] toArray(T[] a); //-------这些是修改相关的操作---------- //向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求， //这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false boolean add(E e); //从集合中移除某个元素，同样的，移除成功返回true，否则false boolean remove(Object o); //-------这些是批量执行的操作---------- //查询当前集合是否包含给定集合中所有的元素 //从数学角度来说，就是看给定集合是不是当前集合的子集 boolean containsAll(Collection\u0026lt;?","title":"JavaSE笔记（六）重制版"},{"content":" 泛型程序设计 在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入了解，从泛型开始，再到数据结构，最后再开始我们的集合类学习，循序渐进。\n泛型 为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？\n现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？\npublic class Score { String name; String id; Object value; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object value) { this.name = name; this.id = id; this.score = value; } } 以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：\npublic static void main(String[] args) { Score score = new Score(\u0026#34;数据结构与算法基础\u0026#34;, \u0026#34;EP074512\u0026#34;, \u0026#34;优秀\u0026#34;); //是String类型的 ... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错 } 使用Object类型作为引用，对于使用者来说，由于是Object类型，所以说并不能直接判断存储的类型到底是String还是Integer，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺\n所以说这种解决办法虽然可行，但并不是最好的方案。\n为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。\n泛型类 泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。\n我们可以将一个类定义为一个泛型类：\npublic class Score\u0026lt;T\u0026gt; { //泛型类需要使用\u0026lt;\u0026gt;，我们需要在里面添加1 - N个类型变量 String name; String id; T value; //T会根据使用时提供的类型自动变成对应类型 public Score(String name, String id, T value) { //这里T可以是任何类型，但是一旦确定，那么就不能修改了 this.name = name; this.id = id; this.value = value; } } 我们来看看这是如何使用的：\npublic static void main(String[] args) { Score\u0026lt;String\u0026gt; score = new Score\u0026lt;String\u0026gt;(\u0026#34;计算机网络\u0026#34;, \u0026#34;EP074512\u0026#34;, \u0026#34;优秀\u0026#34;); //因为现在有了类型变量，在使用时同样需要跟上\u0026lt;\u0026gt;并在其中填写明确要使用的类型 //这样我们就可以根据不同的类型进行选择了 String value = score.value; //一旦类型明确，那么泛型就变成对应的类型了 System.out.println(value); } 泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用的：\n只不过这里需要注意一下，我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个Object类型的变量，因为无论具体类型是什么，一定是Object类的子类：\n我们可以对其进行强制类型转换，但是实际上没多大必要：\npublic void test(T t){ String str = (String) t; //都明确要用String了，那这里定义泛型不是多此一举吗 } 因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象和对应的数组：\n注意，具体类型不同的泛型类变量，不能使用不同的变量进行接收：\n如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用?通配符：\npublic static void main(String[] args) { Test\u0026lt;?\u0026gt; test = new Test\u0026lt;Integer\u0026gt;(); test = new Test\u0026lt;String\u0026gt;(); Object o = test.value; //但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成Object } 当然，泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个：\npublic class Test\u0026lt;A, B, C\u0026gt; { //多个类型变量使用逗号隔开 public A a; public B b; public C c; } 那么在使用时，就需要将这三种类型都进行明确指定：\npublic static void main(String[] args) { Test\u0026lt;String, Integer, Character\u0026gt; test = new Test\u0026lt;\u0026gt;(); //使用钻石运算符可以省略其中的类型 test.a = \u0026#34;lbwnb\u0026#34;; test.b = 10; test.c = \u0026#39;淦\u0026#39;; } 是不是感觉好像还是挺简单的？只要是在类中，都可以使用类型变量：\npublic class Test\u0026lt;T\u0026gt;{ private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } 只不过，泛型只能确定为一个引用类型，基本类型是不支持的：\npublic class Test\u0026lt;T\u0026gt;{ public T value; } 如果要存放基本数据类型的值，我们只能使用对应的包装类：\npublic static void main(String[] args) { Test\u0026lt;Integer\u0026gt; test = new Test\u0026lt;\u0026gt;(); } 当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的：\npublic static void main(String[] args) { Test\u0026lt;int[]\u0026gt; test = new Test\u0026lt;\u0026gt;(); } 通过使用泛型，我们就可以将某些不明确的类型在具体使用时再明确。\n泛型与多态 不只是类，包括接口、抽象类，都是可以支持泛型的：\npublic interface Study\u0026lt;T\u0026gt; { T test(); } 当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：\npublic class Main { public static void main(String[] args) { A a = new A(); Integer i = a.test(); } static class A implements Study\u0026lt;Integer\u0026gt; { //在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型 @Override public Integer test() { return null; } } } 或者是继续摆烂，依然使用泛型：\npublic class Main { public static void main(String[] args) { A\u0026lt;String\u0026gt; a = new A\u0026lt;\u0026gt;(); String i = a.test(); } static class A\u0026lt;T\u0026gt; implements Study\u0026lt;T\u0026gt; { //让子类继续为一个泛型类，那么可以不用明确 @Override public T test() { return null; } } } 继承也是同样的：\nstatic class A\u0026lt;T\u0026gt; { } static class B extends A\u0026lt;String\u0026gt; { } 泛型方法 当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。\n当某个方法（无论是是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：\npublic class Main { public static void main(String[] args) { String str = test(\u0026#34;Hello World!\u0026#34;); } private static \u0026lt;T\u0026gt; T test(T t){ //在返回值类型前添加\u0026lt;\u0026gt;并填写泛型变量表示这个是一个泛型方法 return t; } } 泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型T作为参数，同样的类型T作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成String类型，因此返回值也是String类型。\npublic static void main(String[] args) { String[] strings = new String[1]; Main main = new Main(); main.add(strings, \u0026#34;Hello\u0026#34;); System.out.println(Arrays.toString(strings)); } private \u0026lt;T\u0026gt; void add(T[] arr, T t){ arr[0] = t; } 实际上泛型方法在很多工具类中也有，比如说Arrays的排序方法：\nInteger[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator\u0026lt;Integer\u0026gt;() { //通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型 @Override public int compare(Integer o1, Integer o2) { //这个方法会在执行排序时被调用（别人来调用我们的实现） return 0; } }); 比如现在我们想要让数据从大到小排列，我们就可以自定义：\npublic static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { //两个需要比较的数会在这里给出 return o2 - o1; //compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于 //这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于 } }); System.out.println(Arrays.toString(arr)); } 因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：\npublic static void main(String[] args) { Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8}; Arrays.sort(arr, (o1, o2) -\u0026gt; o2 - o1); //瞬间变一行，效果跟上面是一样的 System.out.println(Arrays.toString(arr)); } 包括数组复制方法：\npublic static void main(String[] args) { String[] arr = {\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;}; String[] newArr = Arrays.copyOf(arr, 3); //这里传入的类型是什么，返回的类型就是什么，也是用到了泛型 System.out.println(Arrays.toString(newArr)); } 因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。\n泛型的界限 现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：\npublic class Score\u0026lt;T extends Number\u0026gt; { //设定类型参数上界，必须是Number或是Number的子类 private final String name; private final String id; private final T value; public Score(String name, String id, T value) { this.name = name; this.id = id; this.value = value; } public T getValue() { return value; } } 只需要在泛型变量的后面添加extends关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：\n实际上就像这样：\n同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：\npublic static void main(String[] args) { Score\u0026lt;? extends Integer\u0026gt; score = new Score\u0026lt;\u0026gt;(\u0026#34;数据结构与算法\u0026#34;, \u0026#34;EP074512\u0026#34;, 60); } 那么既然泛型有上界，那么有没有下界呢？肯定的啊：\n只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：\n那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？\npublic static void main(String[] args) { Score\u0026lt;? extends Number\u0026gt; score = new Score\u0026lt;\u0026gt;(\u0026#34;数据结构与算法基础\u0026#34;, \u0026#34;EP074512\u0026#34;, 10); Number o = score.getValue(); //可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界 } 但是我们限定下界的话，因为还是有可能是Object，所以说依然是跟之前一样：\npublic static void main(String[] args) { Score\u0026lt;? super Number\u0026gt; score = new Score\u0026lt;\u0026gt;(\u0026#34;数据结构与算法基础\u0026#34;, \u0026#34;EP074512\u0026#34;, 10); Object o = score.getValue(); } 通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。\n类型擦除 前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？\npublic abstract class A \u0026lt;T\u0026gt;{ abstract T test(T t); } 实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：\npublic abstract class A { abstract Object test(Object t); //默认就是Object } 当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：\npublic abstract class A \u0026lt;T extends Number\u0026gt;{ //设定上界为Number abstract T test(T t); } 那么编译之后：\npublic abstract class A { abstract Number test(Number t); //上界Number，因为现在只可能出现Number的子类 } 因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：\npublic static void main(String[] args) { Test test = new Test(); //对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型 } 只不过此时编译器会给出警告：\n同样的，由于类型擦除，实际上我们在使用时，编译后的代码是进行了强制类型转换的：\npublic static void main(String[] args) { A\u0026lt;String\u0026gt; a = new B(); String i = a.test(\u0026#34;10\u0026#34;); //因为类型A只有返回值为原始类型Object的方法 } 实际上编译之后：\npublic static void main(String[] args) { A a = new B(); String i = (String) a.test(\u0026#34;10\u0026#34;); //依靠强制类型转换完成的 } 不过，我们思考一个问题，既然继承泛型类之后可以明确具体类型，那么为什么@Override不会出现错误呢？我们前面说了，重写的条件是需要和父类的返回值类型和形参一致，而泛型默认的原始类型是Object类型，子类明确后变为其他类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？\npublic class B extends A\u0026lt;String\u0026gt;{ @Override String test(String s) { return null; } } 我们来看看编译之后长啥样：\n// Compiled from \u0026#34;B.java\u0026#34; public class com.test.entity.B extends com.test.entity.A\u0026lt;java.lang.String\u0026gt; { public com.test.entity.B(); java.lang.String test(java.lang.String); java.lang.Object test(java.lang.Object); //桥接方法，这才是真正重写的方法，但是使用时会调用上面的方法 } 通过反编译进行观察，实际上是编译器帮助我们生成了一个桥接方法用于支持重写：\npublic class B extends A { public Object test(Object obj) { //这才是重写的桥接方法 return this.test((Integer) obj); //桥接方法调用我们自己写的方法 } public String test(String str) { //我们自己写的方法 return null; } } 类型擦除机制其实就是为了方便使用后面集合类（不然每次都要强制类型转换）同时为了向下兼容采取的方案。因此，泛型的使用会有一些限制：\n首先，在进行类型判断时，不允许使用泛型，只能使用原始类型：\n只能判断是不是原始类型，里面的具体类型是不支持的：\nTest\u0026lt;String\u0026gt; test = new Test\u0026lt;\u0026gt;(); System.out.println(test instanceof Test); //在进行类型判断时，不允许使用泛型，只能使用原始类型 还有，泛型类型是不支持创建参数化类型数组的：\n要用只能用原始类型：\npublic static void main(String[] args) { Test[] test = new Test[10]; //同样是因为类型擦除导致的，运行时可不会去检查具体类型是什么 } 只不过只是把它当做泛型类型的数组还是可以用的：\n函数式接口 学习了泛型，我们来介绍一下再JDK 1.8中新增的函数式接口。\n函数式接口就是JDK1.8专门为我们提供好的用于Lambda表达式的接口，这些接口都可以直接使用Lambda表达式，非常方便，这里我们主要介绍一下四个主要的函数式接口：\n**Supplier供给型函数式接口：**这个接口是专门用于供给使用的，其中只有一个get方法用于获取需要的对象。\n@FunctionalInterface //函数式接口都会打上这样一个注解 public interface Supplier\u0026lt;T\u0026gt; { T get(); //实现此方法，实现供给功能 } 比如我们要实现一个专门供给Student对象Supplier，就可以使用：\npublic class Student { public void hello(){ System.out.println(\u0026#34;我是学生！\u0026#34;); } } //专门供给Student对象的Supplier private static final Supplier\u0026lt;Student\u0026gt; STUDENT_SUPPLIER = Student::new; public static void main(String[] args) { Student student = STUDENT_SUPPLIER.get(); student.hello(); } **Consumer消费型函数式接口：**这个接口专门用于消费某个对象的。\n@FunctionalInterface public interface Consumer\u0026lt;T\u0026gt; { void accept(T t); //这个方法就是用于消费的，没有返回值 default Consumer\u0026lt;T\u0026gt; andThen(Consumer\u0026lt;? super T\u0026gt; after) { //这个方法便于我们连续使用此消费接口 Objects.requireNonNull(after); return (T t) -\u0026gt; { accept(t); after.accept(t); }; } } 使用起来也是很简单的：\n//专门消费Student对象的Consumer private static final Consumer\u0026lt;Student\u0026gt; STUDENT_CONSUMER = student -\u0026gt; System.out.println(student+\u0026#34; 真好吃！\u0026#34;); public static void main(String[] args) { Student student = new Student(); STUDENT_CONSUMER.accept(student); } 当然，我们也可以使用andThen方法继续调用：\npublic static void main(String[] args) { Student student = new Student(); STUDENT_CONSUMER //我们可以提前将消费之后的操作以同样的方式预定好 .andThen(stu -\u0026gt; System.out.println(\u0026#34;我是吃完之后的操作！\u0026#34;)) .andThen(stu -\u0026gt; System.out.println(\u0026#34;好了好了，吃饱了！\u0026#34;)) .accept(student); //预定好之后，再执行 } 这样，就可以在消费之后进行一些其他的处理了，使用很简洁的代码就可以实现：\n**Function函数型函数式接口：**这个接口消费一个对象，然后会向外供给一个对象（前两个的融合体）\n@FunctionalInterface public interface Function\u0026lt;T, R\u0026gt; { R apply(T t); //这里一共有两个类型参数，其中一个是接受的参数类型，还有一个是返回的结果类型 default \u0026lt;V\u0026gt; Function\u0026lt;V, R\u0026gt; compose(Function\u0026lt;? super V, ? extends T\u0026gt; before) { Objects.requireNonNull(before); return (V v) -\u0026gt; apply(before.apply(v)); } default \u0026lt;V\u0026gt; Function\u0026lt;T, V\u0026gt; andThen(Function\u0026lt;? super R, ? extends V\u0026gt; after) { Objects.requireNonNull(after); return (T t) -\u0026gt; after.apply(apply(t)); } static \u0026lt;T\u0026gt; Function\u0026lt;T, T\u0026gt; identity() { return t -\u0026gt; t; } } 这个接口方法有点多，我们一个一个来看，首先还是最基本的apply方法，这个是我们需要实现的：\n//这里实现了一个简单的功能，将传入的int参数转换为字符串的形式 private static final Function\u0026lt;Integer, String\u0026gt; INTEGER_STRING_FUNCTION = Object::toString; public static void main(String[] args) { String str = INTEGER_STRING_FUNCTION.apply(10); System.out.println(str); } 我们可以使用compose将指定函数式的结果作为当前函数式的实参：\npublic static void main(String[] args) { String str = INTEGER_STRING_FUNCTION .compose((String s) -\u0026gt; s.length()) //将此函数式的返回值作为当前实现的实参 .apply(\u0026#34;lbwnb\u0026#34;); //传入上面函数式需要的参数 System.out.println(str); } 相反的，andThen可以将当前实现的返回值进行进一步的处理，得到其他类型的值：\npublic static void main(String[] args) { Boolean str = INTEGER_STRING_FUNCTION .andThen(String::isEmpty) //在执行完后，返回值作为参数执行andThen内的函数式，最后得到的结果就是最终的结果了 .apply(10); System.out.println(str); } 比较有趣的是，Function中还提供了一个将传入参数原样返回的实现：\npublic static void main(String[] args) { Function\u0026lt;String, String\u0026gt; function = Function.identity(); //原样返回 System.out.println(function.apply(\u0026#34;不会吧不会吧，不会有人听到现在还是懵逼的吧\u0026#34;)); } **Predicate断言型函数式接口：**接收一个参数，然后进行自定义判断并返回一个boolean结果。\n@FunctionalInterface public interface Predicate\u0026lt;T\u0026gt; { boolean test(T t); //这个方法就是我们要实现的 default Predicate\u0026lt;T\u0026gt; and(Predicate\u0026lt;? super T\u0026gt; other) { Objects.requireNonNull(other); return (t) -\u0026gt; test(t) \u0026amp;\u0026amp; other.test(t); } default Predicate\u0026lt;T\u0026gt; negate() { return (t) -\u0026gt; !test(t); } default Predicate\u0026lt;T\u0026gt; or(Predicate\u0026lt;? super T\u0026gt; other) { Objects.requireNonNull(other); return (t) -\u0026gt; test(t) || other.test(t); } static \u0026lt;T\u0026gt; Predicate\u0026lt;T\u0026gt; isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -\u0026gt; targetRef.equals(object); } } 我们可以来编写一个简单的例子：\npublic class Student { public int score; } private static final Predicate\u0026lt;Student\u0026gt; STUDENT_PREDICATE = student -\u0026gt; student.score \u0026gt;= 60; public static void main(String[] args) { Student student = new Student(); student.score = 80; if(STUDENT_PREDICATE.test(student)) { //test方法的返回值是一个boolean结果 System.out.println(\u0026#34;及格了，真不错，今晚奖励自己一次\u0026#34;); } else { System.out.println(\u0026#34;不是，Java都考不及格？隔壁初中生都在打ACM了\u0026#34;); } } 我们也可以使用组合条件判断：\npublic static void main(String[] args) { Student student = new Student(); student.score = 80; boolean b = STUDENT_PREDICATE .and(stu -\u0026gt; stu.score \u0026gt; 90) //需要同时满足这里的条件，才能返回true .test(student); if(!b) System.out.println(\u0026#34;Java到现在都没考到90分？你的室友都拿国家奖学金了\u0026#34;); } 同样的，这个类型提供了一个对应的实现，用于判断两个对象是否相等：\npublic static void main(String[] args) { Predicate\u0026lt;String\u0026gt; predicate = Predicate.isEqual(\u0026#34;Hello World\u0026#34;); //这里传入的对象会和之后的进行比较 System.out.println(predicate.test(\u0026#34;Hello World\u0026#34;)); } 通过使用这四个核心的函数式接口，我们就可以使得代码更加简洁，具体的使用场景会在后面讲解。\n判空包装 Java8还新增了一个非常重要的判空包装类Optional，这个类可以很有效的处理空指针问题。\n比如对于下面这样一个很简单的方法：\nprivate static void test(String str){ //传入字符串，如果不是空串，那么就打印长度 if(!str.isEmpty()) { System.out.println(\u0026#34;字符串长度为：\u0026#34;+str.length()); } } 但是如果我们在传入参数时，丢个null进去，直接原地爆炸：\npublic static void main(String[] args) { test(null); } private static void test(String str){ if(!str.isEmpty()) { //此时传入的值为null，调用方法马上得到空指针异常 System.out.println(\u0026#34;字符串长度为：\u0026#34;+str.length()); } } 因此我们还需要在使用之前进行判空操作：\nprivate static void test(String str){ if(str == null) return; //这样就可以防止null导致的异常了 if(!str.isEmpty()) { System.out.println(\u0026#34;字符串长度为：\u0026#34;+str.length()); } } 虽然这种方式很好，但是在Java8之后，有了Optional类，它可以更加优雅地处理这种问题，我们来看看如何使用：\nprivate static void test(String str){ Optional .ofNullable(str) //将传入的对象包装进Optional中 .ifPresent(s -\u0026gt; System.out.println(\u0026#34;字符串长度为：\u0026#34;+s.length())); //如果不为空，则执行这里的Consumer实现 } 优雅，真是太优雅了，同样的功能，现在我们只需要两行就搞定了，而且代码相当简洁。如果你学习过JavaScript或是Kotlin等语言，它的语法就像是：\nvar str : String? = null str?.upperCase() 并且，包装之后，我们再获取时可以优雅地处理为空的情况：\nprivate static void test(String str){ String s = Optional.ofNullable(str).get(); //get方法可以获取被包装的对象引用，但是如果为空的话，会抛出异常 System.out.println(s); } 我们可以对于这种有可能为空的情况进行处理，如果为空，那么就返回另一个备选方案：\nprivate static void test(String str){ String s = Optional.ofNullable(str).orElse(\u0026#34;我是为null的情况备选方案\u0026#34;); System.out.println(s); } 是不是感觉很方便？我们还可以将包装的类型直接转换为另一种类型：\nprivate static void test(String str){ Integer i = Optional .ofNullable(str) .map(String::length) //使用map来进行映射，将当前类型转换为其他类型，或者是进行处理 .orElse(-1); System.out.println(i); } 当然，Optional的方法比较多，这里就不一一介绍了。\n数据结构基础 **注意：**本部分内容难度很大，推荐计算机专业课程《数据结构与算法》作为前置学习课程。本部分介绍数据结构只是为了为后面的集合类型做准备。\n学习集合类之前，我们还有最关键的内容需要学习，同第二章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件（学习不要快餐式）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以在数据结构与算法篇视频教程中详细学习。\n在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。\n通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！\n比如现在我们需要保存100个学生的数据，那么你首先想到的肯定是使用数组吧！没错，没有什么比数组更适合存放这100个学生的数据了，但是如果我们现在有了新的需求呢？我们不仅仅是存放这些数据，我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。\n数组无法做到这么高级的功能，那么我们就需要定义一种更加高级的数据结构来做到，我们可以使用线性表（Linear List）\n线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。\n线性表一般需要包含以下功能：\n**获取指定位置上的元素：**直接获取线性表指定位置i上的元素。 **插入元素：**在指定位置i上插入一个元素。 **删除元素：**删除指定位置i上的一个元素。 **获取长度：**返回线性表的长度。 也就是说，现在我们需要设计的是一种功能完善的表结构，它不像是数组那么低级，而是真正意义上的表：\n简单来说它就是列表，比如我们的菜单，我们在点菜时就需要往菜单列表中添加菜品或是删除菜品，这时列表就很有用了，因为数组长度固定、操作简单，而我们添加菜品、删除菜品这些操作又要求长度动态变化、操作多样。\n那么，如此高级的数据结构，我们该如何去实现呢？实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现，我们先来看第一种，也是最简单的的一种。\n线性表：顺序表 前面我们说到，既然数组无法实现这样的高级表结构，那么我就基于数组，对其进行强化，也就是说，我们存放数据还是使用数组，但是我们可以为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为顺序表。\n这里我们可以先定义一个新的类型：\npublic class ArrayList\u0026lt;E\u0026gt; { //泛型E，因为表中要存的具体数据类型待定 int capacity = 10; //当前顺序表的容量 int size = 0; //当前已经存放的元素数量 private Object[] array = new Object[capacity]; //底层存放数据的数组 } 顺序表的插入和删除操作，其实就是：\n当插入元素时，需要将插入位置给腾出来，也就是将后面的所有元素向后移，同样的，如果要删除元素，那么也需要将所有的元素向前移动，顺序表是紧凑的，不能出现空位。\n所以说我们可以来尝试实现一下，首先是插入方法：\npublic void add(E element, int index){ //插入方法需要支持在指定下标位置插入 for (int i = size; i \u0026gt; index; i--) //从后往前，一个一个搬运元素 array[i] = array[i - 1]; array[index] = element; //腾出位置之后，直接插入元素放到对应位置上 size++; //插入完成之后，记得将size自增 } 只不过这样并不完美，因为我们的插入操作并不是在任何位置都支持插入的，我们允许插入的位置只能是 [0, size] 这个范围内\n所以说我们需要在插入之前进行判断：\npublic void add(E element, int index){ if(index \u0026lt; 0 || index \u0026gt; size) //插入之前先判断插入位置是否合法 throw new IndexOutOfBoundsException(\u0026#34;插入位置非法，合法的插入位置为：0 ~ \u0026#34;+size); for (int i = size; i \u0026gt; index; i--) array[i] = array[i - 1]; array[index] = element; size++; } 我们来测试一下吧：\npublic static void main(String[] args) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(10, 1); //一上来只能在第一个位置插入，第二个位置肯定是非法的 } 于是就成功得到异常：\n只不过依然不够完美，万一我们的顺序表装满了咋办？所以说，我们在插入元素之前，需要进行判断，如果已经装满了，那么我们需要先扩容之后才能继续插入新的元素：\npublic void add(E element, int index){ if(index \u0026lt; 0 || index \u0026gt; size) throw new IndexOutOfBoundsException(\u0026#34;插入位置非法，合法的插入位置为：0 ~ \u0026#34;+size); if(capacity == size) { int newCapacity = capacity + (capacity \u0026gt;\u0026gt; 1); //扩容规则就按照原本容量的1.5倍来吧 Object[] newArray = new Object[newCapacity]; //创建一个新的数组来存放更多的元素 System.arraycopy(array, 0, newArray, 0, size); //使用arraycopy快速拷贝原数组内容到新的数组 array = newArray; //更换为新的数组 capacity = newCapacity; //容量变成扩容之后的 } for (int i = size; i \u0026gt; index; i--) array[i] = array[i - 1]; array[index] = element; size++; } 我们来重写一下toString方法打印当前存放的元素：\npublic String toString() { StringBuilder builder = new StringBuilder(); for (int i = 0; i \u0026lt; size; i++) builder.append(array[i]).append(\u0026#34; \u0026#34;); return builder.toString(); } 可以看到，我们的底层数组会自动扩容，便于我们使用：\npublic static void main(String[] args) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 20; i++) list.add(i, i); System.out.println(list); } 我们接着来看删除操作，其实操作差不多，只需要将后面的覆盖到前面就可以了：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) //屏蔽未经检查警告 public E remove(int index){ //删除对应位置上的元素，注意需要返回被删除的元素 E e = (E) array[index]; //因为存放的是Object类型，这里需要强制类型转换为E for (int i = index; i \u0026lt; size; i++) //从前往后，挨个往前搬一位 array[i] = array[i + 1]; size--; //删完记得将size-- return e; } 同样的，我们需要对删除的合法范围进行判断：\n所以说我们也来进行一下判断：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E remove(int index){ if(index \u0026lt; 0 || index \u0026gt; size - 1) throw new IndexOutOfBoundsException(\u0026#34;删除位置非法，合法的插入位置为：0 ~ \u0026#34;+(size - 1)); E e = (E) array[index]; for (int i = index; i \u0026lt; size; i++) array[i] = array[i + 1]; size--; return e; } 因为删除不需要考虑容量的问题，所以说这里的删除操作就编写完成了。\n当然，我们还得支持获取指定下标位置上的元素，这个就简单了，直接从数组中那就行了：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E get(int index){ if(index \u0026lt; 0 || index \u0026gt; size - 1) //在插入之前同样要进行范围检查 throw new IndexOutOfBoundsException(\u0026#34;非法的位置，合法的位置为：0 ~ \u0026#34;+(size - 1)); return (E) array[index]; //直接返回就完事 } public int size(){ //获取当前存放的元素数量 return size; } 是不是感觉顺便表其实还是挺简单的，也就是一个数组多了一些操作罢了。\n线性表：链表 前面我们介绍了如何使用数组实现线性表，我们接着来看第二种方式，我们可以使用链表来实现，那么什么是链表呢？\n链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。\n链表分为带头结点的链表和不带头结点的链表，戴头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据：\n而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。\n我们来尝试定义一下：\npublic class LinkedList\u0026lt;E\u0026gt; { //链表的头结点，用于连接之后的所有结点 private final Node\u0026lt;E\u0026gt; head = new Node\u0026lt;\u0026gt;(null); private int size = 0; //当前的元素数量还是要存一下，方便后面操作 private static class Node\u0026lt;E\u0026gt; { //结点类，仅供内部使用 E element; //每个结点都存放元素 Node\u0026lt;E\u0026gt; next; //以及指向下一个结点的引用 public Node(E element) { this.element = element; } } } 接着我们来设计一下链表的插入和删除，我们前面实现了顺序表的插入，那么链表的插入该怎么做呢？\n我们可以先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点：\n接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点：\n这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上：\n按照这个思路，我们来实现一下，首先设计一下方法：\npublic void add(E element, int index){ Node\u0026lt;E\u0026gt; prev = head; //先找到对应位置的前驱结点 for (int i = 0; i \u0026lt; index; i++) prev = prev.next; Node\u0026lt;E\u0026gt; node = new Node\u0026lt;\u0026gt;(element); //创建新的结点 node.next = prev.next; //先让新的节点指向原本在这个位置上的结点 prev.next = node; //然后让前驱结点指向当前结点 size++; //完事之后一样的，更新size } 我们来重写一下toString方法看看能否正常插入：\n@Override public String toString() { StringBuilder builder = new StringBuilder(); Node\u0026lt;E\u0026gt; node = head.next; //从第一个结点开始，一个一个遍历，遍历一个就拼接到字符串上去 while (node != null) { builder.append(node.element).append(\u0026#34; \u0026#34;); node = node.next; } return builder.toString(); } 可以看到我们的插入操作是可以正常工作的：\npublic static void main(String[] args) { LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); list.add(10, 0); list.add(30, 0); list.add(20, 1); System.out.println(list); } 只不过还不够完美，跟之前一样，我们还得考虑插入位置是否合法：\npublic void add(E element, int index){ if(index \u0026lt; 0 || index \u0026gt; size) throw new IndexOutOfBoundsException(\u0026#34;插入位置非法，合法的插入位置为：0 ~ \u0026#34;+size); Node\u0026lt;E\u0026gt; prev = head; for (int i = 0; i \u0026lt; index; i++) prev = prev.next; Node\u0026lt;E\u0026gt; node = new Node\u0026lt;\u0026gt;(element); node.next = prev.next; prev.next = node; size++; } 插入操作完成之后，我们接着来看删除操作，那么我们如何实现删除操作呢？实际上也会更简单一些，我们可以直接将待删除节点的前驱结点指向修改为待删除节点的下一个：\n这样，在逻辑上来说，待删除结点其实已经不在链表中了，所以我们只需要释放掉待删除结点占用的内存空间就行了：\n那么我们就按照这个思路来编写一下程序：\npublic E remove(int index){ if(index \u0026lt; 0 || index \u0026gt; size - 1) //同样的，先判断位置是否合法 throw new IndexOutOfBoundsException(\u0026#34;删除位置非法，合法的删除位置为：0 ~ \u0026#34;+(size - 1)); Node\u0026lt;E\u0026gt; prev = head; for (int i = 0; i \u0026lt; index; i++) //同样需要先找到前驱结点 prev = prev.next; E e = prev.next.element; //先把待删除结点存放的元素取出来 prev.next = prev.next.next; //可以删了 size--; //记得size-- return e; } 是不是感觉还是挺简单的？这样，我们就成功完成了链表的删除操作。\n我们接着来实现一下获取对应位置上的元素：\npublic E get(int index){ if(index \u0026lt; 0 || index \u0026gt; size - 1) throw new IndexOutOfBoundsException(\u0026#34;非法的位置，合法的位置为：0 ~ \u0026#34;+(size - 1)); Node\u0026lt;E\u0026gt; node = head; while (index-- \u0026gt;= 0) //这里直接让index减到-1为止 node = node.next; return node.element; } public int size(){ return size; } 这样，我们的链表就编写完成了，实际上只要理解了那种结构，其实还是挺简单的。\n问题：什么情况下使用顺序表，什么情况下使用链表呢？\n通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。 而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。 虽然单链表使用起来也比较方便，不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针：\n这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表）\n线性表：栈 栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样：\n也就是说，我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，我们一般将其竖着看：\n底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out）\n实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们需要实现两个新的操作：\npop：出栈操作，从栈顶取出一个元素。 push：入栈操作，向栈中压入一个新的元素。 栈可以使用顺序表实现，也可以使用链表实现，这里我们就使用链表，实际上使用链表会更加的方便，我们可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点：\n当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下：\npublic class LinkedStack\u0026lt;E\u0026gt; { private final Node\u0026lt;E\u0026gt; head = new Node\u0026lt;\u0026gt;(null); //大体内容跟链表类似 private static class Node\u0026lt;E\u0026gt; { E element; Node\u0026lt;E\u0026gt; next; public Node(E element) { this.element = element; } } } 接着我们来编写一下入栈操作：\n代码如下：\npublic void push(E element){ Node\u0026lt;E\u0026gt; node = new Node\u0026lt;\u0026gt;(element); //直接创建新结点 node.next = head.next; //新结点的下一个变成原本的栈顶结点 head.next = node; //头结点的下一个改成新的结点 } 这样，我们就可以轻松实现入栈操作了。其实出栈也是同理，所以我们只需要将第一个元素移除即可：\npublic E pop(){ if(head.next == null) //如果栈已经没有元素了，那么肯定是没办法取的 throw new NoSuchElementException(\u0026#34;栈为空\u0026#34;); E e = head.next.element; //先把待出栈元素取出来 head.next = head.next.next; //直接让头结点的下一个指向下一个的下一个 return e; } 我们来测试一下吧：\npublic static void main(String[] args) { LinkedStack\u0026lt;String\u0026gt; stack = new LinkedStack\u0026lt;\u0026gt;(); stack.push(\u0026#34;AAA\u0026#34;); stack.push(\u0026#34;BBB\u0026#34;); stack.push(\u0026#34;CCC\u0026#34;); System.out.println(stack.pop()); System.out.println(stack.pop()); System.out.println(stack.pop()); } 可以看到，入栈顺序和出栈顺序是完全相反的：\n其实还是挺简单的。\n线性表：队列 前面我们学习了栈，栈中元素只能栈顶出入，它是一种特殊的线性表，同样的，队列（Queue）也是一种特殊的线性表。\n就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾：\n秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。\n队列也可以使用链表和顺序表来实现，只不过使用链表的话就不需要关心容量之类的问题了，会更加灵活一些：\n注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。\n当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位：\n出队时，只需要移除队首指向的下一个元素即可：\n那么我们就按照这个思路，来编写一下代码吧：\npublic class LinkedQueue\u0026lt;E\u0026gt; { private final Node\u0026lt;E\u0026gt; head = new Node\u0026lt;\u0026gt;(null); public void offer(E element){ //入队操作 Node\u0026lt;E\u0026gt; last = head; while (last.next != null) //入队直接丢到最后一个结点的屁股后面就行了 last = last.next; last.next = new Node\u0026lt;\u0026gt;(element); } public E poll(){ //出队操作 if(head.next == null) //如果队列已经没有元素了，那么肯定是没办法取的 throw new NoSuchElementException(\u0026#34;队列为空\u0026#34;); E e = head.next.element; head.next = head.next.next; //直接从队首取出 return e; } private static class Node\u0026lt;E\u0026gt; { E element; Node\u0026lt;E\u0026gt; next; public Node(E element) { this.element = element; } } } 其实使用起来还是挺简单的，我们来测试一下吧：\npublic static void main(String[] args) { LinkedQueue\u0026lt;String\u0026gt; stack = new LinkedQueue\u0026lt;\u0026gt;(); stack.offer(\u0026#34;AAA\u0026#34;); stack.offer(\u0026#34;BBB\u0026#34;); stack.offer(\u0026#34;CCC\u0026#34;); System.out.println(stack.poll()); System.out.println(stack.poll()); System.out.println(stack.poll()); } 可以看到，队列遵从先进先出，入队顺序和出队顺序是一样的。\n树：二叉树 树是一种全新的数据结构，它就像一棵树的树枝一样，不断延伸。\n在我们的程序中，想要表示出一棵树，就可以像下面这样连接：\n可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为树（Tree）注意分支只能向后单独延伸，之后就分道扬镳了，不能与其他分支上的结点相交！\n我们一般称位于最上方的结点为树的根结点（Root）因为整棵树正是从这里开始延伸出去的。 每个结点连接的子结点数目（分支的数目），我们称为结点的度（Degree），而各个结点度的最大值称为树的度。 每个结点延伸下去的下一个结点都可以称为一棵子树（SubTree）比如结点B及其之后延伸的所有分支合在一起，就是一棵A的子树。 每个结点的层次（Level）按照从上往下的顺序，树的根结点为1，每向下一层+1，比如G的层次就是3，整棵树中所有结点的最大层次，就是这颗树的深度（Depth），比如上面这棵树的深度为4，因为最大层次就是4。 由于整棵树错综复杂，所以说我们需要先规定一下结点之间的称呼，就像族谱那样：\n与当前结点直接向下相连的结点，我们称为子结点（Child），比如B、C、D结点，都是A的子结点，就像族谱中的父子关系一样，下一代一定是子女，相反的，那么A就是B、C、D的父结点（Parent），也可以叫双亲结点。 如果某个节点没有任何的子结点（结点度为0时）那么我们称这个结点为叶子结点（因为已经到头了，后面没有分支了，这时就该树枝上长叶子了那样）比如K、L、F、G、M、I、J结点，都是叶子结点。 如果两个结点的父结点是同一个，那么称这两个节点为兄弟结点（Sibling）比如B和C就是兄弟结点，因为都是A的孩子。 从根结点开始一直到某个结点的整条路径的所有结点，都是这个结点的祖先结点（Ancestor）比如L的祖先结点就是A、B、E 那么在了解了树的相关称呼之后，相信各位就应该对树有了一定的了解，虽然概念比较多，但是还请各位一定记住，不然后面就容易听懵。\n而我们本章需要着重讨论的是二叉树（Binary Tree）它是一种特殊的树，它的度最大只能为2，所以我们称其为二叉树，一棵二叉树大概长这样：\n并且二叉树任何结点的子树是有左右之分的，不能颠倒顺序，比如A结点左边的子树，称为左子树，右边的子树称为右子树。\n当然，对于某些二叉树我们有特别的称呼，比如，在一棵二叉树中，所有分支结点都存在左子树和右子树，且叶子结点都在同一层：\n这样的二叉树我们称为满二叉树，可以看到整棵树都是很饱满的，没有出现任何度为1的结点，当然，还有一种特殊情况：\n可以看到只有最后一层有空缺，并且所有的叶子结点是按照从左往右的顺序排列的，这样的二叉树我们一般称其为完全二叉树，所以，一棵满二叉树，一定是一棵完全二叉树。\n我们接着来看看二叉树在程序中的表示形式，我们在前面使用链表的时候，每个结点不仅存放对应的数据，而且会存放一个指向下一个结点的引用：\n而二叉树也可以使用这样的链式存储形式，只不过现在一个结点需要存放一个指向左子树的引用和一个指向右子树的引用了：\n通过这种方式，我们就可以通过连接不同的结点形成一颗二叉树了，这样也更便于我们去理解它，我们首先定义一个类：\npublic class TreeNode\u0026lt;E\u0026gt; { public E element; public TreeNode\u0026lt;E\u0026gt; left, right; public TreeNode(E element){ this.element = element; } } 比如我们现在想要构建一颗像这样的二叉树：\n首先我们需要创建好这几个结点：\npublic static void main(String[] args) { TreeNode\u0026lt;Character\u0026gt; a = new TreeNode\u0026lt;\u0026gt;(\u0026#39;A\u0026#39;); TreeNode\u0026lt;Character\u0026gt; b = new TreeNode\u0026lt;\u0026gt;(\u0026#39;B\u0026#39;); TreeNode\u0026lt;Character\u0026gt; c = new TreeNode\u0026lt;\u0026gt;(\u0026#39;C\u0026#39;); TreeNode\u0026lt;Character\u0026gt; d = new TreeNode\u0026lt;\u0026gt;(\u0026#39;D\u0026#39;); TreeNode\u0026lt;Character\u0026gt; e = new TreeNode\u0026lt;\u0026gt;(\u0026#39;E\u0026#39;); } 接着我们从最上面开始，挨着进行连接，首先是A这个结点：\npublic static void main(String[] args) { ... a.left = b; a.right = c; b.left = d; b.right = e; } 这样的话，我们就成功构建好了这棵二叉树，比如现在我们想通过根结点访问到D：\nSystem.out.println(a.left.left.element); 断点调试也可以看的很清楚：\n这样，我们就通过使用链式结构，成功构建出了一棵二叉树，接着我们来看看如何遍历一棵二叉树，也就是说我们想要访问二叉树的每一个结点，由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：**前序遍历、中序遍历、后序遍历、层序遍历。**不同的访问方式输出都结点顺序也不同。\n首先我们来看最简单的前序遍历：\n前序遍历是一种勇往直前的态度，走到哪就遍历到那里，先走左边再走右边，比如上面的这个图，首先会从根节点开始：\n从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：ABDECF\n打印根节点 前序遍历左子树 前序遍历右子树 我们不难发现规律，整棵二叉树（包括子树）的根节点一定是出现在最前面的，比如A在最前面，A的左子树根结点B也是在最前面的。我们现在就来尝试编写一下代码实现一下，先把二叉树构建出来：\npublic static void main(String[] args) { TreeNode\u0026lt;Character\u0026gt; a = new TreeNode\u0026lt;\u0026gt;(\u0026#39;A\u0026#39;); TreeNode\u0026lt;Character\u0026gt; b = new TreeNode\u0026lt;\u0026gt;(\u0026#39;B\u0026#39;); TreeNode\u0026lt;Character\u0026gt; c = new TreeNode\u0026lt;\u0026gt;(\u0026#39;C\u0026#39;); TreeNode\u0026lt;Character\u0026gt; d = new TreeNode\u0026lt;\u0026gt;(\u0026#39;D\u0026#39;); TreeNode\u0026lt;Character\u0026gt; e = new TreeNode\u0026lt;\u0026gt;(\u0026#39;E\u0026#39;); TreeNode\u0026lt;Character\u0026gt; f = new TreeNode\u0026lt;\u0026gt;(\u0026#39;F\u0026#39;); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; } 组装好之后，我们来实现一下前序遍历的方法：\nprivate static \u0026lt;T\u0026gt; void preOrder(TreeNode\u0026lt;T\u0026gt; root){ System.out.print(root.element + \u0026#34; \u0026#34;); //首先肯定要打印，这个是必须的 } 打印完成之后，我们就按照先左后右的规则往后遍历下一个结点，这里我们就直接使用递归来完成：\nprivate static \u0026lt;T\u0026gt; void preOrder(TreeNode\u0026lt;T\u0026gt; root){ System.out.print(root.element + \u0026#34; \u0026#34;); preOrder(root.left); //先走左边 preOrder(root.right); //再走右边 } 不过还没完，我们的递归肯定是需要一个终止条件的，不可能无限地进行下去，如果已经走到底了，那么就不能再往下走了，所以：\nprivate static \u0026lt;T\u0026gt; void preOrder(TreeNode\u0026lt;T\u0026gt; root){ if(root == null) return; System.out.print(root.element); preOrder(root.left); preOrder(root.right); } 最后我们来测试一下吧：\npublic static void main(String[] args) { ... preOrder(a); } 可以看到结果为：\n这样我们就通过一个简单的递归操作完成了对一棵二叉树的前序遍历，如果不太好理解，建议结合调试进行观察。\n那么前序遍历我们了解完了，接着就是中序遍历了，中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。\n我们还是以上面的二叉树为例：\n首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。\n中序遍历左子树 打印结点 中序遍历右子树 所以这棵二叉树的中序遍历结果为：DBEACF，我们可以发现一个规律，就是在某个结点的左子树中所有结点，其中序遍历结果也是按照这样的规律排列的，比如A的左子树中所有结点，中序遍历结果中全部都在A的左边，右子树中所有的结点，全部都在A的右边（这个规律很关键，后面在做一些算法题时会用到）\n那么怎么才能将打印调整到左子树全部遍历结束之后呢？其实很简单：\nprivate static \u0026lt;T\u0026gt; void inOrder(TreeNode\u0026lt;T\u0026gt; root){ if(root == null) return; inOrder(root.left); //先完成全部左子树的遍历 System.out.print(root.element); //等待左子树遍历完成之后再打印 inOrder(root.right); //然后就是对右子树进行遍历 } 我们只需要将打印放到左子树遍历之后即可，这样打印出来的结果就是中序遍历的结果了：\n这样，我们就实现了二叉树的中序遍历，实际上还是很好理解的。\n接着我们来看一下后序遍历，后序遍历继续将打印的时机延后，需要等待左右子树全部遍历完成，才会去进行打印。\n首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树，发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。\n后序遍历左子树 后序遍历右子树 打印结点 所以最后的遍历顺序为：DEBFCA，不难发现，整棵二叉树（包括子树）根结点一定是在后面的，比如A在所有的结点的后面，B在其子节点D、E的后面，这一点恰恰和前序遍历相反（注意不是得到的结果相反，是规律相反）\n所以，按照这个思路，我们来编写一下后序遍历：\nprivate static \u0026lt;T\u0026gt; void postOrder(TreeNode\u0026lt;T\u0026gt; root){ if(root == null) return; postOrder(root.left); postOrder(root.right); System.out.print(root.element); //时机延迟到最后 } 结果如下：\n最后我们来看层序遍历，实际上这种遍历方式是我们人脑最容易理解的，它是按照每一层在进行遍历：\n层序遍历实际上就是按照从上往下每一层，从左到右的顺序打印每个结点，比如上面的这棵二叉树，那么层序遍历的结果就是：ABCDEF，像这样一层一层的挨个输出。\n虽然理解起来比较简单，但是如果让你编程写出来，该咋搞？是不是感觉有点无从下手？\n我们可以利用队列来实现层序遍历，首先将根结点存入队列中，接着循环执行以下步骤：\n进行出队操作，得到一个结点，并打印结点的值。 将此结点的左右孩子结点依次入队。 不断重复以上步骤，直到队列为空。\n我们来分析一下，首先肯定一开始A在里面：\n接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队：\n现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队：\n现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队：\n我们发现，这个过程中，打印的顺序正好就是我们层序遍历的顺序，所以说队列还是非常有用的，这里我们可以直接把之前的队列拿来用。那么现在我们就来上代码吧，首先是之前的队列：\npublic class LinkedQueue\u0026lt;E\u0026gt; { private final Node\u0026lt;E\u0026gt; head = new Node\u0026lt;\u0026gt;(null); public void offer(E element){ Node\u0026lt;E\u0026gt; last = head; while (last.next != null) last = last.next; last.next = new Node\u0026lt;\u0026gt;(element); } public E poll(){ if(head.next == null) throw new NoSuchElementException(\u0026#34;队列为空\u0026#34;); E e = head.next.element; head.next = head.next.next; return e; } public boolean isEmpty(){ //这里多写了一个判断队列为空的操作，方便之后使用 return head.next == null; //直接看头结点后面还有没有东西就行了 } private static class Node\u0026lt;E\u0026gt; { E element; Node\u0026lt;E\u0026gt; next; public Node(E element) { this.element = element; } } } 我们来尝试编写一下层序遍历：\nprivate static \u0026lt;T\u0026gt; void levelOrder(TreeNode\u0026lt;T\u0026gt; root){ LinkedQueue\u0026lt;TreeNode\u0026lt;T\u0026gt;\u0026gt; queue = new LinkedQueue\u0026lt;\u0026gt;(); //创建一个队列 queue.offer(root); //将根结点丢进队列 while (!queue.isEmpty()) { //如果队列不为空，就一直不断地取出来 TreeNode\u0026lt;T\u0026gt; node = queue.poll(); //取一个出来 System.out.print(node.element); //打印 if(node.left != null) queue.offer(node.left); //如果左右孩子不为空，直接将左右孩子丢进队列 if(node.right != null) queue.offer(node.right); } } 可以看到结果就是层序遍历的结果：\n当然，使用递归也可以实现，但是需要单独存放结果然后单独输出，不是很方便，所以说这里就不演示了。\n树：二叉查找树和平衡二叉树 **注意：**本部分只进行理论介绍，不做代码实现。\n还记得我们开篇讲到的二分搜索算法吗？通过不断缩小查找范围，最终我们可以以很高的效率找到有序数组中的目标位置。而二叉查找树则利用了类似的思想，我们可以借助其来像二分搜索那样快速查找。\n二叉查找树也叫二叉搜索树或是二叉排序树，它具有一定的规则：\n左子树中所有结点的值，均小于其根结点的值。 右子树中所有结点的值，均大于其根结点的值。 二叉搜索树的子树也是二叉搜索树。 一棵二叉搜索树长这样：\n这棵树的根结点为18，而其根结点左边子树的根结点为10，包括后续结点，都是满足上述要求的。二叉查找树满足左边一定比当前结点小，右边一定比当前结点大的规则，比如我们现在需要在这颗树种查找值为15的结点：\n从根结点18开始，因为15小于18，所以从左边开始找。 接着来到10，发现10比15小，所以继续往右边走。 来到15，成功找到。 实际上，我们在对普通二叉树进行搜索时，可能需要挨个进行查看比较，而有了二叉搜索树，查找效率就大大提升了，它就像我们前面的二分搜索那样。\n利用二叉查找树，我们在搜索某个值的时候，效率会得到巨大提升。但是虽然看起来比较完美，也是存在缺陷的，比如现在我们依次将下面的值插入到这棵二叉树中：\n20 15 13 8 6 3 在插入完成后，我们会发现这棵二叉树竟然长这样：\n因为根据我们之前编写的插入规则，小的一律往左边放，现在正好来的就是这样一串递减的数字，最后就组成了这样的一棵只有一边的二叉树，这种情况，与其说它是一棵二叉树，不如说就是一个链表，如果这时我们想要查找某个结点，那么实际上查找的时间并没有得到任何优化，直接就退化成线性查找了。\n所以，二叉查找树只有在理想情况下，查找效率才是最高的，而像这种极端情况，就性能而言几乎没有任何的提升。我们理想情况下，这样的效率是最高的：\n所以，我们在进行结点插入时，需要尽可能地避免这种一边倒的情况，这里就需要引入平衡二叉树的概念了。实际上我们发现，在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡的情况，而我们理想中的二叉查找树左右是尽可能保持平衡的，平衡二叉树（AVL树）就是为了解决这样的问题而生的。\n它的性质如下：\n平衡二叉树一定是一棵二叉查找树。 任意结点的左右子树也是一棵平衡二叉树。 从根节点开始，左右子树都高度差不能超过1，否则视为不平衡。 可以看到，这些性质规定了平衡二叉树需要保持高度平衡，这样我们的查找效率才不会因为数据的插入而出现降低的情况。二叉树上节点的左子树高度 减去 右子树高度， 得到的结果称为该节点的平衡因子（Balance Factor），比如：\n通过计算平衡因子，我们就可以快速得到是否出现失衡的情况。比如下面的这棵二叉树，正在执行插入操作：\n可以看到，当插入之后，不再满足平衡二叉树的定义时，就出现了失衡的情况，而对于这种失衡情况，为了继续保持平衡状态，我们就需要进行处理了。我们可能会遇到以下几种情况导致失衡：\n根据插入结点的不同偏向情况，分为LL型、LR型、RR型、RL型。针对于上面这几种情况，我们依次来看一下如何进行调整，使得这棵二叉树能够继续保持平衡：\n动画网站：https://www.cs.usfca.edu/~galles/visualization/AVLtree.html（实在不理解可以看看动画是怎么走的）\nLL型调整（右旋）\n首先我们来看这种情况，这是典型的LL型失衡，为了能够保证二叉树的平衡，我们需要将其进行旋转来维持平衡，去纠正最小不平衡子树即可。那么怎么进行旋转呢？对于LL型失衡，我们只需要进行右旋操作，首先我们先找到最小不平衡子树，注意是最小的那一个：\n可以看到根结点的平衡因子是2，是目前最小的出现不平衡的点，所以说从根结点开始向左的三个结点需要进行右旋操作，右旋需要将这三个结点中间的结点作为新的根结点，而其他两个结点现在变成左右子树：\n这样，我们就完成了右旋操作，可以看到右旋之后，所有的结点继续保持平衡，并且依然是一棵二叉查找树。\nRR型调整（左旋）\n前面我们介绍了LL型以及右旋解决方案，相反的，当遇到RR型时，我们只需要进行左旋操作即可：\n操作和上面是一样的，只不过现在反过来了而已：\n这样，我们就完成了左旋操作，使得这棵二叉树继续保持平衡状态了。\nRL型调整（先右旋，再左旋）\n剩下两种类型比较麻烦，需要旋转两次才行。我们来看看RL型长啥样：\n可以看到现在的形状是一个回旋镖形状的，先右后左的一个状态，也就是RL型，针对于这种情况，我们需要先进行右旋操作，注意这里的右旋操作针对的是后两个结点：\n其中右旋和左旋的操作，与之前一样，该怎么分配左右子树就怎么分配，完成两次旋转后，可以看到二叉树重新变回了平衡状态。\nLR型调整（先左旋，再右旋）\n和上面一样，我们来看看LR型长啥样，其实就是反着的：\n形状是先向左再向右，这就是典型的LR型了，我们同样需要对其进行两次旋转：\n这里我们先进行的是左旋，然后再进行的右旋，这样二叉树就能继续保持平衡了。\n这样，我们只需要在插入结点时注意维护整棵树的平衡因子，保证其处于稳定状态，这样就可以让这棵树一直处于高度平衡的状态，不会再退化了。\n树：红黑树 **注意：**本部分只进行理论介绍，不做代码实现。\n很多人都说红黑树难，其实就那几条规则，跟着我推一遍其实还是很简单的，当然前提是一定要把前面的平衡二叉树搞明白。\n前面我们讲解了二叉平衡树，通过在插入结点时维护树的平衡，这样就不会出现极端情况使得整棵树的查找效率急剧降低了。但是这样是否开销太大了一点，因为一旦平衡因子的绝对值超过1那么就失衡，这样每插入一个结点，就有很大的概率会导致失衡，我们能否不这么严格，但同时也要在一定程度上保证平衡呢？这就要提到红黑树了。\n在线动画网站：https://www.cs.usfca.edu/~galles/visualization/RedBlack.html\n红黑树也是二叉查找树的一种，它大概长这样，可以看到结点有红有黑：\n它并不像平衡二叉树那样严格要求高度差不能超过1，而是只需要满足五个规则即可，它的规则如下：\n规则1：每个结点可以是黑色或是红色。 规则2：根结点一定是黑色。 规则3：红色结点的父结点和子结点不能为红色，也就是说不能有两个连续的红色。 规则4：所有的空结点都是黑色（空结点视为NIL，红黑树中是将空节点视为叶子结点） 规则5：每个结点到空节点（NIL）路径上出现的黑色结点的个数都相等。 它相比平衡二叉树，通过不严格平衡和改变颜色，就能在一定程度上减少旋转次数，这样的话对于整体性能是有一定提升的，只不过我们在插入结点时，就有点麻烦了，我们需要同时考虑变色和旋转这两个操作了，但是会比平衡二叉树更简单。\n那么什么时候需要变色，什么时候需要旋转呢？我们通过一个简单例子来看看：\n首先这棵红黑树只有一个根结点，因为根结点必须是黑色，所以说直接变成黑色。现在我们要插入一个新的结点了，所有新插入的结点，默认情况下都是红色：\n所以新来的结点7根据规则就直接放到11的左边就行了，然后注意7的左右两边都是NULL，那么默认都是黑色，这里就不画出来了。同样的，我们往右边也来一个：\n现在我们继续插入一个结点：\n插入结点4之后，此时违反了红黑树的规则3，因为红色结点的父结点和子结点不能为红色，此时为了保持以红黑树的性质，我们就需要进行颜色变换才可以，那么怎么进行颜色变换呢？我们只需要直接将父结点和其兄弟结点同时修改为黑色（为啥兄弟结点也需要变成黑色？因为要满足性质5）然后将爷爷结点改成红色即可：\n当然这里还需注意一下，因为爷爷结点正常情况会变成红色，相当于新来了个红色的，这时还得继续往上看有没有破坏红黑树的规则才可以，直到没有为止，比如这里就破坏了性质一，爷爷结点现在是根结点（不是根结点就不需要管了），必须是黑色，所以说还要给它改成黑色才算结束：\n接着我们继续插入结点：\n此时又来了一个插在4左边的结点，同样是连续红色，我们需要进行变色才可以讲解问题，但是我们发现，如果变色的话，那么从11开始到所有NIL结点经历的黑色结点数量就不对了：\n所以说对于这种父结点为红色，父结点的兄弟结点为黑色（NIL视为黑色）的情况，变色无法解决问题了，那么我们只能考虑旋转了，旋转规则和我们之前讲解的平衡二叉树是一样的，这实际上是一种LL型失衡：\n同样的，如果遇到了LR型失衡，跟前面一样，先左旋在右旋，然后进行变色即可：\n而RR型和RL型同理，这里就不进行演示了，可以看到，红黑树实际上也是通过颜色规则在进行旋转调整的，当然旋转和变色的操作顺序可以交换。所以，在插入时比较关键的判断点如下：\n如果整棵树为NULL，直接作为根结点，变成黑色。 如果父结点是黑色，直接插入就完事。 如果父结点为红色，且父结点的兄弟结点也是红色，直接变色即可（但是注意得继续往上看有没有破坏之前的结构） 如果父结点为红色，但父结点的兄弟结点为黑色，需要先根据情况（LL、RR、LR、RL）进行旋转，然后再变色。 在了解这些步骤之后，我们其实已经可以尝试去编写一棵红黑树出来了，当然代码太过复杂，这里就不演示了。\n哈希表 在之前，我们已经学习了多种查找数据的方式，比如最简单的，如果数据量不大的情况下，我们可以直接通过顺序查找的方式在集合中搜索我们想要的元素；当数据量较大时，我们可以使用二分搜索来快速找到我们想要的数据，不过需要要求数据按照顺序排列，并且不允许中途对集合进行修改。\n在学习完树形结构篇之后，我们可以利用二叉查找树来建立一个便于我们查找的树形结构，甚至可以将其优化为平衡二叉树或是红黑树来进一步提升稳定性。\n这些都能够极大地帮助我们查找数据，而散列表，则是我们数据结构系列内容的最后一块重要知识。\n散列（Hashing）通过散列函数（哈希函数）将要参与检索的数据与散列值（哈希值）关联起来，生成一种便于搜索的数据结构，我们称其为散列表（哈希表），也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了：\n散列函数也叫哈希函数，哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果，不同的目标计算出的结果介乎都不同。哈希函数在现实生活中应用十分广泛，比如很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整，哈希函数多种多样，目前应用最为广泛的是SHA-1和MD5，比如我们在下载IDEA之后，会看到有一个验证文件SHA-256校验和的选项，我们可以点进去看看：\n点进去之后，得到：\ne54a026da11d05d9bb0172f4ef936ba2366f985b5424e7eecf9e9341804d65bf *ideaIU-2022.2.1.dmg 这一串由数字和小写字母随意组合的一个字符串，就是安装包文件通过哈希算法计算得到的结果，那么这个东西有什么用呢？我们的网络可能有时候会出现卡顿的情况，导致我们下载的文件可能会出现不完整的情况，因为哈希函数对同一个文件计算得到的结果是一样的，我们可以在本地使用同样的哈希函数去计算下载文件的哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。\n可见，哈希函数在这些地方就显得非常实用，在我们的生活中起了很大的作用，它也可以用于布隆过滤器和负载均衡等场景，这里不多做介绍了。\n前面我们介绍了散列函数，我们知道可以通过散列函数计算一个目标的哈希值，那么这个哈希值计算出来有什么用呢，对我们的程序设计有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构，这种表结构是专为哈希设立的，我们称其为哈希表（散列表）\n我们可以将这些元素保存到哈希表中，而保存的位置则与其对应的哈希值有关，哈希值是通过哈希函数计算得到的，我们只需要将对应元素的关键字（一般是整数）提供给哈希函数就可以进行计算了，一般比较简单的哈希函数就是取模操作，哈希表长度是多少（长度最好是一个素数），模就是多少：\n比如现在我们需要插入一个新的元素（关键字为17）到哈希表中：\n插入的位置为计算出来的哈希值，比如上面是8，那么就在下标位置8插入元素，同样的，我们继续插入27：\n这样，我们就可以将多种多样的数据保存到哈希表中了，注意保存的数据是无序的，因为我们也不清楚计算完哈希值最后会放到哪个位置。那么如果现在我们想要从哈希表中查找数据呢？比如我们现在需要查找哈希表中是否有14这个元素：\n同样的，直接去看哈希值对应位置上看看有没有这个元素，如果没有，那么就说明哈希表中没有这个元素。可以看到，哈希表在查找时只需要进行一次哈希函数计算就能直接找到对应元素的存储位置，效率极高。\n我们来尝试编写一下：\npublic class HashTable\u0026lt;E\u0026gt; { private final int TABLE_SIZE = 10; private final Object[] TABLE = new Object[TABLE_SIZE]; public void insert(E element){ int index = hash(element); TABLE[index] = element; } public boolean contains(E element){ int index = hash(element); return TABLE[index] == element; } private int hash(Object object){ //哈希函数，计算出存放的位置 int hashCode = object.hashCode(); //每一个对象都有一个独一无二的哈希值，可以通过hashCode方法得到（只有极小的概率会出现相同的情况） return hashCode % TABLE_SIZE; } } 这样，我们就实现了一个简单的哈希表和哈希函数，通过哈希表，我们可以将数据的查找时间复杂度提升到常数阶。\n前面我介绍了哈希函数，通过哈希函数计算得到一个目标的哈希值，但是在某些情况下，哈希值可能会出现相同的情况：\n比如现在同时插入14和23这两个元素，他们两个计算出来的哈希值是一样的，都需要在5号下标位置插入，这时就出现了打架的情况，那么到底是把哪一个放进去呢？这种情况，我们称为哈希碰撞（哈希冲突）\n这种问题是很严重的，因为哈希函数的设计不同，难免会出现这种情况，这种情况是不可避免的，我们只能通过使用更加高级的哈希函数来尽可能避免这种情况，但是无法完全避免。当然，如果要完全解决这种问题，我们还需要去寻找更好的方法。这里我们只介绍一种比较重要的，会在后面集合类中用到的方案。\n实际上常见的哈希冲突解决方案是链地址法，当出现哈希冲突时，我们依然将其保存在对应的位置上，我们可以将其连接为一个链表的形式：\n当表中元素变多时，差不多就变成了这样，我们一般将其横过来看：\n通过结合链表的形式，哈希冲突问题就可以得到解决了，但是同时也会出现一定的查找开销，因为现在有了链表，我们得挨个往后看才能找到，当链表变得很长时，查找效率也会变低，此时我们可以考虑结合其他的数据结构来提升效率。比如当链表长度达到8时，自动转换为一棵平衡二叉树或是红黑树，这样就可以在一定程度上缓解查找的压力了。\npublic class HashTable\u0026lt;E\u0026gt; { private final int TABLE_SIZE = 10; private final Node\u0026lt;E\u0026gt;[] TABLE = new Node[TABLE_SIZE]; public HashTable(){ for (int i = 0; i \u0026lt; TABLE_SIZE; i++) TABLE[i] = new Node\u0026lt;\u0026gt;(null); } public void insert(E element){ int index = hash(element); Node\u0026lt;E\u0026gt; prev = TABLE[index]; while (prev.next != null) prev = prev.next; prev.next = new Node\u0026lt;\u0026gt;(element); } public boolean contains(E element){ int index = hash(element); Node\u0026lt;E\u0026gt; node = TABLE[index].next; while (node != null) { if(node.element == element) return true; node = node.next; } return false; } private int hash(Object object){ int hashCode = object.hashCode(); return hashCode % TABLE_SIZE; } private static class Node\u0026lt;E\u0026gt; { private final E element; private Node\u0026lt;E\u0026gt; next; private Node(E element){ this.element = element; } } } 实际上这种方案代码写起来也会更简单，使用也更方便一些。\n至此，数据结构相关内容，我们就讲解到这里，学习这些数据结构，实际上也是为了方便各位小伙伴对于后续结合类的学习，因为集合类的底层实现就是这些数据结构。\n实战练习 合理利用集合类，我们可以巧妙地解决各种各样的难题。\n反转链表 本题来自LeetCode：206. 反转链表\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]\n示例 2：\n输入：head = [1,2] 输出：[2,1]\n这道题依然是考察各位小伙伴对于链表相关操作的掌握程度，我们如何才能将一个链表的顺序进行反转，关键就在于如何修改每个节点的指针指向。\n括号匹配问题 本题来自LeetCode：20. 有效的括号\n给定一个只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026rsquo;}\u0026rsquo;，\u0026rsquo;[\u0026rsquo;，\u0026rsquo;]\u0026rsquo; 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1：\n输入：s = \u0026ldquo;()\u0026rdquo; 输出：true\n示例 2：\n输入：s = \u0026ldquo;()[]{}\u0026rdquo; 输出：true\n示例 3：\n输入：s = \u0026ldquo;(]\u0026rdquo; 输出：false\n示例 4：\n输入：s = \u0026ldquo;([)]\u0026rdquo; 输出：false\n示例 5：\n输入：s = \u0026ldquo;{[]}\u0026rdquo; 输出：true\n题干很明确，就是需要我们去对这些括号完成匹配，如果给定字符串中的括号无法完成一一匹配的话，那么就表示匹配失败。实际上这种问题我们就可以利用前面学习的栈这种数据结构来解决，我们可以将所有括号的左半部分放入栈中，当遇到右半部分时，进行匹配，如果匹配失败，那么就失败，如果匹配成功，那么就消耗一个左半部分，直到括号消耗完毕。\n实现计算器 输入一个计算公式（含加减乘除运算符，没有负数但是有小数）得到结果，比如输入：1+4*3/1.321，得到结果为：2.2\n现在请你设计一个Java程序，实现计算器。\n","permalink":"https://blog.l50.top/posts/javase%E7%AC%94%E8%AE%B0%E4%BA%94%E9%87%8D%E5%88%B6%E7%89%88/","summary":"泛型程序设计 在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入了解，从泛型开始，再到数据结构，最后再开始我们的集合类学习，循序渐进。\n泛型 为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？\n现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？\npublic class Score { String name; String id; Object value; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object value) { this.name = name; this.id = id; this.score = value; } } 以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：\npublic static void main(String[] args) { Score score = new Score(\u0026#34;数据结构与算法基础\u0026#34;, \u0026#34;EP074512\u0026#34;, \u0026#34;优秀\u0026#34;); //是String类型的 ... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错 } 使用Object类型作为引用，对于使用者来说，由于是Object类型，所以说并不能直接判断存储的类型到底是String还是Integer，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺\n所以说这种解决办法虽然可行，但并不是最好的方案。\n为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。\n泛型类 泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。\n我们可以将一个类定义为一个泛型类：\npublic class Score\u0026lt;T\u0026gt; { //泛型类需要使用\u0026lt;\u0026gt;，我们需要在里面添加1 - N个类型变量 String name; String id; T value; //T会根据使用时提供的类型自动变成对应类型 public Score(String name, String id, T value) { //这里T可以是任何类型，但是一旦确定，那么就不能修改了 this.","title":"JavaSE笔记（五）重制版"},{"content":" 面向对象高级篇 经过前面的学习，我们已经了解了面向对象编程的大部分基础内容，这一部分，我们将继续探索面向对象编程过程中一些常用的东西。\n基本类型包装类 Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！\n包装类介绍 所有的包装类层次结构如下：\n其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：\nbyte -\u0026gt; Byte boolean -\u0026gt; Boolean short -\u0026gt; Short char -\u0026gt; Character int -\u0026gt; Integer long -\u0026gt; Long float -\u0026gt; Float double -\u0026gt; Double 我们可以直接使用，这里我们以Integer类为例：\npublic static void main(String[] args) { Integer i = new Integer(10); //将10包装为一个Integer类型的变量 } 包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想）我们可以来看看Integer类中是怎么写的：\nprivate final int value; //类中实际上就靠这个变量在存储包装的值 public Integer(int value) { this.value = value; } 包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：\npublic static void main(String[] args) { Integer i = 10; //将int类型值作为包装类型使用 } 这是怎么做到的？为什么一个对象类型的值可以直接接收一个基本类类型的值？实际上这里就是自动装箱：\npublic static void main(String[] args) { Integer i = Integer.valueOf(10); //上面的写法跟这里是等价的 } 这里本质上就是被自动包装成了一个Integer类型的对象，只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的：\npublic static void main(String[] args) { Integer i = 10; int a = i; } 实际上上面的写法本质上就是：\npublic static void main(String[] args) { Integer i = 10; int a = i.intValue(); //通过此方法变成基本类型int值 } 这里就是自动拆箱，得益于包装类型的自动装箱和拆箱机制，我们可以让包装类型轻松地参与到基本类型的运算中：\npublic static void main(String[] args) { Integer a = 10, b = 20; int c = a * b; //直接自动拆箱成基本类型参与到计算中 System.out.println(c); } 因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：\npublic static void main(String[] args) { Integer a = new Integer(10); Integer b = new Integer(10); System.out.println(a == b); //虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假 } 那么自动装箱的呢？\npublic static void main(String[] args) { Integer a = 10, b = 10; System.out.println(a == b); } 我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：\npublic static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) //这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } IntegerCache会默认缓存-128~127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128~127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。\n但是如果超出这个缓存范围的话，就会得到不同的对象了：\npublic static void main(String[] args) { Integer a = 128, b = 128; System.out.println(a == b); } 这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制，感兴趣的小伙伴可以自己点进去看看。\n我们来看看包装类中提供了哪些其他的方法，包装类支持字符串直接转换：\npublic static void main(String[] args) { Integer i = new Integer(\u0026#34;666\u0026#34;); //直接将字符串的666，转换为数字666 System.out.println(i); } 当然，字符串转Integer有多个方法：\npublic static void main(String[] args) { Integer i = Integer.valueOf(\u0026#34;5555\u0026#34;); //Integer i = Integer.parseInt(\u0026#34;5555\u0026#34;); System.out.println(i); } 我们甚至可以对十六进制和八进制的字符串进行解码，得到对应的int值：\npublic static void main(String[] args) { Integer i = Integer.decode(\u0026#34;0xA6\u0026#34;); System.out.println(i); } 也可以将十进制的整数转换为其他进制的字符串：\npublic static void main(String[] args) { System.out.println(Integer.toHexString(166)); } 当然，Integer中提供的方法还有很多，这里就不一一列出了。\n特殊包装类 除了我们上面认识的这几种基本类型包装类之外，还有两个比较特殊的包装类型。\n其中第一个是用于计算超大数字的BigInteger，我们知道，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字：\npublic static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); //表示Long的最大值，轻轻松松 System.out.println(i); } 我们可以通过调用类中的方法，进行运算操作：\npublic static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); i = i.multiply(BigInteger.valueOf(Long.MAX_VALUE)); //即使是long的最大值乘以long的最大值，也能给你算出来 System.out.println(i); } 我们来看看结果：\n可以看到，此时数值已经非常大了，也可以轻松计算出来。咱们来点更刺激的：\npublic static void main(String[] args) { BigInteger i = BigInteger.valueOf(Long.MAX_VALUE); i = i.pow(100); //long的最大值来个100次方吧 System.out.println(i); } 可以看到，这个数字已经大到一排显示不下了：\n一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。\n我们接着来看第二种，前面我们说了，浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算。\npublic static void main(String[] args) { BigDecimal i = BigDecimal.valueOf(10); i = i.divide(BigDecimal.valueOf(3), 100, RoundingMode.CEILING); //计算10/3的结果，精确到小数点后100位 //RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整 System.out.println(i); } 可以看到，确实可以精确到这种程度：\n但是注意，对于这种结果没有终点的，无限循环的小数，我们必须要限制长度，否则会出现异常。\n数组 我们接着来看一个比较特殊的类型，数组。\n假设出现一种情况，我们想记录100个数字，要是采用定义100个变量的方式可以吗？是不是有点太累了？这种情况我们就可以使用数组来存放一组相同类型的数据。\n一维数组 数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，我们来看看如何去定义一个数组变量：\npublic static void main(String[] args) { int[] array; //类型[]就表示这个是一个数组类型 } 注意，数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建）即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用new 关键字：\npublic static void main(String[] args) { int[] array = new int[10]; //在创建数组时，需要指定数组长度，也就是可以容纳多个int变量的值 Object obj = array; //因为同样是类，肯定是继承自Object的，所以说可以直接向上转型 } 除了上面这种方式之外，我们也可以使用其他方式：\n类型[] 变量名称 = new 类型[数组大小]; 类型 变量名称[] = new 类型[数组大小]; //支持C语言样式，但不推荐！ 类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小） 类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的，要访问数组的某一个元素，我们可以：\npublic static void main(String[] args) { int[] array = new int[10]; System.out.println(\u0026#34;数组的第一个元素为：\u0026#34;+array[0]); //使用 变量名[下标] 的方式访问 } 注意，数组的下标是从0开始的，不是从1开始的，所以说第一个元素的下标就是0，我们要访问第一个元素，那么直接输入0就行了，但是注意千万别写成负数或是超出范围了，否则会出现异常。\n我们也可以使用这种方式为数组的元素赋值：\npublic static void main(String[] args) { int[] array = new int[10]; array[0] = 888; //就像使用变量一样，是可以放在赋值运算符左边的，我们可以直接给对应下标位置的元素赋值 System.out.println(\u0026#34;数组的第一个元素为：\u0026#34;+array[0]); } 因为数组本身也是一个对象，数组对象也是具有属性的，比如长度：\npublic static void main(String[] args) { int[] array = new int[10]; System.out.println(\u0026#34;当前数组长度为：\u0026#34;+array.length); //length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的 } 注意，这个length是在一开始就确定的，而且是final类型的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。\n当然，既然是类型，那么肯定也是继承自Object类的：\npublic static void main(String[] args) { int[] array = new int[10]; System.out.println(array.toString()); System.out.println(array.equals(array)); } 但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现：\n所以说通过toString()打印出来的结果，好丑，只不过我们可以发现，数组类型的类名很奇怪，是[开头的。\n因此，如果我们要打印整个数组中所有的元素，得一个一个访问：\npublic static void main(String[] args) { int[] array = new int[10]; for (int i = 0; i \u0026lt; array.length; i++) { System.out.print(array[i] + \u0026#34; \u0026#34;); } } 有时候为了方便，我们可以使用简化版的for语句foreach语法来遍历数组中的每一个元素：\npublic static void main(String[] args) { int[] array = new int[10]; for (int i : array) { //int i就是每一个数组中的元素，array就是我们要遍历的数组 System.out.print(i+\u0026#34; \u0026#34;); //每一轮循环，i都会更新成数组中下一个元素 } } 是不是感觉这种写法更加简洁？只不过这仅仅是语法糖而已，编译之后依然是跟上面一样老老实实在遍历的：\npublic static void main(String[] args) { //反编译的结果 int[] array = new int[10]; int[] var2 = array; int var3 = array.length; for(int var4 = 0; var4 \u0026lt; var3; ++var4) { int i = var2[var4]; System.out.print(i + \u0026#34; \u0026#34;); } } 对于这种普通的数组，其实使用还是挺简单的。这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：\npublic static void main(String[] args) { int[] arr = new int[10]; Integer[] test = arr; } 还有，由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的：\n但是如果是引用类型的话，是可以的：\npublic static void main(String[] args) { String[] arr = new String[10]; Object[] array = arr; //数组同样支持向上转型 } public static void main(String[] args) { Object[] arr = new Object[10]; String[] array = (String[]) arr; //也支持向下转型 } 多维数组 前面我们介绍了简单的数组（一维数组）既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的，套娃嘛，谁不会：\npublic static void main(String[] args) { int[][] array = new int[2][10]; //数组类型数组那么就要写两个[]了 } 存放数组的数组，相当于将维度进行了提升，比如上面的就是一个2x10的数组：\n这个中数组一共有2个元素，每个元素都是一个存放10个元素的数组，所以说最后看起来就像一个矩阵一样。甚至可以继续套娃，将其变成一个三维数组，也就是存放数组的数组的数组。\npublic static void main(String[] args) { int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; //一个三行两列的数组 System.out.println(arr[2][1]); //访问第三行第二列的元素 } 在访问多维数组时，我们需要使用多次[]运算符来得到对应位置的元素。如果我们要遍历多维数组话，那么就需要多次嵌套循环：\npublic static void main(String[] args) { int[][] arr = new int[][]{{1, 2}, {3, 4}, {5, 6}}; for (int i = 0; i \u0026lt; 3; i++) { //要遍历一个二维数组，那么我们得一列一列一行一行地来 for (int j = 0; j \u0026lt; 2; j++) { System.out.println(arr[i][j]); } } } 可变长参数 我们接着来看数组的延伸应用，实际上我们的方法是支持可变长参数的，什么是可变长参数？\npublic class Person { String name; int age; String sex; public void test(String... strings){ } } 我们在使用时，可以传入0 - N个对应类型的实参：\npublic static void main(String[] args) { Person person = new Person(); person.test(\u0026#34;1！\u0026#34;, \u0026#34;5！\u0026#34;, \u0026#34;哥们在这跟你说唱\u0026#34;); //这里我们可以自由传入任意数量的字符串 } 那么我们在方法中怎么才能得到这些传入的参数呢，实际上可变长参数本质就是一个数组：\npublic void test(String... strings){ //strings这个变量就是一个String[]类型的 for (String string : strings) { System.out.println(string); //遍历打印数组中每一个元素 } } 注意，如果同时存在其他参数，那么可变长参数只能放在最后：\npublic void test(int a, int b, String... strings){ } 这里最后我们再来说一个从开始到现在一直都没有说的东西：\npublic static void main(String[] args) { //这个String[] args到底是个啥？？？ } 实际上这个是我们在执行Java程序时，输入的命令行参数，我们可以来打印一下：\npublic static void main(String[] args) { for (String arg : args) { System.out.println(arg); } } 可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：\njava com/test/Main lbwnb aaaa xxxxx #放在包中需要携带主类完整路径才能运行 可以看到，我们在后面随意添加的三个参数，都放到数组中了：\n这个东西我们作为新手一般也不会用到，只做了解就行了。\n字符串 字符串类是一个比较特殊的类，它用于保存字符串。我们知道，基本类型char可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组）Java中没有字符串这种基本类型，因此只能使用类来进行定义。注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。\nString类 String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象：\npublic static void main(String[] args) { String str = \u0026#34;Hello World!\u0026#34;; } 我们也可以象征性地使用一下new关键字：\npublic static void main(String[] args) { String str = new String(\u0026#34;Hello World!\u0026#34;); //这种方式就是创建一个新的对象 } 注意，如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象：\npublic static void main(String[] args) { String str1 = \u0026#34;Hello World\u0026#34;; String str2 = \u0026#34;Hello World\u0026#34;; System.out.println(str1 == str2); } 但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了：\npublic static void main(String[] args) { String str1 = new String(\u0026#34;Hello World\u0026#34;); String str2 = new String(\u0026#34;Hello World\u0026#34;); System.out.println(str1 == str2); } 至于为什么会出现这种情况，我们在JVM篇视频教程中会进行详细的介绍，这里各位小伙伴只需要记住就行了。因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用==，String类重载了equals方法用于判断和比较内容是否相同：\npublic static void main(String[] args) { String str1 = new String(\u0026#34;Hello World\u0026#34;); String str2 = new String(\u0026#34;Hello World\u0026#34;); System.out.println(str1.equals(str2)); //字符串的内容比较，一定要用equals } 既然String也是一个类，那么肯定是具有一些方法的，我们可以来看看：\npublic static void main(String[] args) { String str = \u0026#34;Hello World\u0026#34;; System.out.println(str.length()); //length方法可以求字符串长度，这个长度是字符的数量 } 因为双引号括起来的字符串本身就是一个实例对象，所以说我们也可以直接用：\npublic static void main(String[] args) { System.out.println(\u0026#34;Hello World\u0026#34;.length()); //虽然看起来挺奇怪的，但是确实支持这种写法 } 字符串类中提供了很多方便我们操作的方法，比如字符串的裁剪、分割操作：\npublic static void main(String[] args) { String str = \u0026#34;Hello World\u0026#34;; String sub = str.substring(0, 3); //分割字符串，并返回一个新的子串对象 System.out.println(sub); } public static void main(String[] args) { String str = \u0026#34;Hello World\u0026#34;; String[] strings = str.split(\u0026#34; \u0026#34;); //使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组 for (String string : strings) { System.out.println(string); } } 字符数组和字符串之间是可以快速进行相互转换的：\npublic static void main(String[] args) { String str = \u0026#34;Hello World\u0026#34;; char[] chars = str.toCharArray(); System.out.println(chars); } public static void main(String[] args) { char[] chars = new char[]{\u0026#39;奥\u0026#39;, \u0026#39;利\u0026#39;, \u0026#39;给\u0026#39;}; String str = new String(chars); System.out.println(str); } 当然，String类还有很多其他的一些方法，这里就不一一介绍了。\nStringBuilder类 我们在之前的学习中已经了解，字符串支持使用+和+=进行拼接操作。\n但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：\npublic static void main(String[] args) { String str = \u0026#34;杰哥\u0026#34; + \u0026#34;你干嘛\u0026#34;; //我们在写代码时使用的是拼接的形式 System.out.println(str); } 编译之后就变成这样了：\npublic static void main(String[] args) { String str = \u0026#34;杰哥你干嘛\u0026#34;; System.out.println(str); } 对于变量来说，也有优化，比如下面这种情况：\npublic static void main(String[] args) { String str1 = \u0026#34;你看\u0026#34;; String str2 = \u0026#34;这\u0026#34;; String str3 = \u0026#34;汉堡\u0026#34;; String str4 = \u0026#34;做滴\u0026#34;; String str5 = \u0026#34;行不行\u0026#34;; String result = str1 + str2 + str3 + str4 + str5; //5个变量连续加 System.out.println(result); } 如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？这种情况实际上会被优化为下面的写法：\npublic static void main(String[] args) { String str1 = \u0026#34;你看\u0026#34;; String str2 = \u0026#34;这\u0026#34;; String str3 = \u0026#34;汉堡\u0026#34;; String str4 = \u0026#34;做滴\u0026#34;; String str5 = \u0026#34;行不行\u0026#34;; StringBuilder builder = new StringBuilder(); builder.append(str1).append(str2).append(str3).append(str4).append(str5); System.out.println(builder.toString()); } 这里创建了一个StringBuilder的类型，这个类型是干嘛的呢？实际上它就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足：\npublic static void main(String[] args) { StringBuilder builder = new StringBuilder(); //一开始创建时，内部什么都没有 builder.append(\u0026#34;AAA\u0026#34;); //我们可以使用append方法来讲字符串拼接到后面 builder.append(\u0026#34;BBB\u0026#34;); System.out.println(builder.toString()); //当我们字符串编辑完成之后，就可以使用toString转换为字符串了 } 它还支持裁剪等操作：\npublic static void main(String[] args) { StringBuilder builder = new StringBuilder(\u0026#34;AAABBB\u0026#34;); //在构造时也可以指定初始字符串 builder.delete(2, 4); //删除2到4这个范围内的字符 System.out.println(builder.toString()); } 当然，StringBuilder类的编辑操作也非常多，这里就不一一列出了。\n正则表达式 我们现在想要实现这样一个功能，对于给定的字符串进行判断，如果字符串符合我们的规则，那么就返回真，否则返回假，比如现在我们想要判断字符串是不是邮箱的格式：\npublic static void main(String[] args) { String str = \u0026#34;aaaa731341@163.com\u0026#34;; //假设邮箱格式为 数字/字母@数字/字母.com } 那么现在请你设计一个Java程序用于判断，你该怎么做？是不是感觉很麻烦，但是我们使用正则表达式就可以很轻松解决这种字符串格式匹配问题。\n正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n我们先来看看下面的这个例子：\npublic static void main(String[] args) { String str = \u0026#34;oooo\u0026#34;; //matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false System.out.println(str.matches(\u0026#34;o+\u0026#34;)); //+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配 } 用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：\n字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \u0026ldquo;z\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;。***** 等价于 {0,}。 + 匹配前面的子表达式一次或多次。例如，zo+ 能匹配 \u0026ldquo;zo\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;，但不能匹配 \u0026ldquo;z\u0026rdquo;。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 \u0026ldquo;do\u0026rdquo; 、 \u0026ldquo;does\u0026rdquo;、 \u0026ldquo;doxy\u0026rdquo; 中的 \u0026ldquo;do\u0026rdquo; 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 o，但是能匹配 \u0026ldquo;food\u0026rdquo; 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 o，但能匹配 \u0026ldquo;foooood\u0026rdquo; 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。 {n,m} m 和 n 均为非负整数，其中 n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 \u0026ldquo;fooooood\u0026rdquo; 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。 如果我们想要表示一个范围内的字符，可以使用方括号：\npublic static void main(String[] args) { String str = \u0026#34;abcabccaa\u0026#34;; System.out.println(str.matches(\u0026#34;[abc]*\u0026#34;)); //表示abc这几个字符可以出现 0 - N 次 } 对于普通字符来说，我们可以下面的方式实现多种字符匹配：\n字符 描述 [ABC] 匹配 [\u0026hellip;] 中的所有字符，例如 [aeiou] 匹配字符串 \u0026ldquo;google runoob taobao\u0026rdquo; 中所有的 e o u a 字母。 [^ABC] 匹配除了 [\u0026hellip;] 中字符的所有字符，例如 [^aeiou] 匹配字符串 \u0026ldquo;google runoob taobao\u0026rdquo; 中除了 e o u a 字母的所有字母。 [A-Z] [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。 . 匹配除换行符（\\n、\\r）之外的任何单个字符，相等于 [^\\n\\r] [\\s\\S] 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，不包括换行。 \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_] 当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：https://www.runoob.com/regexp/regexp-syntax.html\n正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。\n内部类 上一章我们详细介绍了类，我们现在已经知道该如何创建类、使用类了。当然，类的创建其实可以有多种多样的方式，并不仅仅局限于普通的创建。内部类顾名思义，就是创建在内部的类，那么具体是什么的内部呢，我们接着就来讨论一下。\n**注意：**内部类很多地方都很绕，所以说一定要仔细思考。\n成员内部类 我们可以直接在类的内部定义成员内部类：\npublic class Test { public class Inner { //内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类 public void test(){ System.out.println(\u0026#34;我是成员内部类！\u0026#34;); } } } 成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的，如果我们要使用成员内部类，那么就需要：\npublic static void main(String[] args) { Test test = new Test(); //我们首先需要创建对象 Test.Inner inner = test.new Inner(); //成员内部类的类型名称就是 外层.内部类名称 } 虽然看着很奇怪，但是确实是这样使用的。我们同样可以使用成员内部类中的方法：\npublic static void main(String[] args) { Test test = new Test(); Test.Inner inner = test.new Inner(); inner.test(); } 注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为private，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的：\n可以看到这里直接不认识了。\n这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的：\npublic class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { public void test(){ System.out.println(\u0026#34;我是成员内部类：\u0026#34;+name); //成员内部类可以访问到外部的成员变量 //因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的 } } } 每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。\n所以说我们在使用时：\npublic static void main(String[] args) { Test a = new Test(\u0026#34;小明\u0026#34;); Test.Inner inner1 = a.new Inner(); //依附于a创建的对象，那么就是a的 inner1.test(); Test b = new Test(\u0026#34;小红\u0026#34;); Test.Inner inner2 = b.new Inner(); //依附于b创建的对象，那么就是b的 inner2.test(); } 那现在问大家一个问题，外部能访问内部类里面的成员变量吗？\n那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个呢？\npublic class Test { private final String name; public Test(String name){ this.name = name; } public class Inner { String name; public void test(String name){ System.out.println(\u0026#34;方法参数的name = \u0026#34;+name); //依然是就近原则，最近的是参数，那就是参数了 System.out.println(\u0026#34;成员内部类的name = \u0026#34;+this.name); //在内部类中使用this关键字，只能表示内部类对象 System.out.println(\u0026#34;成员内部类的name = \u0026#34;+Test.this.name); //如果需要指定为外部的对象，那么需要在前面添加外部类型名称 } } } 包括对方法的调用和super关键字的使用，也是一样的：\npublic class Inner { String name; public void test(String name){ this.toString();\t//内部类自己的toString方法 super.toString(); //内部类父类的toString方法 Test.this.toString(); //外部类的toSrting方法 Test.super.toString(); //外部类父类的toString方法 } } 所以说成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用。\n静态内部类 前面我们介绍了成员内部类，它就像成员变量和成员方法一样，是属于对象的，同样的，静态内部类就像静态方法和静态变量一样，是属于类的，我们可以直接创建使用。\npublic class Test { private final String name; public Test(String name){ this.name = name; } public static class Inner { public void test(){ System.out.println(\u0026#34;我是静态内部类！\u0026#34;); } } } 不需要依附任何对象，我们可以直接创建静态内部类的对象：\npublic static void main(String[] args) { Test.Inner inner = new Test.Inner(); //静态内部类的类名同样是之前的格式，但是可以直接new了 inner.test(); } 静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的：\n只不过受影响的只是外部内容的使用，内部倒是不受影响，还是跟普通的类一样：\npublic static class Inner { String name; public void test(){ System.out.println(\u0026#34;我是静态内部类：\u0026#34;+name); } } 其实也很容易想通，因为静态内部类是属于外部类的，不依附任何对象，那么我要是直接访问外部类的非静态属性，那到底访问哪个对象的呢？这样肯定是说不通的。\n局部内部类 局部内部类就像局部变量一样，可以在方法中定义。\npublic class Test { private final String name; public Test(String name){ this.name = name; } public void hello(){ class Inner { //直接在方法中创建局部内部类 } } } 既然是在方法中声明的类，那作用范围也就只能在方法中了：\npublic class Test { public void hello(){ class Inner{ //局部内部类跟局部变量一样，先声明后使用 public void test(){ System.out.println(\u0026#34;我是局部内部类\u0026#34;); } } Inner inner = new Inner(); //局部内部类直接使用类名就行 inner.test(); } } 只不过这种局部内部类的形式，使用频率很低，基本上不会用到，所以说了解就行了。\n匿名内部类 匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。\n还记得我们在之前学习的抽象类和接口吗？在抽象类和接口中都会含有某些抽象方法需要子类去实现，我们当时已经很明确地说了不能直接通过new的方式去创建一个抽象类或是接口对象，但是我们可以使用匿名内部类。\npublic abstract class Student { public abstract void test(); } 正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。\n而我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象：\npublic static void main(String[] args) { Student student = new Student() { //在new的时候，后面加上花括号，把未实现的方法实现了 @Override public void test() { System.out.println(\u0026#34;我是匿名内部类的实现!\u0026#34;); } }; student.test(); } 此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。\n匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）所以说：\nStudent student = new Student() { int a; //因为本质上就相当于是子类，所以说子类定义一些子类的属性完全没问题 @Override public void test() { System.out.println(name + \u0026#34;我是匿名内部类的实现!\u0026#34;); //直接使用父类中的name变量 } }; 同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类：\npublic static void main(String[] args) { Study study = new Study() { @Override public void study() { System.out.println(\u0026#34;我是学习方法！\u0026#34;); } }; study.study(); } 当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。\nLambda表达式 前面我们介绍了匿名内部类，我们可以通过这种方式创建一个临时的实现子类。\n特别的，如果一个接口中有且只有一个待实现的抽象方法，那么我们可以将匿名内部类简写为Lambda表达式：\npublic static void main(String[] args) { Study study = () -\u0026gt; System.out.println(\u0026#34;我是学习方法！\u0026#34;); //是不是感觉非常简洁！ study.study(); } 在初学阶段，为了简化学习，各位小伙伴就认为Lambda表达式就是匿名内部类的简写就行了（Lambda表达式的底层其实并不只是简简单单的语法糖替换，感兴趣的可以在新特性篇视频教程中了解）\n那么它是一个怎么样的简写规则呢？我们来看一下Lambda表达式的具体规范：\n标准格式为：([参数类型 参数名称,]...) ‐\u0026gt; { 代码语句，包括返回值 } 和匿名内部类不同，Lambda仅支持接口，不支持抽象类 接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来） 比如我们之前写的Study接口，只要求实现一个无参无返回值的方法，所以说直接就是最简单的形式：\n() -\u0026gt; System.out.println(\u0026#34;我是学习方法！\u0026#34;); //跟之前流程控制一样，如果只有一行代码花括号可省略 当然，如果有一个参数和返回值的话：\npublic static void main(String[] args) { Study study = (a) -\u0026gt; { System.out.println(\u0026#34;我是学习方法\u0026#34;); return \u0026#34;今天学会了\u0026#34;+a; //实际上这里面就是方法体，该咋写咋写 }; System.out.println(study.study(10)); } 注意，如果方法体中只有一个返回语句，可以直接省去花括号和return关键字：\nStudy study = (a) -\u0026gt; { return \u0026#34;今天学会了\u0026#34;+a; //这种情况是可以简化的 }; Study study = (a) -\u0026gt; \u0026#34;今天学会了\u0026#34;+a; 如果参数只有一个，那么可以省去小括号：\nStudy study = a -\u0026gt; \u0026#34;今天学会了\u0026#34;+a; 是不是感觉特别简洁，实际上我们程序员追求的就是写出简洁高效的代码，而Java也在朝这个方向一直努力，近年来从Java 9开始出现的一些新语法基本都是各种各样的简写版本。\n如果一个方法的参数需要的是一个接口的实现：\npublic static void main(String[] args) { test(a -\u0026gt; \u0026#34;今天学会了\u0026#34;+a); //参数直接写成lambda表达式 } private static void test(Study study){ study.study(10); } 当然，这还只是一部分，对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。\n方法引用 方法引用就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行）\npublic interface Study { int sum(int a, int b); //待实现的求和方法 } 那么使用时候，可以直接使用Lambda表达式：\npublic static void main(String[] args) { Study study = (a, b) -\u0026gt; a + b; } 只不过还能更简单，因为Integer类中默认提供了求两个int值之和的方法：\n//Integer类中就已经有对应的实现了 public static int sum(int a, int b) { return a + b; } 此时，我们可以直接将已有方法的实现作为接口的实现：\npublic static void main(String[] args) { Study study = (a, b) -\u0026gt; Integer.sum(a, b); //直接使用Integer为我们通过好的求和方法 System.out.println(study.sum(10, 20)); } 我们发现，Integer.sum的参数和返回值，跟我们在Study中定义的完全一样，所以说我们可以直接使用方法引用：\npublic static void main(String[] args) { Study study = Integer::sum; //使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式 System.out.println(study.sum(10, 20)); } 方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现：\npublic interface Study { String study(); } 如果是普通从成员方法，我们同样需要使用对象来进行方法引用：\npublic static void main(String[] args) { Main main = new Main(); Study study = main::lbwnb; //成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式 } public String lbwnb(){ return \u0026#34;卡布奇诺今犹在，不见当年倒茶人。\u0026#34;; } 因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：\npublic static void main(String[] args) { Study study = String::new; //没错，构造方法也可以被引用，使用new表示 } 反正只要是符合接口中方法的定义的，都可以直接进行方法引用，对于Lambda表达式和方法引用，在Java新特性介绍篇视频教程中还有详细的讲解，这里就不多说了。\n异常机制 在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？\npublic static void main(String[] args) { test(1, 0); //当b为0的时候，还能正常运行吗？ } private static int test(int a, int b){ return a/b; //没有任何的判断而是直接做计算 } 此时我们可以看到，出现了运算异常：\n那么这个异常到底是什么样的一种存在呢？当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！\n异常的类型 我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自Exception类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！\n异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常，异常也是由类定义的，所有的运行时异常都继承自RuntimeException。\npublic static void main(String[] args) { Object object = null; object.toString(); //这种情况就会出现运行时异常 } 又比如下面的这种情况：\npublic static void main(String[] args) { Object object = new Object(); Main main = (Main) object; } 异常的另一种类型是编译时异常，编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！默认继承自Exception类的异常都是编译时异常。\nprotected native Object clone() throws CloneNotSupportedException; 比如Object类中定义的clone方法，就明确指出了在运行的时候会出现的异常。\n还有一种类型是错误，错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如OutOfMemoryError就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）\npublic static void main(String[] args) { test(); } private static void test(){ test(); } 比如这样的一个无限递归的方法，会导致运行过程中无限制地向下调用方法，导致栈溢出：\n这种情况就是错误了，已经严重到整个程序都无法正常运行了。又比如：\npublic static void main(String[] args) { Object[] objects = new Object[Integer.MAX_VALUE]; //这里申请一个超级大数组 } 实际上我们电脑的内存是有限的，不可能无限制地使用内存来存放变量，所以说如果内存不够用了，会直接：\n此时没有更多的可用内存供我们的程序使用，那么程序也就没办法继续运行下去了，这同样是一个很严重的错误。\n当然，我们这一块主要讨论的目录依然是异常。\n自定义异常 异常其实就两大类，一个是编译时异常，一个是运行时异常，我们先来看编译时异常。\npublic class TestException extends Exception{ public TestException(String message){ super(message); //这里我们选择使用父类的带参构造，这个参数就是异常的原因 } } 编译时异常只需要继承Exception就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。\n异常多种多样，不同的异常对应着不同的情况，比如在类型转换时出错那么就是类型转换异常，如果是使用一个值为null的变量调用方法，那么就会出现空指针异常。\n运行时异常只需要继承RuntimeException就行了：\npublic class TestException extends RuntimeException{ public TestException(String message){ super(message); } } RuntimeException继承自Exception，Exception继承自Throwable：\n运行时异常同同样也有很多，只不过运行时异常和编译型异常在使用时有一些不同，我们会在后面的学习中慢慢认识。\n当然还有一种类型是Error，它是所有错误的父类，同样是继承自Throwable的。\n抛出异常 当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：\npublic static int test(int a, int b) { if(b == 0) throw new RuntimeException(\u0026#34;被除数不能为0\u0026#34;); //使用throw关键字来抛出异常 return a / b; } 异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在RuntimeException的构造方法中我们可以写入原因。\n当出现异常时：\n程序会终止，并且会打印栈追踪信息，因为各位小伙伴才初学，还不知道什么是栈，我们这里就简单介绍一下，实际上方法之间的调用是有层级关系的，而当异常发生时，方法调用的每一层都会在栈追踪信息中打印出来，比如这里有两个at，实际上就是在告诉我们程序运行到哪个位置时出现的异常，位于最上面的就是发生异常的最核心位置，我们代码的第15行。\n并且这里会打印出当前抛出的异常类型和我们刚刚自定义异常信息。\n注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以：\nprivate static void test() throws Exception { //使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好 throw new Exception(\u0026#34;我是编译时异常！\u0026#34;); } 注意，如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：\nprivate static void test(int a) throws FileNotFoundException, ClassNotFoundException { //多个异常使用逗号隔开 if(a == 1) throw new FileNotFoundException(); else throw new ClassNotFoundException(); } 当然，并不是只有非运行时异常可以像这样明确指出，运行时异常也可以，只不过不强制要求：\nprivate static void test(int a) throws RuntimeException { throw new RuntimeException(); } 至于如何处理明确抛出的异常，我们会下一个部分中进行讲解。\n最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：\n@Override protected Object clone() { return new Object(); } 异常的处理 当程序没有按照我们理想的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：\npublic static void main(String[] args) { try { //使用try-catch语句进行异常捕获 Object object = null; object.toString(); } catch (NullPointerException e){ //因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常 } System.out.println(\u0026#34;程序继续正常运行！\u0026#34;); } 我们可以将代码编写到try语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用catch关键字对指定的异常进行捕获，这里我们捕获的是NullPointerException空指针异常：\n可以看到，当我们捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。\n注意，catch中捕获的类型只能是Throwable的子类，也就是说要么是抛出的异常，要么是错误，不能是其他的任何类型。\n我们可以在catch语句块中对捕获到的异常进行处理：\npublic static void main(String[] args) { try { Object object = null; object.toString(); } catch (NullPointerException e){ e.printStackTrace(); //打印栈追踪信息 System.out.println(\u0026#34;异常错误信息：\u0026#34;+e.getMessage()); //获取异常的错误信息 } System.out.println(\u0026#34;程序继续正常运行！\u0026#34;); } 如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用try-catch语句块进行异常的捕获，不然就无法通过编译：\npublic static void main(String[] args) { test(10); //必须要进行异常的捕获，否则报错 } private static void test(int a) throws IOException { //明确会抛出IOException throw new IOException(); } 当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级：\npublic static void main(String[] args) throws IOException { //继续编写throws往上一级抛 test(10); } private static void test(int a) throws IOException { throw new IOException(); } 注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。\n注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到：\npublic static void main(String[] args) throws IOException { try { int[] arr = new int[1]; arr[1] = 100; //这里发生的是数组越界异常，它是运行时异常的子类 } catch (RuntimeException e){ //使用运行时异常同样可以捕获到 System.out.println(\u0026#34;捕获到异常\u0026#34;); } } 当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：\ntry { //.... } catch (NullPointerException e) { } catch (IndexOutOfBoundsException e){ } catch (RuntimeException e){ } 但是要注意一下顺序：\ntry { //.... } catch (RuntimeException e){ //父类型在前，会将子类的也捕获 } catch (NullPointerException e) { //永远都不会被捕获 } catch (IndexOutOfBoundsException e){ //永远都不会被捕获 } 只不过这样写好像有点丑，我们也可以简写为：\ntry { //.... } catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } 如果简写的话，那么发生这些异常的时候，都会采用统一的方式进行处理了。\n最后，当我们希望，程序运行时，无论是否出现异常，都会在最后执行任务，可以交给finally语句块来处理：\ntry { //.... }catch (Exception e){ }finally { System.out.println(\u0026#34;lbwnb\u0026#34;); //无论是否出现异常，都会在最后执行 } try语句块至少要配合catch或finally中的一个：\ntry { int a = 10; a /= 0; } finally { //不捕获异常，程序会终止，但在最后依然会执行下面的内容 System.out.println(\u0026#34;lbwnb\u0026#34;); } 思考：try、catch和finally执行顺序？\n断言表达式 我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下：\n开启断言之后，我们就可以开始使用了。\n断言表达式需要使用到assert关键字，如果assert后面的表达式判断结果为false，将抛出AssertionError错误。\npublic static void main(String[] args) { assert false; } 比如我们可以判断变量的值，如果大于10就抛出错误：\npublic static void main(String[] args) { int a = 10; assert a \u0026gt; 10; } 我们可以在表达式的后面添加错误信息：\npublic static void main(String[] args) { int a = 10; assert a \u0026gt; 10 : \u0026#34;我是自定义的错误信息\u0026#34;; } 这样就会显示到错误后面了：\n断言表达式一般只用于测试，我们正常的程序中一般不会使用，这里只做了解就行了。\n常用工具类介绍 前面我们学习了包装类、数组和字符串，我们接着来看看常用的一些工具类。工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。\n数学工具类 Java提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。\npublic static void main(String[] args) { //Math也是java.lang包下的类，所以说默认就可以直接使用 System.out.println(Math.pow(5, 3)); //我们可以使用pow方法直接计算a的b次方 Math.abs(-1); //abs方法可以求绝对值 Math.max(19, 20); //快速取最大值 Math.min(2, 4); //快速取最小值 Math.sqrt(9); //求一个数的算术平方根 } 当然，三角函数肯定也是安排上了的：\nMath.sin(Math.PI / 2); //求π/2的正弦值，这里我们可以使用预置的PI进行计算 Math.cos(Math.PI); //求π的余弦值 Math.tan(Math.PI / 4); //求π/4的正切值 Math.asin(1); //三角函数的反函数也是有的，这里是求arcsin1的值 Math.acos(1); Math.atan(0); 可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果：\npublic static void main(String[] args) { System.out.println(Math.sin(Math.PI)); //计算 sinπ 的结果 } 正常来说，sinπ的结果应该是0才对，为什么这里得到的是一个很奇怪的数？这个E是干嘛的，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是：\n$1.2246467991473532 \\times 10^{-16}$ 其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。\n我们也可以快速计算对数函数：\npublic static void main(String[] args) { Math.log(Math.E); //e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e Math.log10(100); //10为底的对数函数 //利用换底公式，我们可以弄出来任何我们想求的对数函数 double a = Math.log(4) / Math.log(2); //这里是求以2为底4的对数，log(2)4 = ln4 / ln2 System.out.println(a); } 还有一些比较特殊的计算：\npublic static void main(String[] args) { Math.ceil(4.5); //通过使用ceil来向上取整 Math.floor(5.6); //通过使用floor来向下取整 } 向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。\n这里我们再介绍一下随机数的生成，Java中想要生成一个随机数其实也很简单，我们需要使用Random类来生成（这个类时java.util包下的，需要手动导入才可以）\npublic static void main(String[] args) { Random random = new Random(); //创建Random对象 for (int i = 0; i \u0026lt; 30; i++) { System.out.print(random.nextInt(100)+\u0026#34; \u0026#34;); //nextInt方法可以指定创建0 - x之内的随机数 } } 结果为，可以看到确实是一堆随机数：\n只不过，程序中的随机并不是真随机，而是根据某些东西计算出来的，只不过计算过程非常复杂，能够在一定程度上保证随机性（根据爱因斯坦理论，宏观物质世界不存在真随机，看似随机的事物只是现目前无法计算而已，唯物主义的公理之一就是任何事物都有因果关系）\n数组工具类 前面我们介绍了数组，但是我们发现，想要操作数组实在是有点麻烦，比如我们要打印一个数组，还得一个一个元素遍历才可以，那么有没有一个比较方便的方式去使用数组呢？我们可以使用数组工具类Arrays。\n这个类也是java.util包下类，它用于便捷操作数组，比如我们想要打印数组，可以直接通过toString方法转换字符串：\npublic static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 8, 2, 0, 9, 7, 3, 6}; System.out.println(Arrays.toString(arr)); } 是不是感觉非常方便？这样我们直接就可以打印数组了！\n除了这个方法，它还支持将数组进行排序：\npublic static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 8, 2, 0, 9, 7, 3, 6}; Arrays.sort(arr); //可以对数组进行排序，将所有的元素按照从小到大的顺序排放 System.out.println(Arrays.toString(arr)); } 感兴趣的小伙伴可以在数据结构与算法篇视频教程中了解多种多样的排序算法，这里的排序底层实现实际上用到了多种排序算法。\n数组中的内容也可以快速进行填充：\npublic static void main(String[] args) { int[] arr = new int[10]; Arrays.fill(arr, 66); System.out.println(Arrays.toString(arr)); } 我们可以快速地对一个数组进行拷贝：\npublic static void main(String[] args) { int[] arr = new int[]{1, 2, 3, 4, 5}; int[] target = Arrays.copyOf(arr, 5); System.out.println(Arrays.toString(target)); //拷贝数组的全部内容，并生成一个新的数组对象 System.out.println(arr == target); } public static void main(String[] args) { int[] arr = new int[]{1, 2, 3, 4, 5}; int[] target = Arrays.copyOfRange(arr, 3, 5); //也可以只拷贝某个范围内的内容 System.out.println(Arrays.toString(target)); System.out.println(arr == target); } 我们也可以将一个数组中的内容拷贝到其他数组中：\npublic static void main(String[] args) { int[] arr = new int[]{1, 2, 3, 4, 5}; int[] target = new int[10]; System.arraycopy(arr, 0, target, 0, 5); //使用System.arraycopy进行搬运 System.out.println(Arrays.toString(target)); } 对于一个有序的数组（从小到大排列）我们可以使用二分搜索快速找到对应的元素在哪个位置：\npublic static void main(String[] args) { int[] arr = new int[]{1, 2, 3, 4, 5}; System.out.println(Arrays.binarySearch(arr, 5)); //二分搜索仅适用于有序数组 } 这里提到了二分搜索算法，我们会在后面的实战练习中进行讲解。\n那要是现在我们使用的是多维数组呢？因为现在数组里面的每个元素就是一个数组，所以说toString会出现些问题：\npublic static void main(String[] args) { int[][] array = new int[][]{{2, 8, 4, 1}, {9, 2, 0, 3}}; System.out.println(Arrays.toString(array)); } 只不过别担心，Arrays也支持对多维数组进行处理：\npublic static void main(String[] args) { int[][] array = new int[][]{{2, 8, 4, 1}, {9, 2, 0, 3}}; System.out.println(Arrays.deepToString(array)); //deepToString方法可以对多维数组进行打印 } 同样的，因为数组本身没有重写equals方法，所以说无法判断两个不同的数组对象中的每一个元素是否相同，Arrays也为一维数组和多维数组提供了相等判断的方法：\npublic static void main(String[] args) { int[][] a = new int[][]{{2, 8, 4, 1}, {9, 2, 0, 3}}; int[][] b = new int[][]{{2, 8, 4, 1}, {9, 2, 0, 3}}; System.out.println(Arrays.equals(a, b)); //equals仅适用于一维数组 System.out.println(Arrays.deepEquals(a, b)); //对于多维数组，需要使用deepEquals来进行深层次判断 } 这里肯定有小伙伴疑问了，不是说基本类型的数组不能转换为引用类型的数组吗？为什么这里的deepEquals接受的是Object[]也可以传入参数呢？这是因为现在是二维数组，二维数组每个元素都是一个数组，而数组本身的话就是一个引用类型了，所以说可以转换为Object类型，但是如果是一维数组的话，就报错：\n总体来说，这个工具类对于我们数组的使用还是很方便的。\n实战练习 到目前为止，关于面向对象相关的内容我们已经学习了非常多了，接着依然是练习题。\n冒泡排序算法 有一个int数组，但是数组内的数据是打乱的，现在我们需要将数组中的数据按从小到大的顺序进行排列：\npublic static void main(String[] args) { int[] arr = new int[]{3, 5, 7, 2, 9, 0, 6, 1, 8, 4}; } 请你设计一个Java程序将这个数组中的元素按照顺序排列。\n二分搜索算法 现在有一个从小到大排序的数组，给你一个目标值target，现在我们想要找到这个值在数组中的对应下标，如果数组中没有这个数，请返回-1：\npublic static void main(String[] args) { int[] arr = {1, 3, 4, 6, 7, 8, 10, 11, 13, 15}; int target = 3; } 请你设计一个Java程序实现这个功能。\n青蛙跳台阶问题 现在一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？\n例如n=2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。\n现在请你设计一个Java程序，计算当台阶数为n的情况下，能够有多少种方案到达顶端。\n回文串判断 “回文串”是一个正读和反读都一样的字符串，请你实现一个Java程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。\nABCBA 就是一个回文串，因为正读反读都是一样的\nABCA 就不是一个回文串，因为反着读不一样\n汉诺塔求解 什么是汉诺塔？\n汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始\n按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。\n这三根柱子我们就依次命名为A、B、C，现在请你设计一个Java程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。\n","permalink":"https://blog.l50.top/posts/javase%E7%AC%94%E8%AE%B0%E5%9B%9B%E9%87%8D%E5%88%B6%E7%89%88/","summary":"面向对象高级篇 经过前面的学习，我们已经了解了面向对象编程的大部分基础内容，这一部分，我们将继续探索面向对象编程过程中一些常用的东西。\n基本类型包装类 Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！\n包装类介绍 所有的包装类层次结构如下：\n其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：\nbyte -\u0026gt; Byte boolean -\u0026gt; Boolean short -\u0026gt; Short char -\u0026gt; Character int -\u0026gt; Integer long -\u0026gt; Long float -\u0026gt; Float double -\u0026gt; Double 我们可以直接使用，这里我们以Integer类为例：\npublic static void main(String[] args) { Integer i = new Integer(10); //将10包装为一个Integer类型的变量 } 包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想）我们可以来看看Integer类中是怎么写的：\nprivate final int value; //类中实际上就靠这个变量在存储包装的值 public Integer(int value) { this.value = value; } 包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：\npublic static void main(String[] args) { Integer i = 10; //将int类型值作为包装类型使用 } 这是怎么做到的？为什么一个对象类型的值可以直接接收一个基本类类型的值？实际上这里就是自动装箱：","title":"JavaSE笔记（四）重制版"},{"content":" 面向对象基础篇 我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。\n面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。\n这一章开始难度就上来了，所以说请各位小伙伴一定认真。\n类与对象 类的概念我们在生活中其实已经听说过很多了。\n人类、鸟类、鱼类\u0026hellip; 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。\n对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。\n所以说，类就是抽象概念的人，而对象，就是具体的某一个人。\nA：是谁拿走了我的手机？ B：是个人。（某一个类） A：我还知道是个人呢，具体是谁呢？ B：是XXX。（具体某个对象） 而我们在Java中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象。像这种编程方式，我们称为面向对象编程。\n类的定义与对象创建 前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。\n比如现在我们想要定义一个人类，我们可以右键src目录，点击创建新的类：\n我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。\n可以看到，现在我们的目录下有了两个.java源文件，其中一个是默认创建的Main.java，还有一个是我们刚刚创建的类。\n我们来看看创建好之后，一个类写了哪些内容：\npublic class Person { } 可以发现，这不是跟一开始创建的Main中写的格式一模一样吗？没错，Main也是一个类，只不过我们一直都将其当做主类在使用，也就是编写主方法的类，关于方法我们会在后面进行介绍。\n现在我们就创建好了一个类，既然是人类，那么肯定有人相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？\n我们可以将这些属性直接作为类的成员变量（成员变量相当于是这个类所具有的属性，每个实例创建出来之后，这些属性都可能会各不相同）定义到类中。\npublic class Person { //这里定义的人类具有三个属性，名字、年龄、性别 String name; //直接在类中定义变量，表示类具有的属性 int age; String sex; } 可能会有小伙伴疑问，这些变量啥时候被赋值呢？实际上这些变量只有在一个具体的对象中才可以使用。\n那么现在人类的属性都规定好了，我们就可以尝试创建一个实例对象了，实例对应的应该是一个具体的人：\nnew 类名(); public static void main(String[] args) { new Person(); //我们可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名() //这里创建出来的，就是一个具体的人了 } 实际上整个流程为：\n只不过这里仅仅是创建出了这样的一个对象，我们目前没有办法去操作这个对象，比如想要修改或是获取这个人的名字等等。\n对象的使用 既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。\n我们同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身：\npublic static void main(String[] args) { //这里的a存放的是具体的某个值 int a = 10; //创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名 //这里的p存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象 Person p = new Person(); } 至于为什么对象类型的变量存放的是对象的引用，比如：\npublic static void main(String[] args) { Person p1 = new Person(); Person p2 = p1; } 这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在）\n我们可以来测试一下：\npublic static void main(String[] args) { Person p1 = new Person(); Person p2 = p1; System.out.println(p1 == p2); //使用 == 可以判断两个变量引用的是不是同一个对象 } 但是如果我们像这样去编写：\npublic static void main(String[] args) { Person p1 = new Person(); //这两个变量分别引用的是不同的两个对象 Person p2 = new Person(); System.out.println(p1 == p2); //如果两个变量存放的是不同对象的引用，那么肯定就是不一样的了 } 实际上我们之前使用的String类型，也是一个引用类型，我们会在下一章详细讨论。我们在上一章介绍的都是基本类型，而类使用的都是引用类型。\n现在我们有了对象的引用之后，我们就可以进行操作了：\n我们可以直接访问对象的一些属性，也就是我们在类中定义好的那些，对于不同的对象，这些属性都具体存放值也会不同。\n比如我们可以修改对象的名字：\npublic static void main(String[] args) { Person p = new Person(); p.name = \u0026#34;小明\u0026#34;; //要访问对象的属性，我们需要使用 . 运算符 System.out.println(p.name); //直接打印对象的名字，就是我们刚刚修改好的结果了 } 注意，不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象：\npublic static void main(String[] args) { Person p1 = new Person(); Person p2 = new Person(); p1.name = \u0026#34;小明\u0026#34;; //这个修改的是第一个对象的属性 p2.name = \u0026#34;大明\u0026#34;; //这里修改的是第二个对象的属性 System.out.println(p1.name); //这里我们获取的是第一个对象的属性 } 关于对象类型的变量，我们也可以不对任何对象进行引用：\npublic static void main(String[] args) { Person p1 = null; //null是一个特殊的值，它表示空，也就是不引用任何的对象 } 注意，如果不引用任何的对象，那肯定是不应该去通过这个变量去操作所引用的对象的（都没有引用对象，我操作谁啊我）\n虽然这样可以编译通过，但是在运行时会出现问题：\npublic static void main(String[] args) { Person p = null; //此时变量没有引用任何对象 p.name = \u0026#34;小红\u0026#34;; //我任性，就是要操作 System.out.println(p.name); } 我们来尝试运行一下这段代码：\n此时程序在运行的过程中，出现了异常，虽然我们还没有学习到异常，但是各位可以将异常理解为程序在运行过程中出现了问题，此时不得不终止程序退出。\n这里出现的是空指针异常，很明显是因为我们去操作一个值为null的变量导致的。在我们以后的学习中，这个异常是出现频率最高的。\n我们来看最后一个问题，对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？\npublic static void main(String[] args) { Person p = new Person(); System.out.println(\u0026#34;name = \u0026#34;+p.name); System.out.println(\u0026#34;age = \u0026#34;+p.age); System.out.println(\u0026#34;sex = \u0026#34;+p.sex); } 我们来看看运行结果：\n我们可以看到，如果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为0（如果是boolean的话，默认值为false）如果是引用类型，那么默认是null。\n方法创建与使用 前面我们介绍了类的定义以及对象的创建和使用。\n现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。\n而对象也可以做出一些行为，我们可以通过定义方法来实现（在C语言中叫做函数）\n方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。\n方法的定义如下：\n返回值类型 方法名称() { 方法体... } 首先是返回值类型，也就是说这个方法完成任务之后，得到的结果的数据类型（可以是基本类型，也可以是引用类型）当然，如果没有返回值，只是完成任务，那么可以使用void表示没有返回值，比如我们现在给人类编写一个自我介绍的行为：\npublic class Person { String name; int age; String sex; //自我介绍只需要完成就行，没有返回值，所以说使用void void hello(){ //完成自我介绍需要执行的所有代码就在这个花括号中编写 //这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数） //自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值 System.out.println(\u0026#34;我叫 \u0026#34;+name+\u0026#34; 今年 \u0026#34;+age+\u0026#34; 岁了！\u0026#34;); } } 注意，方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。\n现在我们给人类定义好了一个方法（行为）那么怎么才能让对象执行这个行为呢？\npublic static void main(String[] args) { Person p = new Person(); p.name = \u0026#34;小明\u0026#34;; p.age = 18; p.hello(); //我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可 } 像这样执行定义好的方法，我们一般称为方法的调用，我们来看看效果：\n比如现在我们要让人类学会加法运算，我们也可以通过定义一个方法的形式来完成，只不过，要完成加法运算，我们需要别人给人类提供两个参与加法运算的值才可以，所以我们这里就要用到参数了：\n//我们的方法需要别人提供参与运算的值才可以 //我们可以为方法设定参数，在调用方法时，需要外部传入参数才可以 //参数的定义需要在小括号内部编写，类似于变量定义，需要填写 类型和参数名称，多个参数用逗号隔开 int sum(int a, int b){ //这里需要两个int类型的参数进行计算 } 那么现在参数从外部传入之后，我们怎么使用呢？\nint sum(int a, int b){ //这里的参数，相当于我们在函数中定义了两个局部变量，我们可以直接在方法中使用 int c = a + b; //直接c = a + b } 那么现在计算完成了，我们该怎么将结果传递到外面呢？首先函数的返回值是int类型，我们只需要使用return关键字来返回一个int类型的结果就可以了：\nint sum(int a, int b){ int c = a + b; return c; //return后面紧跟需要返回的结果，这样就可以将计算结果丢出去了 //带返回值的方法，是一定要有一个返回结果的！否则无法通过编译！ } 我们来测试一下吧：\npublic static void main(String[] args) { Person p = new Person(); p.name = \u0026#34;小明\u0026#34;; p.age = 18; int result = p.sum(10, 20); //现在我们要让这个对象帮我们计算10 + 20的结果 System.out.println(result); //成功得到30，实际上这里的println也是在调用方法进行打印操作 } **注意：**方法定义时编写的参数，我们一般称为形式参数，而调用方法实际传入的参数，我们成为实际参数。\n是不是越来越感觉我们真的在跟一个对象进行交互？只要各位有了这样的体验，基本上就已经摸到面向对象的门路了。\n关于return关键字，我们还需要进行进一步的介绍。\n在我们使用return关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的：\n在return后编写代码，会导致编译不通过，因为存在不可达语句。\n如果我们的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以：\n只要有任何一个分支缺少了return语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。\n当然，如果方法没有返回值，我们也可以使用return语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行：\nvoid test(int a){ if(a == 10) return; //当a等于10时直接结束方法，后面无论有没有代码都不会执行了 System.out.println(\u0026#34;Hello World!\u0026#34;); //不是的情况就正常执行 } 最后我们来讨论一下参数的传递问题：\nvoid test(int a){ //我们可以设置参数来让外部的数据传入到函数内部 System.out.println(a); } 实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身，我们来下面的这个例子：\nvoid swap(int a, int b){ //这个函数的目的很明显，就是为了交换a和b的值 int tmp = a; a = b; b = a; } 那么我们来测试一下：\npublic static void main(String[] args) { Person p = new Person(); int a = 5, b = 9; //外面也叫a和b p.swap(a, b); System.out.println(\u0026#34;a = \u0026#34;+a+\u0026#34;, b = \u0026#34;+b); //最后的结果会变成什么样子呢？ } 我们来看看结果是什么：\n我们发现a和b的值并没有发生交换，但是按照我们的方法逻辑来说，应该是会交换才对，这是为什么呢？实际上这里仅仅是将值复制给了函数里面的变量而已（相当于是变量的赋值）\n所以说我们交换的仅仅是方法中的a和b，参数传递仅仅是值传递，我们是没有办法直接操作到外面的a和b的。\n那么各位小伙伴看看下面的例子：\nvoid modify(Person person){ person.name = \u0026#34;lbwnb\u0026#34;; //修改对象的名称 } public static void main(String[] args) { Person p = new Person(); p.name = \u0026#34;小明\u0026#34;; //先在外面修改一次 p.modify(p); //调用方法再修改一次 System.out.println(p.name); //请问最后name会是什么？ } 我们来看看结果：\n不对啊，前面不是说只是值传递吗，怎么这里又可以修改成功呢？\n确实，这里同样是进行的值传递，只不过各位小伙伴别忘了，我们前面可是说的清清楚楚，引用类型的变量，仅仅存放的是对象的引用，而不是对象本身。那么这里进行了值传递，相当于将对象的引用复制到了方法内部的变量中，而这个内部的变量，依然是引用的同一个对象，所以说这里在方法内操作，相当于直接操作外面的定义对象。\n方法进阶使用 有时候我们的方法中可能会出现一些与成员变量重名的变量：\n//我们希望使用这个方法，来为当前对象设定名字 void setName(String name) { } 此时类中定义的变量名称也是name，那么我们是否可以这样编写呢：\nvoid setName(String name) { name = name; //出现重名时，优先使用作用域最接近的，这里实际上是将方法参数的局部变量name赋值为本身 } 我们来测试一下：\npublic static void main(String[] args) { Person p = new Person(); p.setName(\u0026#34;小明\u0026#34;); System.out.println(p.name); } 我们发现，似乎这样做并没有任何的效果，name依然是没有修改的状态。那么当出现重名的时候，因为默认情况下会优先使用作用域最近的变量，我们怎么才能表示要使用的变量是类的成员变量呢？\nPerson p = new Person(); p.name = \u0026#34;小明\u0026#34;; //我们之前在外面使用时，可以直接通过对象.属性的形式访问到 同样的，我们如果想要在方法中访问到当前对象的属性，那么可以使用this关键字，来明确表示当前类的示例对象本身：\nvoid setName(String name) { this.name = name; //让当前对象的name变量值等于参数传入的值 } 这样就可以修改成功了，当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用this关键字来明确表示当前对象：\nString getName() { return name; //这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了 } 我们接着来看方法的重载。\n有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：\nint sum(int a, int b){ return a + b; } public static void main(String[] args) { Person p = new Person(); System.out.println(p.sum(10, 20)); //这里可以正常计算两个整数的和 } 但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？\n当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载。\n一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！\nint sum(int a, int b){ return a + b; } double sum(double a, double b){ //为了支持小数加法，我们可以进行一次重载 return a + b; } 这样就可以正常使用了：\npublic static void main(String[] args) { Person p = new Person(); //当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用 System.out.println(p.sum(1.5, 2.2)); } 包括我们之前一直在使用的println方法，其实也是重载了很多次的，因为要支持各种值的打印。\n注意，如果仅仅是返回值的不同，是不支持重载的：\n当然，方法之间是可以相互调用的：\nvoid test(){ System.out.println(\u0026#34;我是test\u0026#34;); //实际上这里也是调用另一个方法 } void say(){ test(); //在一个方法内调用另一个方法 } 如果我们这样写的话：\nvoid test(){ say(); } void say(){ test(); } 各位猜猜看会出现什么情况？\n此时又出现了一个我们不认识的异常，实际上什么原因导致的我们自己都很清楚，方法之间一直在相互调用，没有一个出口。\n方法自己也可以调用自己：\nvoid test(){ test(); } 像这样自己调用自己的行为，我们称为递归调用，如果直接这样编写，会跟上面一样，出现栈溢出错误。但是如果我们给其合理地设置出口，就不会出现这种问题，比如我们想要计算从1加到n的和：\nint test(int n){ if(n == 0) return 0; return test(n - 1) + n; //返回的结果是下一层返回的结果+当前这一层的n } 是不是感觉很巧妙？实际上递归调用在很多情况下能够快速解决一些很麻烦的问题，我们会在后面继续了解。\n构造方法 我们接着来看一种比较特殊的方法，构造方法。\n我们前面创建对象，都是直接使用new关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，我们可以使用构造方法（构造器）来完成。\n实际上每个类都有一个默认的构造方法，我们可以来看看反编译的结果：\npublic class Person { String name; int age; String sex; public Person() { //反编译中，多出来了这样一个方法，这其实就是构造方法 } } 构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：\npublic class Person { String name; int age; String sex; Person(){ //构造方法不需要指定返回值，并且方法名称与类名相同 name = \u0026#34;小明\u0026#34;; //构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理 age = 18; sex = \u0026#34;男\u0026#34;; } } 构造方法会在new的时候自动执行：\npublic static void main(String[] args) { Person p = new Person(); //这里的new Person()其实就是在调用无参构造方法 System.out.println(p.name); } 当然，我们也可以为构造方法设定参数：\npublic class Person { String name; int age; String sex; Person(String name, int age, String sex){ //跟普通方法是一样的 this.name = name; this.age = age; this.sex = sex; } } 注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法：\npublic static void main(String[] args) { Person p = new Person(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); //调用自己定义的带三个参数的构造方法 System.out.println(p.name); } 我们可以去看看反编译的结果，会发现此时没有无参构造了，而是只剩下我们自己编写的。\n当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：\npublic class Person { String name = \u0026#34;未知\u0026#34;; //直接赋值，那么对象构造好之后，属性默认就是这个值 int age = 10; String sex = \u0026#34;男\u0026#34;; } 这里需要特别注意，成员变量的初始化，并不是在构造方法之前之后，而是在这之前就已经完成了：\nPerson(String name, int age, String sex){ System.out.println(age); //在赋值之前看看是否有初始值 this.name = name; this.age = age; this.sex = sex; } 我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：\npublic class Person { String name; int age; String sex; { System.out.println(\u0026#34;我是代码块\u0026#34;); //代码块中的内容会在对象创建时仅执行一次 } Person(String name, int age, String sex){ System.out.println(\u0026#34;我被构造了\u0026#34;); this.name = name; this.age = age; this.sex = sex; } } 只不过一般情况下使用代码块的频率比较低，标准情况下还是通过构造方法进行进行对象初始化工作，所以说这里做了解就行了。\n静态变量和静态方法 前面我们已经了解了类的大部分特性，一个类可以具有多种属性、行为，包括对象该如何创建，我们可以通过构造方法进行设定，我们可以通过类创建对象，每个对象都会具有我们在类中设定好的属性，包括我们设定好的行为，所以说类就像是一个模板，我们可以通过这个模板快速捏造出一个又一个的对象。我们接着来看比较特殊的静态特性。\n静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。我们通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。\npublic class Person { String name; int age; String sex; static String info; //这里我们定义一个info静态变量 } 我们来测试一下：\npublic static void main(String[] args) { Person p1 = new Person(); Person p2 = new Person(); p1.info = \u0026#34;杰哥你干嘛\u0026#34;; System.out.println(p2.info); //可以看到，由于静态属性是属于类的，因此无论通过什么方式改变，都改变的是同一个目标 } 所以说一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：\npublic static void main(String[] args) { Person.info = \u0026#34;让我看看\u0026#34;; System.out.println(Person.info); } 同样的，我们可以将方法标记为静态：\nstatic void test(){ System.out.println(\u0026#34;我是静态方法\u0026#34;); } 静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样：\n因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值：\n成员变量是某个具体对象拥有的属性，就像小明这个具体的人的名字才叫小明，而静态方法是类具有的，并不是具体对象的，肯定是没办法访问到的。同样的，在静态方法中，无法使用this关键字，因为this关键字代表的是当前的对象本身。\n但是静态方法是可以访问到静态变量的：\nstatic String info; static void test(){ System.out.println(\u0026#34;静态变量的值为：\u0026#34;+info); } 因为他们都属于类，所以说肯定是可以访问到的。\n我们也可以将代码块变成静态的：\nstatic String info; static { //静态代码块可以用于初始化静态变量 info = \u0026#34;测试\u0026#34;; } 那么，静态变量，是在什么时候进行初始化的呢？\n我们在一开始介绍了，我们实际上是将.class文件丢给JVM去执行的，而每一个.class文件其实就是我们编写的一个类，我们在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：\n访问类的静态变量，或者为静态变量赋值 new 创建类的实例（隐式加载） 调用类的静态方法 子类初始化时 其他的情况会在讲到反射时介绍 所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。\n我们可以来测试一下：\npublic class Person { String name = test(); //这里我们用test方法的返回值作为变量的初始值，便于观察 int age; String sex; { System.out.println(\u0026#34;我是普通代码块\u0026#34;); } Person(){ System.out.println(\u0026#34;我是构造方法\u0026#34;); } String test(){ System.out.println(\u0026#34;我是成员变量初始化\u0026#34;); return \u0026#34;小明\u0026#34;; } static String info = init(); //这里我们用init静态方法的返回值作为变量的初始值，便于观察 static { System.out.println(\u0026#34;我是静态代码块\u0026#34;); } static String init(){ System.out.println(\u0026#34;我是静态变量初始化\u0026#34;); return \u0026#34;test\u0026#34;; } } 现在我们在主方法中创建一个对象，观察这几步是怎么在执行的：\n可以看到，确实是静态内容在对象构造之前的就完成了初始化，实际上就是类初始化时完成的。\n当然，如果我们直接访问类的静态变量：\npublic static void main(String[] args) { System.out.println(Person.info); } 那么此时同样会使得类初始化，进行加载：\n可以看到，在使用时，确实是先将静态内容初始化之后，才得到值的。当然，如果我们压根就没有去使用这个类，那么也不会被初始化了。\n有关类与对象的基本内容，我们就全部讲解完毕了。\n包和访问控制 通过前面的学习，我们知道该如何创建和使用类。\n包声明和导入 包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。\n包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的www.baidu.com，后面的baidu.com就是域名，我们的包就可以命名为com.baidu，当然，各位小伙伴现在还没有自己的域名，所以说我们随便起一个名称就可以了。其中的.就是用于分割的，对应多个文件夹，比如com.test：\n我们可以将类放入到包中：\n我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了：\npackage com.test; //在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包 public class Main { //将Main类放到com.test这个包中 public static void main(String[] args) { } } 这里又是一个新的关键字package，这个是用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。\n不同的类可以放在不同的包下：\n当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中）而当我们需要使用其他包中的类时，需要先进行导入才可以：\npackage com.test; import com.test.entity.Person; //使用import关键字导入其他包中的类 public class Main { public static void main(String[] args) { Person person = new Person(); //只有导入之后才可以使用，否则编译器不知道这个类从哪来的 } } 这里使用了import关键字导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用*表示导入这个包中全部的类：\nimport com.test.entity.*; 实际上我们之前一直在使用的System类，也是在一个包中的：\npackage java.lang; import java.io.*; import java.lang.reflect.Executable; import java.lang.annotation.Annotation; import java.security.AccessControlContext; import java.util.Properties; import java.util.PropertyPermission; import java.util.StringTokenizer; import java.util.Map; import java.security.AccessController; import java.security.PrivilegedAction; import java.security.AllPermission; import java.nio.channels.Channel; import java.nio.channels.spi.SelectorProvider; import sun.nio.ch.Interruptible; import sun.reflect.CallerSensitive; import sun.reflect.Reflection; import sun.security.util.SecurityConstants; import sun.reflect.annotation.AnnotationType; import jdk.internal.util.StaticProperty; /** * The \u0026lt;code\u0026gt;System\u0026lt;/code\u0026gt; class contains several useful class fields * and methods. It cannot be instantiated. * * \u0026lt;p\u0026gt;Among the facilities provided by the \u0026lt;code\u0026gt;System\u0026lt;/code\u0026gt; class * are standard input, standard output, and error output streams; * access to externally defined properties and environment * variables; a means of loading files and libraries; and a utility * method for quickly copying a portion of an array. * * @author unascribed * @since JDK1.0 */ public final class System { ... } 可以看到它是属于java.lang这个包下的类，并且这个类也导入了很多其他包中的类在进行使用。那么，为什么我们在使用这个类时，没有导入呢？实际上Java中会默认导入java.lang这个包下的所有类，因此我们不需要手动指定。\nIDEA非常智能，我们在使用项目中定义的类时，会自动帮我们将导入补全，所以说代码写起来非常高效。\n注意，在不同包下的类，即使类名相同，也是不同的两个类：\npackage com.test.entity; public class String { //我们在自己的包中也建一个名为String的类 } 当我们在使用时：\n![image-20220921121404900](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220921121404900.png)\n由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：\npublic class Main { public static void main(java.lang.String[] args) { //主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了 com.test.entity.String string = new com.test.entity.String(); } } 我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。\n可能各位小伙伴会发现一个问题，为什么对象的属性访问不了了？\n编译器说name属性在这个类中不是public，无法在外部进行访问，这是什么情况呢？这里我们就要介绍的到Java的访问权限控制了。\n访问权限控制 实际上Java中是有访问权限控制的，就是我们个人的隐私的一样，我不允许别人随便来查看我们的隐私，只有我们自己同意的情况下，才能告诉别人我们的名字、年龄等隐私信息。\n所以说Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：\nprivate - 私有，标记为私有的内容无法被除当前类以外的任何位置访问。 什么都不写 - 默认，默认情况下，只能被类本身和同包中的其他类访问。 protected - 受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍） public - 公共，标记为公共的内容，允许在任何地方被访问。 这四种访问权限，总结如下表：\n当前类 同一个包下的类 不同包下的子类 不同包下的类 public ✅ ✅ ✅ ✅ protected ✅ ✅ ✅ ❌ 默认 ✅ ✅ ❌ ❌ private ✅ ❌ ❌ ❌ 比如我们刚刚出现的情况，就是因为是默认的访问权限，所以说在当前包以外的其他包中无法访问，但是我们可以提升它的访问权限，来使得外部也可以访问：\npublic class Person { public String name; //在name变量前添加public关键字，将其可见性提升为公共等级 int age; String sex; } 这样我们就可以在外部正常使用这个属性了：\npublic static void main(String[] args) { Person person = new Person(); System.out.println(person.name); //正常访问到成员变量 } 实际上如果各位小伙伴观察仔细的话，会发现我们创建出来的类自带的访问等级就是public：\npackage com.test.entity; public class Person { //class前面有public关键字 } 也就是说这个类实际上可以在任何地方使用，但是我们也可以将其修改为默认的访问等级：\npackage com.test.entity; class Person { //去掉public变成默认等级 } 如果是默认等级的话，那么在外部同样是无法访问的：\n但是注意，我们创建的普通类不能是protected或是private权限，因为我们目前所使用的普通类要么就是只给当前的包内使用，要么就是给外面都用，如果是private谁都不能用，那这个类定义出来干嘛呢？\n如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：\npublic class Person { String name; int age; String sex; public static void test(){ System.out.println(\u0026#34;我是静态方法！\u0026#34;); } } 我们来尝试一下静态导入：\nimport static com.test.entity.Person.test; //静态导入test方法 public class Main { public static void main(String[] args) { test(); //直接使用就可以，就像在这个类定义的方法一样 } } 至此，有关包相关的内容，我们就讲解到这里。\n封装、继承和多态 封装、继承和多态是面向对象编程的三大特性。\n封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。\n继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。\n多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。\n正是这三大特性，让我们的Java程序更加生动形象。\n类的封装 封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。\n我们可以将之前的类进行改进：\npublic class Person { private String name; //现在类的属性只能被自己直接访问 private int age; private String sex; public Person(String name, int age, String sex) { //构造方法也要声明为公共，否则对象都构造不了 this.name = name; this.age = age; this.sex = sex; } public String getName() { return name; //想要知道这个对象的名字，必须通过getName()方法来获取，并且得到的只是名字值，外部无法修改 } public String getSex() { return sex; } public int getAge() { return age; } } 我们可以来试一下：\npublic static void main(String[] args) { Person person = new Person(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); System.out.println(person.getName()); //只能通过调用getName()方法来获取名字 } 也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含\u0026quot;小\u0026quot;这个字：\npublic void setName(String name) { if(name.contains(\u0026#34;小\u0026#34;)) return; this.name = name; } 我们甚至还可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象：\npublic class Person { private String name; private int age; private String sex; private Person(){} //不允许外部使用new关键字创建对象 public static Person getInstance() { //而是需要使用我们的独特方法来生成对象并返回 return new Person(); } } 通过这种方式，我们可以实现单例模式：\npublic class Test { private static Test instance; private Test(){} public static Test getInstance() { if(instance == null) instance = new Test(); return instance; } } 单例模式就是全局只能使用这一个对象，不能创建更多的对象，我们就可以封装成这样，关于单例模式的详细介绍，还请各位小伙伴在《Java设计模式》视频教程中再进行学习。\n封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。\n类的继承 前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。\n在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中非私有的成员。\n比如说我们一开始使用的人类，那么实际上人类根据职业划分，所掌握的技能也会不同，比如画家会画画，歌手会唱，舞者会跳，Rapper会rap，运动员会篮球，我们可以将人类这个大类根据职业进一步地细分出来：\n实际上这些划分出来的类，本质上还是人类，也就是说人类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。在Java中，我们可以创建一个类的子类来实现上面的这种效果：\npublic class Person { //先定义一个父类 String name; int age; String sex; } 接着我们可以创建各种各样的子类，想要继承一个类，我们只需要使用extends关键字即可：\npublic class Worker extends Person{ //工人类 } public class Student extends Person{ //学生类 } 类的继承可以不断向下，但是同时只能继承一个类，同时，标记为final的类不允许被继承：\npublic final class Person { //class前面添加final关键字表示这个类已经是最终形态，不能继承 } 当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为private，那么子类将无法访问（但是依然是继承了这个属性的）：\npublic class Student extends Person{ public void study(){ System.out.println(\u0026#34;我的名字是 \u0026#34;+name+\u0026#34;，我在学习！\u0026#34;); //可以直接访问父类中定义的name属性 } } 同样的，在父类中定义的方法同样会被子类继承：\npublic class Person { String name; int age; String sex; public void hello(){ System.out.println(\u0026#34;我叫 \u0026#34;+name+\u0026#34;，今年 \u0026#34;+age+\u0026#34; 岁了!\u0026#34;); } } 子类直接获得了此方法，当我们创建一个子类对象时就可以直接使用这个方法：\npublic static void main(String[] args) { Student student = new Student(); student.study(); //子类不仅有自己的独特技能 student.hello(); //还继承了父类的全部技能 } 是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。\n如果父类存在一个有参构造方法，子类必须在构造方法中调用：\npublic class Person { protected String name; //因为子类需要用这些属性，所以说我们就将这些变成protected，外部不允许访问 protected int age; protected String sex; protected String profession; //构造方法也改成protected，只能子类用 protected Person(String name, int age, String sex, String profession) { this.name = name; this.age = age; this.sex = sex; this.profession = profession; } public void hello(){ System.out.println(\u0026#34;[\u0026#34;+profession+\u0026#34;] 我叫 \u0026#34;+name+\u0026#34;，今年 \u0026#34;+age+\u0026#34; 岁了!\u0026#34;); } } 可以看到，此时两个子类都报错了：\n因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了：\n既然现在父类需要三个参数才能构造，那么子类需要按照同样的方式调用父类的构造方法：\npublic class Student extends Person{ public Student(String name, int age, String sex) { //因为学生职业已经确定，所以说学生直接填写就可以了 super(name, age, sex, \u0026#34;学生\u0026#34;); //使用super代表父类，父类的构造方法就是super() } public void study(){ System.out.println(\u0026#34;我的名字是 \u0026#34;+name+\u0026#34;，我在学习！\u0026#34;); } } public class Worker extends Person{ public Worker(String name, int age, String sex) { super(name, age, sex, \u0026#34;工人\u0026#34;); //父类构造调用必须在最前面 System.out.println(\u0026#34;工人构造成功！\u0026#34;); //注意，在调用父类构造方法之前，不允许执行任何代码，只能在之后执行 } } 我们在使用子类时，可以将其当做父类来使用：\npublic static void main(String[] args) { Person person = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); //这里使用父类类型的变量，去引用一个子类对象（向上转型） person.hello(); //父类对象的引用相当于当做父类来使用，只能访问父类对象的内容 } 虽然我们这里使用的是父类类型引用的对象，但是这并不代表子类就彻底变成父类了，这里仅仅只是当做父类使用而已。\n我们也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类：\npublic static void main(String[] args) { Person person = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); Student student = (Student) person; //使用强制类型转换（向下转型） student.study(); } 但是注意，这种方式只适用于这个对象本身就是对应的子类才可以，如果本身都不是这个子类，或者说就是父类，那么会出现问题：\npublic static void main(String[] args) { Person person = new Worker(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); //实际创建的是Work类型的对象 Student student = (Student) person; student.study(); } 此时直接出现了类型转换异常，因为本身不是这个类型，强转也没用。\n那么如果我们想要判断一下某个变量所引用的对象到底是什么类，那么该怎么办呢？\npublic static void main(String[] args) { Person person = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); if(person instanceof Student) { //我们可以使用instanceof关键字来对类型进行判断 System.out.println(\u0026#34;对象是 Student 类型的\u0026#34;); } if(person instanceof Person) { System.out.println(\u0026#34;对象是 Person 类型的\u0026#34;); } } 如果变量所引用的对象是对应类型或是对应类型的子类，那么instanceof都会返回true，否则返回false。\n最后我们需要来特别说明一下，子类是可以定义和父类同名的属性的：\npublic class Worker extends Person{ protected String name; //子类中同样可以定义name属性 public Worker(String name, int age, String sex) { super(name, age, sex, \u0026#34;工人\u0026#34;); } } 此时父类的name属性和子类的name属性是同时存在的，那么当我们在子类中直接使用时：\npublic void work(){ System.out.println(\u0026#34;我是 \u0026#34;+name+\u0026#34;，我在工作！\u0026#34;); //这里的name，依然是作用域最近的哪一个，也就是在当前子类中定义的name属性，而不是父类的name属性 } 所以说，我们在使用时，实际上这里得到的结果为null：\n那么，在子类存在同名变量的情况下，怎么去访问父类的呢？我们同样可以使用super关键字来表示父类：\npublic void work(){ System.out.println(\u0026#34;我是 \u0026#34;+super.name+\u0026#34;，我在工作！\u0026#34;); //这里使用super.name来表示需要的是父类的name变量 } 这样得到的结果就不一样了：\n但是注意，没有super.super这种用法，也就是说如果存在多级继承的话，那么最多只能通过这种方法访问到父类的属性（包括继承下来的属性）\n顶层Object类 实际上所有类都默认继承自Object类，除非手动指定继承的类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：\n我们发现，除了我们自己在类中编写的方法之外，还可以调用一些其他的方法，那么这些方法不可能无缘无故地出现，肯定同样是因为继承得到的，那么这些方法是继承谁得到的呢？\npublic class Person extends Object{ //除非我们手动指定要继承的类是什么，实际上默认情况下所有的类都是继承自Object的，只是可以省略 } 所以说我们的继承结构差不多就是：\n既然所有的类都默认继承自Object，我们来看看这个类里面有哪些内容：\npublic class Object { private static native void registerNatives(); //标记为native的方法是本地方法，底层是由C++实现的 static { registerNatives(); //这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍 } //获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到 public final native Class\u0026lt;?\u0026gt; getClass(); //获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址 public native int hashCode(); //判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象 public boolean equals(Object obj) { return (this == obj); } //克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性 protected native Object clone() throws CloneNotSupportedException; //将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值 public String toString() { return getClass().getName() + \u0026#34;@\u0026#34; + Integer.toHexString(hashCode()); } //唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到 public final native void notify(); //唤醒所有等待当前对象锁的线程，同上 public final native void notifyAll(); //使得持有当前对象锁的线程进入等待状态，同上 public final native void wait(long timeout) throws InterruptedException; //同上 public final void wait(long timeout, int nanos) throws InterruptedException { ... } //同上 public final void wait() throws InterruptedException { ... } //当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到 protected void finalize() throws Throwable { } } 这里我们可以尝试调用一下Object为我们提供的toString()方法：\npublic static void main(String[] args) { Person person = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); String str = person.toString(); System.out.println(str); } 这里就是按照上面说的格式进行打印：\n当然，我们直接可以给println传入一个Object类型的对象：\npublic void println(Object x) { String s = String.valueOf(x); //这里同样会调用对象的toString方法，所以说跟上面效果是一样的 synchronized (this) { print(s); newLine(); } } 有小伙伴肯定会好奇，这里不是接受的一个Object类型的值的，为什么任意类型都可以传入呢？因为所有类型都是继承自Object，如果方法接受的参数是一个引用类型的值，那只要是这个类的对象或是这个类的子类的对象，都可以作为参数传入。\n我们也可以试试看默认提供的equals方法：\npublic static void main(String[] args) { Person p1 = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); Person p2 = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); System.out.println(p1.equals(p2)); } 因为默认比较的是两个对象是否为同一个对象，所以说这里得到的肯定是false，但是有些情况下，实际上我们所希望的情况是如果名字、年龄、性别都完全相同，那么这肯定是同一个人，但是这里却做不到这样的判断，我们需要修改一下equals方法的默认实现来完成，这就要用到方法的重写了。\n方法的重写 注意，方法的重写不同于之前的方法重载，不要搞混了，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如我们现在不希望使用Object类中提供的equals方法，那么我们就可以将其重写了：\npublic class Person{ ... @Override //重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略 public boolean equals(Object obj) { //重写方法要求与父类的定义完全一致 if(obj == null) return false; //如果传入的对象为null，那肯定不相等 if(obj instanceof Person) { //只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么 Person person = (Person) obj; //先转换为当前类型，接着我们对三个属性挨个进行比较 return this.name.equals(person.name) \u0026amp;\u0026amp; //字符串内容的比较，不能使用==，必须使用equals方法 this.age == person.age \u0026amp;\u0026amp; //基本类型的比较跟之前一样，直接== this.sex.equals(person.sex); } return false; } } 在重写Object提供的equals方法之后，就会按照我们的方式进行判断了：\npublic static void main(String[] args) { Person p1 = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); Person p2 = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); System.out.println(p1.equals(p2)); //此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象 } 有时候为了方便查看对象的各个属性，我们可以将Object类提供的toString方法重写了：\n@Override public String toString() { //使用IDEA可以快速生成 return \u0026#34;Person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, sex=\u0026#39;\u0026#34; + sex + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, profession=\u0026#39;\u0026#34; + profession + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } 这样，我们直接打印对象时，就会打印出对象的各个属性值了：\npublic static void main(String[] args) { Person person = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); System.out.println(person); } 注意，静态方法不支持重写，因为它是属于类本身的，但是它可以被继承。\n基于这种方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为，比如考试，学生考试可以得到A，而工人去考试只能得到D：\npublic class Person { ... public void exam(){ System.out.println(\u0026#34;我是考试方法\u0026#34;); } ... } public class Student extends Person{ ... @Override public void exam() { System.out.println(\u0026#34;我是学生，我就是小镇做题家，拿个 A 轻轻松松\u0026#34;); } } public class Worker extends Person{ ... @Override public void exam() { System.out.println(\u0026#34;我是工人，做题我并不擅长，只能得到 D\u0026#34;); } } 这样，不同的子类，对于同一个方法会产生不同的结果：\npublic static void main(String[] args) { Person person = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); person.exam(); person = new Worker(\u0026#34;小强\u0026#34;, 18, \u0026#34;男\u0026#34;); person.exam(); } 这其实就是面向对象编程中多态特性的一种体现。\n注意，我们如果不希望子类重写某个方法，我们可以在方法前添加final关键字，表示这个方法已经是最终形态：\npublic final void exam(){ System.out.println(\u0026#34;我是考试方法\u0026#34;); } 或者，如果父类中方法的可见性为private，那么子类同样无法访问，也就不能重写，但是可以定义同名方法：\n虽然这里可以编译通过，但是并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。\n还有，我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用super关键字：\n@Override public void exam() { super.exam(); //调用父类的实现 System.out.println(\u0026#34;我是工人，做题我并不擅长，只能得到 D\u0026#34;); } 然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性：\npublic void exam(){ System.out.println(\u0026#34;我是考试方法\u0026#34;); } 因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，我们可以在子类中提升权限：\nprotected void exam(){ System.out.println(\u0026#34;我是考试方法\u0026#34;); } @Override public void exam() { //将可见性提升为public System.out.println(\u0026#34;我是工人，做题我并不擅长，只能得到 D\u0026#34;); } 可以看到作为子类时就可以正常调用，但是如果将其作为父类使用，因为访问权限不足所有就无法使用，总之，子类重写的方法权限不能比父类还低。\n抽象类 在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象，比如我们前面编写的考试方法：\nprotected void exam(){ System.out.println(\u0026#34;我是考试方法\u0026#34;); } 这个方法再子类中一定会被重写，所以说除非子类中调用父类的实现，否则一般情况下永远都不会被调用，就像我们说一个人会不会考试一样，实际上人怎么考试是一个抽象的概念，而学生怎么考试和工人怎么考试，才是具体的一个实现，所以说，我们可以将人类进行进一步的抽象，让某些方法完全由子类来实现，父类中不需要提供实现。\n要实现这样的操作，我们可以将人类变成抽象类，抽象类比类还要抽象：\npublic abstract class Person { //通过添加abstract关键字，表示这个类是一个抽象类 protected String name; //大体内容其实普通类差不多 protected int age; protected String sex; protected String profession; protected Person(String name, int age, String sex, String profession) { this.name = name; this.age = age; this.sex = sex; this.profession = profession; } public abstract void exam(); //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体 } 而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法：\npublic class Worker extends Person{ public Worker(String name, int age, String sex) { super(name, age, sex, \u0026#34;工人\u0026#34;); } @Override public void exam() { //子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译 System.out.println(\u0026#34;我是工人，做题我并不擅长，只能得到 D\u0026#34;); } } 抽象类由于不是具体的类定义（它是类的抽象）可能会存在某些方法没有实现，因此无法直接通过new关键字来直接创建对象：\n要使用抽象类，我们只能去创建它的子类对象。\n抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类：\npublic abstract class Student extends Person{ //如果抽象类的子类也是抽象类，那么可以不用实现父类中的抽象方法 public Student(String name, int age, String sex) { super(name, age, sex, \u0026#34;学生\u0026#34;); } @Override //抽象类中并不是只能有抽象方法，抽象类中也可以有正常方法的实现 public void exam() { System.out.println(\u0026#34;我是学生，我就是小镇做题家，拿个 A 轻轻松松\u0026#34;); } } 注意，抽象方法的访问权限不能为private：\n因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。\n接口 接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）\n咋一看，这啥意思啊，什么叫支持接口代表的功能？实际上接口的目标就是将类所具有某些的行为抽象出来。\n比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：\npublic interface Study { //使用interface表示这是一个接口 void study(); //接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略 } 我们可以让类实现这个接口：\npublic class Student extends Person implements Study { //使用implements关键字来实现接口 public Student(String name, int age, String sex) { super(name, age, sex, \u0026#34;学生\u0026#34;); } @Override public void study() { //实现接口时，同样需要将接口中所有的抽象方法全部实现 System.out.println(\u0026#34;我会学习！\u0026#34;); } } public class Teacher extends Person implements Study { protected Teacher(String name, int age, String sex) { super(name, age, sex, \u0026#34;教师\u0026#34;); } @Override public void study() { System.out.println(\u0026#34;我会加倍学习！\u0026#34;); } } 接口不同于继承，接口可以同时实现多个：\npublic class Student extends Person implements Study, A, B, C { //多个接口的实现使用逗号隔开 } 所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。\n接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用：\n当做接口使用时，只有接口中定义的方法和Object类的方法，无法使用类本身的方法和父类的方法。\n接口同样支持向下转型：\npublic static void main(String[] args) { Study study = new Teacher(\u0026#34;小王\u0026#34;, 27, \u0026#34;男\u0026#34;); if(study instanceof Teacher) { //直接判断引用的对象是不是Teacher类型 Teacher teacher = (Teacher) study; //强制类型转换 teacher.study(); } } 这里的使用其实跟之前的父类是差不多的。\n从Java8开始，接口中可以存在方法的默认实现：\npublic interface Study { void study(); default void test() { //使用default关键字为接口中的方法添加默认实现 System.out.println(\u0026#34;我是默认实现\u0026#34;); } } 如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。\n接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法，在接口中定义的变量只能是：\npublic interface Study { public static final int a = 10; //接口中定义的静态变量只能是public static final的 public static void test(){ //接口中定义的静态方法也只能是public的 System.out.println(\u0026#34;我是静态方法\u0026#34;); } void study(); } 跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容：\npublic static void main(String[] args) { System.out.println(Study.a); Study.test(); } 接口是可以继承自其他接口的：\npublic interface A exetnds B { } 并且接口没有继承数量限制，接口支持多继承：\npublic interface A exetnds B, C, D { } 接口的继承相当于是对接口功能的融合罢了。\n最后我们来介绍一下Object类中提供的克隆方法，为啥要留到这里才来讲呢？因为它需要实现接口才可以使用：\npackage java.lang; public interface Cloneable { //这个接口中什么都没定义 } 实现接口后，我们还需要将克隆方法的可见性提升一下，不然还用不了：\npublic class Student extends Person implements Study, Cloneable { //首先实现Cloneable接口，表示这个类具有克隆的功能 public Student(String name, int age, String sex) { super(name, age, sex, \u0026#34;学生\u0026#34;); } @Override public Object clone() throws CloneNotSupportedException { //提升clone方法的访问权限 return super.clone(); //因为底层是C++实现，我们直接调用父类的实现就可以了 } @Override public void study() { System.out.println(\u0026#34;我会学习！\u0026#34;); } } 接着我们来尝试一下，看看是不是会得到一个一模一样的对象：\npublic static void main(String[] args) throws CloneNotSupportedException { //这里向上抛出一下异常，还没学异常，所以说照着写就行了 Student student = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); Student clone = (Student) student.clone(); //调用clone方法，得到一个克隆的对象 System.out.println(student); System.out.println(clone); System.out.println(student == clone); } 可以发现，原对象和克隆对象，是两个不同的对象，但是他们的各种属性都是完全一样的：\n通过实现接口，我们就可以很轻松地完成对象的克隆了，在我们之后的学习中，还会经常遇到接口的使用。\n**注意：**以下内容为选学内容，在设计模式篇视频教程中有详细介绍。\n克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。\n**浅拷贝：**对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。 **深拷贝：**无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。 那么clone方法出来的克隆对象，是深拷贝的结果还是浅拷贝的结果呢？\npublic static void main(String[] args) throws CloneNotSupportedException { Student student = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); Student clone = (Student) student.clone(); System.out.println(student.name == clone.name); } 可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的clone方法只会进行浅拷贝。\n枚举类 假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：\npublic class Student extends Person implements Study { private String status; //状态，可以是跑步、学习、睡觉这三个之中的其中一种 public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } } 但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的，有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们预先定义好的状态，所以，我们可以使用枚举类来完成：\npublic enum Status { //enum表示这是一个枚举类，枚举类的语法稍微有一些不一样 RUNNING, STUDY, SLEEP; //直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上 } 使用枚举类也非常方便，就像使用普通类型那样：\nprivate Status status; //类型变成刚刚定义的枚举类 public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } 这样，别人在使用时，就能很清楚地知道我们支持哪些了：\n枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量：\n//这里使用javap命令对class文件进行反编译得到 Compiled from \u0026#34;Status.java\u0026#34; public final class com.test.Status extends java.lang.Enum\u0026lt;com.test.Status\u0026gt; { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {}; } 既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：\npublic enum Status { RUNNING(\u0026#34;睡觉\u0026#34;), STUDY(\u0026#34;学习\u0026#34;), SLEEP(\u0026#34;睡觉\u0026#34;); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; } } 这样，枚举就可以按照我们想要的中文名称打印了：\npublic static void main(String[] args) { Student student = new Student(\u0026#34;小明\u0026#34;, 18, \u0026#34;男\u0026#34;); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName()); } 枚举类还自带一些继承下来的实用方法，比如获取枚举类中的所有枚举，只不过这里用到了数组，我们会在下一章进行介绍。\n至此，面向对象基础内容就全部讲解完成了，下一章我们还将继续讲解面向对象的其他内容。\n","permalink":"https://blog.l50.top/posts/javase%E7%AC%94%E8%AE%B0%E4%B8%89%E9%87%8D%E5%88%B6%E7%89%88/","summary":"面向对象基础篇 我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。\n面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。\n这一章开始难度就上来了，所以说请各位小伙伴一定认真。\n类与对象 类的概念我们在生活中其实已经听说过很多了。\n人类、鸟类、鱼类\u0026hellip; 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。\n对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。\n所以说，类就是抽象概念的人，而对象，就是具体的某一个人。\nA：是谁拿走了我的手机？ B：是个人。（某一个类） A：我还知道是个人呢，具体是谁呢？ B：是XXX。（具体某个对象） 而我们在Java中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象。像这种编程方式，我们称为面向对象编程。\n类的定义与对象创建 前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。\n比如现在我们想要定义一个人类，我们可以右键src目录，点击创建新的类：\n我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。\n可以看到，现在我们的目录下有了两个.java源文件，其中一个是默认创建的Main.java，还有一个是我们刚刚创建的类。\n我们来看看创建好之后，一个类写了哪些内容：\npublic class Person { } 可以发现，这不是跟一开始创建的Main中写的格式一模一样吗？没错，Main也是一个类，只不过我们一直都将其当做主类在使用，也就是编写主方法的类，关于方法我们会在后面进行介绍。\n现在我们就创建好了一个类，既然是人类，那么肯定有人相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？\n我们可以将这些属性直接作为类的成员变量（成员变量相当于是这个类所具有的属性，每个实例创建出来之后，这些属性都可能会各不相同）定义到类中。\npublic class Person { //这里定义的人类具有三个属性，名字、年龄、性别 String name; //直接在类中定义变量，表示类具有的属性 int age; String sex; } 可能会有小伙伴疑问，这些变量啥时候被赋值呢？实际上这些变量只有在一个具体的对象中才可以使用。\n那么现在人类的属性都规定好了，我们就可以尝试创建一个实例对象了，实例对应的应该是一个具体的人：\nnew 类名(); public static void main(String[] args) { new Person(); //我们可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名() //这里创建出来的，就是一个具体的人了 } 实际上整个流程为：\n只不过这里仅仅是创建出了这样的一个对象，我们目前没有办法去操作这个对象，比如想要修改或是获取这个人的名字等等。\n对象的使用 既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。\n我们同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身：\npublic static void main(String[] args) { //这里的a存放的是具体的某个值 int a = 10; //创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名 //这里的p存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象 Person p = new Person(); } 至于为什么对象类型的变量存放的是对象的引用，比如：","title":"JavaSE笔记（三）重制版"},{"content":" 面向过程篇 前面我们已经认识了Java语言的相关特性，并且已经成功配置好了开发环境，从这节课开始，我们就可以正式进入到Java语言的学习当中了。Java语言是一门面向对象的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。\nJava程序基础 首先我们还是从最基本的Java程序基础开始讲解。\n程序代码基本结构 还记得我们之前使用的示例代码吗？\npublic class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } 这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。\n由于我们还没有学习到类的相关性质，所以在第二章之前，各位小伙伴直接记住固定模式即可，首先我们创建的源文件名称需要为Main.java然后编写的代码第一行：\npublic class Main { } 注意需要区分大小写，Java语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错：\n只要源代码中存在报错的地方，就无法正常完成编译得到二进制文件，会提示构建失败：\n注意最后还有一个花括号，并且此花括号是成对出现的，一一对应。\n所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是：\npublic static void main(String[] args) { } 这是我们整个Java程序的入口点，我们称为主方法（如果你学习过C肯定能够联想到主函数，只不过Java中不叫函数，叫方法）最后也会有一个花括号成对出现，而在主方法的花括号中编写的代码，就是按照从上往下的顺序依次执行的。\n比如我们之前编写的：\nSystem.out.println(\u0026#34;Hello World!\u0026#34;); 这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上，可以看到最后还加上了一个;符号，表示这一句代码结束。我们每一段代码结束时都需要加上一个分号表示这一句的结束，就像我们写作文一样。\n比如下面的代码，我们就可以实现先打印Hello World!，然后再打印YYDS!到控制台。\npublic class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); System.out.println(\u0026#34;YYDS!\u0026#34;); } } 效果如下：\n如果两段代码没有加上分号分割，那么编译器会认为这两段代码是同一句代码中的，即使出现换行或者是空格：\n这里IDEA很聪明，会提醒我们这里少加了分号，所以说这个IDEA能够在初期尽可能地帮助新手。\n再比如下面的代码：\n这里我们尝试在中途换行和添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意进行换行编写或者是添加没必要的空格。\n同样的，如果添加了分号，即使在同一行，也会被认为是两句代码：\n如果在同一行就是从左往右的顺序，得到的结果跟上面是一样的。\n注释 我们在编写代码时，可能有些时候需要标记一下这段代码表示什么意思：\n但是如果直接写上文字的话，会导致编译不通过，因为这段文字也会被认为是程序的一部分。\n这种情况，我们就可以告诉编译器，这段文字是我们做的笔记，并不是程序的一部分，那么要怎么告诉编译器这不是代码呢？很简单，我们只需要在前面加上双斜杠就可以了：\n添加双斜杠之后（自动变成了灰色），后续的文本内容只要没有发生换行，那么都会被认为是一段注释，并不属于程序，在编译时会被直接忽略，之后这段注释也不会存在于程序中。但是一旦发生换行那就不行了：\n那要是此时注释很多，一行写不完，我们想要编写很多行的注释呢？我们可以使用多行注释标记：\npublic class Main { public static void main(String[] args) { /* 这里面的内容 无论多少行 都可以 */ System.out.println(\u0026#34;Hello World!\u0026#34;); } } 多行可以使用/*和*/的组合来囊括需要编写的注释内容。\n当然还有一种方式就是使用/**来进行更加详细的文档注释：\n这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。\n变量与常量 我们的程序不可能永远都只进行上面那样的简单打印操作，有些时候可能需要计算某些数据，此时我们就需要用到变量了。\n那么，什么是变量呢？我们在数学中其实已经学习过变量了：\n变量，指值可以变的量。变量以非数字的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。\n比如一个公式 $x^2 + 6 = 22$ 此时x就是一个变量，变量往往代表着某个值，比如这里的x就代表的是4这个值。在Java中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的。\n要声明一个变量，我们需要使用以下格式：\n[数据类型] [变量名称]; 这里的数据类型我们会在下节课开始逐步讲解，比如整数就是int类型，不同类型的变量可以存储不同的类型的值。后面的变量名称顾名思义，就像x一样，这个名称我们可以随便起一个，但是注意要满足以下要求：\n标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。 变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。 不能有空格、@、#、+、-、/ 等符号。 应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。 不可以是 true 和 false。 不能与Java语言的关键字或是基本数据类型重名，关键字列表如下： ![image-20220916224014438](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220916224014438.png)\n当然各位小伙伴没必要刻意去进行记忆，我们会在学习的过程中逐步认识到这些关键字。新手要辨别一个单词是否为关键字，只需要通过IDEA的高亮颜色进行区分即可，比如：\n深色模式下，关键字会高亮为橙色，浅色模式下会高亮为深蓝色，普通的代码都是正常的灰白色。\n比如现在我们想要定义一个变量a，那么就可以这样编写：\npublic class Main { public static void main(String[] args) { int a; //声明一个整数类型变量a } } 但是这个变量一开始没有任何值，比如现在我们要让这个变量表示10，那么就可以将10赋值给这个变量：\npublic static void main(String[] args) { int a = 10; //直接在定义变量后面添加 = 10，表示这个变量的初始值为10，这里的10就是一个常量数字 } 或者我们可以在使用时再对其进行赋值：\npublic static void main(String[] args) { int a; a = 10; //使用时再赋值也可以 } 是不是感觉跟数学差不多？这种写法对于我们人来说，实际上是很好理解的，意思表达很清晰。\n我们可以一次性定义多个变量，比如现在我们想定义两个int类型的变量：\npublic static void main(String[] args) { int a, b; //定义变量a和变量b，中间使用逗号隔开就行了 } 或者两个变量单独声明也可以：\npublic static void main(String[] args) { int a; //分两句进行声明 int b; } 为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台：\npublic static void main(String[] args) { int a = 666; System.out.println(a); //之前我们在小括号写的是\u0026#34;\u0026#34;，现在我们直接将变量给进去就可以打印变量的值了 System.out.println(888); //甚至直接输出一个常量值都可以 } 得到结果：\n变量的值也可以在中途进行修改：\npublic static void main(String[] args) { int a = 666; a = 777; System.out.println(a); //这里打印得到的值就是777了 } 变量的值也可以直接指定为其他变量的值：\npublic static void main(String[] args) { int a = 10; int b = a; //直接让b等于a，那么a的值就会给到b System.out.println(b); //这里输出的就是10了 } 我们还可以让变量与数值之间做加减法（运算符会在后面详细介绍）：\npublic static void main(String[] args) { int a = 9; //a初始值为9 a = a + 1; //a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧 System.out.println(a); //最后得到的结果就是10了 } 有时候我们希望变量的值一直保持不变，我们就可以将其指定为常量，这里我们介绍Java中第一个需要认识的关键字：\npublic static void main(String[] args) { final int a = 666; //在变量前面添加final关键字，表示这是一个常量 a = 777; //常量的值不允许发生修改 } 编译时出现：\n常量的值只有第一次赋值可以修改，其他任何情况下都不行：\npublic static void main(String[] args) { final int a; a = 777; //第一次赋值 } 至此，Java的基础语法部分介绍完毕，下一部分我们将开始介绍Java中的几大基本数据类型。\n基本数据类型 我们的程序中可能需要表示各种各样的数据，比如整数、小数、字符等等，这一部分我们将探索Java中的八大基本数据类型。只不过在开始之前，我们还需要先补充一点简单的计算机小知识。\n计算机中的二进制表示 在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。\n注意这里的bit跟我们生活中的网速MB/s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit = 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100/8 = 12.5 MB/s了。\n十进制的7 -\u0026gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0\n现在有4个bit位，最大能够表示多大的数字呢？\n最小：0000 =\u0026gt; 0 最大：1111 =\u0026gt; 23+22+21+20 =\u0026gt; 8 + 4 + 2 + 1 = 15 在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：\n最小：1111 =\u0026gt; -(22+21+2^0) =\u0026gt; -7 最大：0111 =\u0026gt; +(22+21+2^0) =\u0026gt; +7 =\u0026gt; 7 现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：\n1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）\n我们得创造一种更好的表示方式！于是我们引入了反码：\n正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 经过上面的定义，我们再来进行加减法：\n1+(-1) = 0001 + 1110 = 1111 =\u0026gt; -0 （直接相加，这样就简单多了！）\n思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：\n正数的补码就是其本身 （不变！） 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8） 对补码再求一次补码就可得该补码对应的原码。 比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。\n所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算：\n1+(-1) = 0001 + 1111 = (1)0000 =\u0026gt; +0 （现在无论你怎么算，也不会有-0了！）\n所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。\n整数类形 整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。\n在Java中，整数类型包括以下几个：\nbyte 字节型 （8个bit，也就是1个字节）范围：-128~+127 short 短整形（16个bit，也就是2个字节）范围：-32768~+32767 int 整形（32个bit，也就是4个字节）最常用的类型：-2147483648 ~ +2147483647 long 长整形（64个bit，也就是8个字节）范围：-9223372036854775808 ~ +9223372036854775807 这里我们来使用一下，其实这几种变量都可以正常表示整数：\npublic static void main(String[] args) { short a = 10; System.out.println(a); } 因为都可以表示整数，所以说我们可以将小的整数类型值传递给大的整数类型：\npublic static void main(String[] args) { short a = 10; int b = a; //小的类型可以直接传递给表示范围更大的类型 System.out.println(b); } 反之会出现报错：\n这是由于我们在将小的整数类型传递给大的整数类型时发生了隐式类型转换，只要是从存储范围小的类型到存储范围大的类型，都支持隐式类型转换，它可以自动将某种类型的值，转换为另一种类型，比如上面就是将short类型的值转换为了int类型的值。\n隐式类型转换不仅可以发生在整数之间，也可以是其他基本数据类型之间，我们后面会逐步介绍。\n实际上我们在为变量赋一个常量数值时，也发生了隐式类型转换，比如：\npublic static void main(String[] args) { byte b = 10; //这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值 } 由于直接编写的整数常量值默认为int，这里需要特别注意一下，比如下面这种情况：\n按照long类型的规定，实际上是可以表示这么大的数字的，但是为什么这里报错了呢？这是因为我们直接在代码中写的常量数字，默认情况下就是int类型，这么大肯定是表示不下的，如果需要将其表示为一个long类型的常量数字，那么需要在后面添加大写或是小写的L才可以。\npublic static void main(String[] args) { long a = 922337203685477580L; //这样就可以正常编译通过了 } 当然，针对于这种很长的数字，为了提升辨识度，我们可以使用下划线分割每一位：\npublic static void main(String[] args) { int a = 1_000_000; //当然这里依然表示的是1000000，没什么区别，但是辨识度会更高 } 我们也可以以8进制或是16进制表示一个常量值：\npublic static void main(String[] args) { System.out.println(0xA); System.out.println(012); } **十六进制：**以0x开头的都是十六进制表示法，十六进制满16进一，但是由于我们的数学只提供了0-9这十个数字，10、11、12\u0026hellip;15该如何表示呢，我们使用英文字母A按照顺序开始表示，A表示10、B表示11\u0026hellip;F表示15。比如上面的0xA实际上就是我们十进制中的10。 **八进制：**以0开头的都是八进制表示法，八进制就是满8进一，所以说只能使用0-7这几个数字，比如上面的012实际上就是十进制的10。 我们最后再来看一个问题：\npublic static void main(String[] args) { int a = 2147483647; //int最大值 a = a + 1; //继续加 System.out.println(a); } 此时a的值已经来到了int类型所能表示的最大值了，那么如果此时再继续+1，各位小伙伴觉得会发生什么？可以看到结果很奇怪：\n什么情况？？？怎么正数加1还变成负数了？请各位小伙伴回想一下我们之前讲解的原码、反码和补码。\n我们先来看看，当int为最大值时，二进制表示形式为什么：\n2147483647 = 01111111 11111111 11111111 11111111（第一个是符号位0，其他的全部为1，就是正数的最大值） 那么此时如果加1，会进位成：\n10000000 00000000 00000000 00000000 各位想一想，符号位为1，那么此时表示的不就是一个负数了吗？我们回想一下负数的补码表示规则，瞬间就能明白了，这不就是补码形式下的最小值了吗？\n所以说最后的结果就是int类型的最小值：-2147483648，是不是感觉了解底层原理会更容易理解这是为什么。\n浮点类型 前面我们介绍了整数类型，我们接着来看看浮点类型，在Java中也可以轻松地使用小数。\n首先来看看Java中的小数类型包含哪些：\nfloat 单精度浮点型 （32bit，4字节） double 双精度浮点型（64bit，8字节） 那么小数在计算机中又是如何存放的呢？\n根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式： $$ V = (-1)^S \\times M \\times 2^E $$\n$(-1)^S$ 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。 M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据） $2^E$ 表示指数位。（用于移动小数点，所以说才称为浮点型） 比如， 对于十进制的 5.25 对应的二进制为：101.01，相当于：$1.0101 \\times 2^2$。所以，S 为 0，M 为 1.0101，E 为 2。因此，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码，所以浮点类型的大致取值范围：\n单精度：$±3.40282347 \\times 10^{38}$ 双精度：$±1.79769313486231570 \\times 10^{308}$ 我们可以直接创建浮点类型的变量：\npublic static void main(String[] args) { double a = 10.5, b = 66; //整数类型常量也可以隐式转换到浮点类型 } 注意，跟整数类型常量一样，小数类型常量默认都是double类型，所以说如果我们直接给一个float类型赋值：\n由于float类型的精度不如double，如果直接给其赋一个double类型的值，会直接出现错误。\n同样的，我们可以给常量后面添加大写或小写的F来表示这是一个float类型的常量值：\npublic static void main(String[] args) { float f = 9.9F; //这样就可以正常编译通过了 } 但是反之，由于double精度更大，所以说可以直接接收float类型的值：\npublic static void main(String[] args) { float f = 9.9F; double a = f; //隐式类型转换为double值 System.out.println(a); } 只不过由于精度问题，最后的打印结果：\n这种情况是正常的，因为浮点类型并不保证能够精确计算，我们会在下一章介绍 BigDecimal 和 BigInteger，其中BigDecimal更适合需要精确计算的场景。\n我们最后来看看下面的例子：\npublic static void main(String[] args) { long l = 21731371236768L; float f = l; //这里能编译通过吗？ System.out.println(f); } 此时我们发现，long类型的值居然可以直接丢给float类型隐式类型转换，很明显float只有32个bit位，而long有足足64个，这是什么情况？怎么大的还可以隐式转换为小的？这是因为虽然float空间没有那么大，但是由于是浮点类型，指数可以变化，最大的数值表示范围实际上是大于long类型的，虽然会丢失精度，但是确实可以表示这么大的数。\n所以说我们来总结一下隐式类型转换规则：byte→short(char)→int→long→float→double\n字符类型 字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）\nchar 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535 可以看到char类型依然存储的是数字，那么它是如何表示每一个字符的呢？实际上每个数字在计算机中都会对应一个字符，首先我们需要介绍ASCII码：\n比如我们的英文字母A要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，所以说当char为65时，打印出来的结果就是大写的字母A了：\npublic static void main(String[] args) { char c = 65; System.out.println(c); } 得到结果为：\n或者我们也可以直接写一个字符常量值赋值：\npublic static void main(String[] args) { char c = \u0026#39;A\u0026#39;; //字符常量值需要使用单引号囊括，并且内部只能有一个字符 System.out.println(c); } 这种写法效果与上面是一样的。\n不过，我们回过来想想，这里的字符表里面不就128个字符吗，那char干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。\n我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。\n不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。\n虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode（准确的说应该是规定的字符集，包含了几乎全世界所有语言的字符），规定每个字符必须使用两个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）\n但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，肯定不能直接就这样去表示，这会导致某些字符浪费了很多空间，我们需要一个更加好用的具体的字符编码方式。所以最后就有了UTF-8编码格式（它是Unicode字符集的一个编码规则），区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：\n10000011 10000110 //这就是一个连续出现都大于127的字节（注意这里是不考虑符号位的） 所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式，随着更多的字符加入，实际上两个字节也装不下了，可能需要3个甚至4个字节才能表示某些符号，后来就有了UTF-16编码格式，Java在运行时采用的就是UTF-16，几乎全世界的语言用到的字符都可以表示出来。\nUnicode符号范围（十六进制） UTF-8编码方式(二进制) 0000 0000 ~ 0000 007F 0xxxxxxx 0000 0080 ~ 0000 07FF 110xxxxx 10xxxxxx 0000 0800 ~ 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 ~ 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx **注意：**Unicode 是“字符集”，也就是有哪些字符，而UTF-8、UTF-16 是“编码规则”，也就是怎么对这些字符编码，怎么以二进制的形式保存，千万不要搞混了。\n简而言之，char实际上需要两个字节才能表示更多种类的字符，所以，char类型可以直接表示一个中文字符：\npublic static void main(String[] args) { int a = \u0026#39;淦\u0026#39;; //使用int类型接收字符类型常量值可以直接转换为对应的编码 System.out.println(a); } 得到结果为：\nJava程序在编译为.class文件之后，会采用UTF-8的编码格式，支持的字符也非常多，所以你甚至可以直接把变量名写成中文，依然可以编译通过：\n介绍完了字符之后，我们接着来看看字符串，其实字符串我们在一开始就已经接触到了。字符虽然可以表示一个中文，但是它没办法表示多个字符：\n但是实际上我们使用率最高的还是多个字符的情况，我们需要打印一连串的字符。这个时候，我们就可以使用字符串了：\npublic static void main(String[] args) { String str = \u0026#34;啊这\u0026#34;; //字符串需要使用双引号囊括，字符串中可以包含0-N个字符 } 注意，这里使用的类型是String类型，这种类型并不是基本数据类型，它是对象类型，我们会在下一章继续对其进行介绍，这里我们只需要简单了解一下就可以了。\n布尔类型 布尔类型是Java中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态：\ntrue - 真 false - 假 布尔类型（boolean）只有true和false两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。\npublic static void main(String[] args) { boolean b = true; //值只能是true或false System.out.println(b); } 如果给一个其他的值，会无法编译通过：\n至此，基本数据类型的介绍就结束了。\n运算符 前面我们介绍了多种多样的基本数据类型，但是光有这些基本数据类型还不够，我们还需要让这些数据之间进行运算，才可以真正意义上发挥计算机的作用。\n要完成计算，我们需要借助运算符来完成，实际上我们在数学中就已经接触过多种多样的运算符了。\n比如：+ - × ÷\n这些运算符都是我们在初等数学中学习的，而使用规则也很简单，我们只需要将需要进行运算的两个数放到运算符的两边就可以了：\n比如：10 ÷ 2\n上面运算的结果就是5了，而在Java中，我们同样可以使用这样的方式来进行运算。\n赋值运算符 首先我们还是来回顾一下之前认识的老朋友：赋值运算符。\n赋值运算符可以直接给某个变量赋值：\npublic static void main(String[] args) { int a = 666; //使用等号进行赋值运算 } **使用规则为：**赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。\n当然，赋值运算符并不只是单纯的赋值，它是有结果的：\npublic static void main(String[] args) { int a; int b = a = 777; } 当出现连续使用赋值运算符时，按照从右往左的顺序进行计算，首先是a = 777，计算完成后，a的值就变成了777，计算完成后，会得到计算结果（赋值运算的计算结果就是赋的值本身，就像1 + 1的结果是2一样，a = 1的结果就是1）此时继续进行赋值计算，那么b就被赋值为a = 777的计算结果，同样的也是 777 了。\n所以，使用连等可以将一连串变量都赋值为最右边的值。\n算术运算符 算术运算符也就是我们初等数学中认识的这些运算符，包括加减乘除，当然Java还支持取模运算，算术运算同样需要左右两边都有一个拿来计算的目标。\npublic static void main(String[] args) { int a = 1 + 1; System.out.println(a); } 可以看到a赋值为1+1的结果，所以说最后a就是2了。\n当然变量也是可以参与到算术运算中：\npublic static void main(String[] args) { int a = 3; int b = a - 10; System.out.println(b); } 不同类型之间也可以进行运算：\npublic static void main(String[] args) { int a = 5; short b = 10; int c = a + b; //不同类型的整数一起运算，小类型需要转换为大类型，short、byte、char一律转换为int再进行计算（无论算式中有无int，都需要转换），结果也是int；如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，反正就是依大的来 } 因为运算时会发生隐式类型转换，所以说这里b自动转换为了int类型进行计算，所以说最后得到结果也一定是转换后的类型：\n小数和整数一起计算同样会发生隐式类型转换：\n因为小数表示范围更广，所以说整数会被转换为小数再进行计算，而最后的结果也肯定是小数了。\n我们也可以将加减号作为正负符号使用，比如我们现在需要让a变成自己的相反数：\npublic static void main(String[] args) { int a = 10; a = -a; //减号此时作为负号运算符在使用，会将右边紧跟的目标变成相反数 System.out.println(a); //这里就会得到-10了 } 同样的，正号也可以使用，但是似乎没什么卵用：\npublic static void main(String[] args) { int a = 10; a = +a; //正号本身在数学中就是可以省略的存在，所以Java中同样如此 System.out.println(a); } 注意加法支持对字符串的拼接：\npublic static void main(String[] args) { String str = \u0026#34;伞兵\u0026#34; + \u0026#34;lbw\u0026#34;; //我们可以使用加号来拼接两个字符串 System.out.println(str); } 最后这个字符串就变成了拼接后的结果了：\n字符串不仅可以跟字符串拼接，也可以跟基本数据类型拼接：\npublic static void main(String[] args) { String str = \u0026#34;伞兵\u0026#34; + true + 1.5 + \u0026#39;A\u0026#39;; System.out.println(str); } 最后就可以得到对应的结果了：\n当然，除了加减法之外乘除法也是支持的：\npublic static void main(String[] args) { int a = 8, b = 2; System.out.println(a * b); //乘法使用*表示乘号 System.out.println(a / b); //除法就是一个/表示除号 } 注意，两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）\npublic static void main(String[] args) { int a = 8, b = 5; System.out.println(a / b); } 上面是两个int类型的值进行的除法运算，正常情况下8除以5应该得到1.6，但是由于结果也是整数，所以说最后小数部分被丢弃：\n但是如果是两个小数一起计算的话，因为结果也是小数，所以说就可以准确得到结果：\npublic static void main(String[] args) { double a = 8.0, b = 5.0; System.out.println(a / b); } 同样的，整数和小数一起计算，由于所有的整数范围都比小数小，根据我们上一部分介绍的转换规则，整数和小数一起计算时，所有的整数都会变成小数参与运算，所以说最后的结果也就是小数了，同样可以得到正确的结果：\npublic static void main(String[] args) { double a = 8.0; int b = 5; System.out.println(a / b); } 那么问题来了，现在我们有两个整数需要进行计算，但是我们就是希望可以得到一个小数的结果该怎么办呢？\npublic static void main(String[] args) { int a = 8, b = 5; double c = a; //我们可以将其先隐式转换为小数类型，再那转换后的小数变量去参与计算 System.out.println(c / b); //同样可以得到正确结果 } 在下一节，我们将介绍强制类型转换，通过使用强制类型转换，我们可以更轻松地让整数计算出小数的结果。\n除了最基本的加减乘除操作，我们也可以进行取模操作：\npublic static void main(String[] args) { int a = 10; System.out.println(a % 3); //比如这里对a进行取模操作，实际上就是计算除以3的余数 } 比如上面的是 10 % 3 得到的结果就是10除以3最后的余数1，取模操作也是非常好用的。\n比如我们查看某个数是否为双数，只需要将其对2进行取模操作即可，因为如果是双数一定是可以整除的，如果是单数一定会余1：\npublic static void main(String[] args) { System.out.println(17 % 2); //17不是双数，所以说最后会得到1 } 注意，运算符之间是有优先级之分的，比如乘除法优先级高于加减法：\npublic static void main(String[] args) { System.out.println(10 + 3 * 4); } 上面的算式按照数学中的规则，应该先计算3 * 4，然后再进行加法计算，而Java中同样遵循这样的规律。我们来总结一下到目前为止所有学习到的运算符相关性质：\n优先级 运算符 结合性（出现同优先级运算符时） 1 -(负号) +(正号) 从右向左 2 * / % 从左往右 3 +(加法，包括字符串) -(减法) 从左往右 4 = 从右向左 比如下面的结果：\npublic static void main(String[] args) { int a = 10; int b = a = 8 * -a + 10; /* 1. 正负号优先级最高，所有首先计算的是-a，得到-10 2. 其次是乘除号优先级更高，所以说这里计算 8 * -10，得到 -80 3. 然后是加减法，-80 + 10 = -70 4. 最后是赋值运算，因为等号运算符从右往左结合，先算a = -70的结果就是 -70 5. 最后b就是 -70 */ System.out.println(b); } 通过使用这些基本算术运算符，我们就可以更加快速地计算我们想要的结果了。\n括号运算符 前面我们介绍了算术运算符，我们接着来看括号运算符。\n我们常常在数学中使用括号提升某些运算的优先级，比如：\n(1 + 7) × (3 - 6) = -24\n虽然加法优先级比乘法要低但是我们给其添加括号之后，相当于提升了内部加法运算的优先级，所以说需要先计算括号中的再去计算括号外的，Java同样满足这个要求。\n我们可以通过添加括号的方式来提升某些运算的优先级：\npublic static void main(String[] args) { int a = 10; int b = (a = 8) * (-a + 10); /* 1. 括号的优先级是最高的，我们需要先计算括号中的内容，如果存在多个括号，就从左往右计算 2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8 3. 然后是后面的加法，-a就是-8，加上10就是2 4. 最后才是乘法，左边此时是8，右边是2，最后结果为16 */ System.out.println(b); } 所以，通过添加括号，就可以更加灵活的控制计算。\n当然，括号是可以嵌套的，这一点跟数学中也是一样的，只不过我们不需要使用方括号和花括号，一律使用小括号就行了。\n在嵌套的情况下，会优先计算最内层括号中的算式：\npublic static void main(String[] args) { int b = (2 + (3 + 1) * 3) * 2; System.out.println(b); } 这里会优先计算 3 + 1的结果，然后由于第二层都在一个括号中，所以说按照正常优先级计算，2 + 4 * 3 = 14，最后来到最外层14*2 = 28，计算结束。\n括号除了可以用来提升运算优先级，也可以用作强制类型转换，前面我们介绍了隐式类型转换，但是隐式类型转换存在局限性，比如此时我们希望将一个大的类型转换为一个小的类型：\n正常情况下无法编译通过，但是实际上a的值并没有超出short的范围，理论上是可以直接给到b存放的，此时我们就可以使用强制类型转换：\npublic static void main(String[] args) { int a = 10; short b = (short) a; //在括号中填写上强制转换的类型，就可以强制转换到对应的类型了 } 只不过强制类型转换存在一定的风险，比如：\npublic static void main(String[] args) { int a = 128; //已经超出byte的范围了 byte b = (byte) a; //此时强制类型转换为byte类型，那么只会保留byte能够表示的bit位 System.out.println(b); } 比如这里的128：\n00000000 00000000 00000000 10000000 -\u0026gt; byte只有一个字节，所以说只保留最后8位 -\u0026gt; 10000000 这里的10000000，由于第一个位置是符号位，导致此时直接变成了byte的最小值：\n所以说强制类型转换只有在明确不会出现问题的情况下，才可以使用。当然，强制类型转换也可以用在后面的类中，我们将会在下一章继续探讨。\n有了强制类型转换，我们就可以很轻松地让两个整数计算出小数的结果了：\npublic static void main(String[] args) { int a = 8, b = 5; double c = a/(double)b; //强制类型转换的优先级跟正负号一样 //计算时，只需要将其中一者转换为double类型，此时按照隐式类型转换规则，全都会变成double参与运算，所以结果也就是小数了 System.out.println(c); } 各位思考一下下面的这种情况可以正确得到小数的结果吗？\npublic static void main(String[] args) { int a = 8, b = 5; double c = (double) (a/b); System.out.println(c); } 不能得到，因为括号将a/b的运算优先进行了，此时得到的结果已经是一个整数结果，再转换为double毫无意义。\n最后我们还是来总结一下目前遇到的所有运算符：\n优先级 运算符 结合性 1 ( ) 从左向右 2 - + (强制类型转换) 从右向左 3 * / % 从左向右 4 +(加法，包括字符串) -(减法) 从左向右 5 = 从右向左 自增自减运算符 **注意：**这一节很容易搞晕，请务必记清楚顺序！\n有时候我们可能需要让变量自己进行增加操作，比如我们现在想要进行跳绳计数，每转动一圈，计数+1，当我们想要对一个变量进行这样的自增操作时，可以：\npublic static void main(String[] args) { int a = 8; a = a + 1; //让a等于a本身+1，相当于自增了1 System.out.println(a); //得到9 } 当然，除了这种方式，我们也可以使用自增自减运算符：\npublic static void main(String[] args) { int a = 8; a++; //自增运算符就是两个加号连在一起，效果跟上面是一样的，a都会自增1 a--; //自减不用我多说了吧 System.out.println(a); } 自增自减运算符可以放到操作数的前后：\npublic static void main(String[] args) { int a = 8; ++a; //自增运算符在前在后最终效果都是让a自增1，是一样的 System.out.println(a); } 自增自减操作同样是有结果的，注意，这两种方式自增操作的结果不一样，我们来看下面的例子：\npublic static void main(String[] args) { int a = 8; int b = a++; //先出结果，再自增 System.out.println(b); //b得到的是a自增前的值 } public static void main(String[] args) { int a = 8; int b = ++a; //先自增，再出结果 System.out.println(b); //b得到的是a自增之后的结果 } 第一个结果为8，而第二个结果却是9，这是因为，自增运算符放在前面，是先自增再得到结果，而自增运算符放到后面，是先出结果再自增（自减同理），这个新手很容易记混，所以说一定要分清楚。\n自增自减运算符的优先级与正负号等价比如：\npublic static void main(String[] args) { int a = 8; int b = -a++ + ++a; //我们首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++ //a++的结果还是8，然后是负号，得到-8 //接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10 //最后得到的结果为 -8 + 10 = 2 System.out.println(b); } 一般情况下，除了考试为了考察各位小伙伴对运算符的优先级和结合性的理解，会出现这种恶心人的写法之外，各位小伙伴尽量不要去写这种难以阅读的东西。\n当然，有些时候我们并不是希望以1进行自增，可能希望以其他的数进行自增操作，除了按照之前的方式老老实实写之外：\npublic static void main(String[] args) { int a = 8; a = a + 4; System.out.println(a); } 我们可以将其缩写：\npublic static void main(String[] args) { int a = 8; a += 4; //加号和等号连在一起，与a = a + 4效果完全一样 System.out.println(a); } 并且结果也是操作之后的结果：\npublic static void main(String[] args) { int a = 8; int b = a += 4; //+=的运算结果就是自增之后的结果 System.out.println(b); //所以b就是12 } 不止加法，包括我们前面介绍的全部算术运算符，都是支持这种缩写的：\npublic static void main(String[] args) { int a = 8; a *= 9; //跟 a = a * 9 等价 System.out.println(a); //得到72 } 是不是感觉能够编写更简洁的代码了？\n优先级 运算符 结合性 1 ( ) 从左向右 2 - + (强制类型转换) ++ \u0026ndash; 从右向左 3 * / % 从左向右 4 +(加法，包括字符串) -(减法) 从左向右 5 = += -= *= /= %= 从右向左 位运算符 我们接着来看位运算符，它比较偏向于底层，但是只要各位小伙伴前面的计算机二进制表示听明白了，这里就不是问题。\n我们可以使用位运算符直接以二进制形式操作目标，位运算符包括：\u0026amp; | ^ ~\n我们先来看按位与\u0026amp;，比如下面的两个数：\npublic static void main(String[] args) { int a = 9, b = 3; int c = a \u0026amp; b; //进行按位与运算 System.out.println(c); } 按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0：\na = 9 = 1001 b = 3 = 0011 c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0） 同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1：\npublic static void main(String[] args) { int a = 9, b = 3; int c = a | b; System.out.println(c); } a = 9 = 1001 b = 3 = 0011 c =11= 1011（只要上下有一个是1或者都是1，那结果就是1） 按位异或符号很多小伙伴会以为是乘方运算，但是Java中并没有乘方运算符，^是按位异或运算符，不要记错了。\npublic static void main(String[] args) { int a = 9, b = 3; int c = a ^ b; System.out.println(c); } 异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：\na = 9 = 1001 b = 3 = 0011 c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0） 按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1：\npublic static void main(String[] args) { byte c = ~127; System.out.println(c); } 127 = 01111111 -128 = 10000000 所以说计算的结果就是-128了。\n除了以上的四个运算符之外，还有位移运算符，比如：\npublic static void main(String[] args) { byte c = 1 \u0026lt;\u0026lt; 2; //两个连续的小于符号，表示左移运算 System.out.println(c); } 1 = 00000001 4 = 00000100（左移两位之后，1跑到前面去了，尾部使用0填充，此时就是4） 我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用*进行乘2的运算之外，我们也可以使用左移操作来完成。\n同样的，右移操作就是向右移动每一位咯：\npublic static void main(String[] args) { byte c = 8 \u0026gt;\u0026gt; 2; System.out.println(c); } 8 = 00001000 2 = 00000010（右移两位之后，1跑到后面去了，头部使用符号位数字填充，此时变成2） 跟上面一样，右移操作可以快速进行除以2的计算。\n对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响：\npublic static void main(String[] args) { byte c = -4 \u0026gt;\u0026gt; 1; System.out.println(c); } -4 = 11111100 -2 = 11111110（前面这一长串1都被推到后面一位了，因为是负数，头部需要使用符号位数字来进行填充） 我们来总结一下：\n**左移操作\u0026laquo;：**高位直接丢弃，低位补0 **右移操作\u0026raquo;：**低位直接丢弃，符号位是什么高位补什么 我们也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动：\npublic static void main(String[] args) { int c = -1 \u0026gt;\u0026gt; 1; //正常的右移操作，高位补1，所以说移了还是-1 System.out.println(c); } public static void main(String[] args) { int c = -1 \u0026gt;\u0026gt;\u0026gt; 1; //无符号右移是三个大于符号连在一起，移动会直接考虑符号位 System.out.println(c); } 比如：\n-1 = 11111111 11111111 11111111 11111111 右移： 01111111 11111111 11111111 11111111（无符号右移使用0填充高位） 此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移。\n位移操作也可以缩写：\npublic static void main(String[] args) { int c = -1; c = c \u0026lt;\u0026lt; 2; System.out.println(c); } 可以缩写为：\npublic static void main(String[] args) { int c = -1; c \u0026lt;\u0026lt;= 2; //直接运算符连上等号即可，跟上面是一样的 System.out.println(c); } 最后我们还是来总结一下优先级：\n优先级 运算符 结合性 1 ( ) 从左向右 2 ~ - + (强制类型转换) ++ \u0026ndash; 从右向左 3 * / % 从左向右 4 + - 从左向右 5 \u0026laquo; \u0026raquo; \u0026raquo;\u0026gt; 从左向右 6 \u0026amp; 从左向右 7 ^ 从左向右 8 | 从左向右 9 = += -= *= /= %= \u0026amp;= |= ^= \u0026laquo;= \u0026raquo;= \u0026raquo;\u0026gt;= 从右向左 关系运算符 到目前为止，我们发现有一个基本数据类型很低调，在前面的计算中boolean类型一直都没有机会出场，而接下来就是它的主场。\n我们可以对某些事物进行判断，比如我们想判断两个变量谁更大，我们可以使用关系运算符：\npublic static void main(String[] args) { int a = 10, b = 20; boolean c = a \u0026gt; b; //进行判断，如果a \u0026gt; b那么就会得到true，否则会得到false } 关系判断的结果只可能是真或是假，所以说得到的结果是一个boolean类型的值。\n关系判断运算符包括：\n\u0026gt; 大于 \u0026lt; 小于 == 等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了） != 不等于 \u0026gt;= 大于等于 \u0026lt;= 小于等于 关系运算符的计算还是比较简单的。\n逻辑运算符 前面我们介绍了简单的关系运算符，我们可以通过对关系的判断得到真或是假的结果，但是只能进行简单的判断，如果此时我们想要判断a是否小于等于100且大于等于60，就没办法了：\n注意不能像这样进行判断，这是错误的语法，同时只能使用其中一种关系判断运算符。\n为了解决这种问题，我们可以使用逻辑运算符，逻辑运算符包括：\n\u0026amp;\u0026amp; 与运算，要求两边同时为true才能返回true || 或运算，要求两边至少要有一个为true才能返回true ! 非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转 现在，我们就可以使用逻辑运算符进行复杂条件判断：\npublic static void main(String[] args) { int a = 10; boolean b = 100 \u0026gt;= a \u0026amp;\u0026amp; a \u0026gt;= 60; //我们可以使用与运算符连接两个判断表达式 } 与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假，上面的判断虽然满足第一个判断表达式，但是不满足第二个，所以说得到的结果就是false。\n我们再来看下面的这个例子：\npublic static void main(String[] args) { int a = 150; boolean b = 100 \u0026gt;= a \u0026amp;\u0026amp; a \u0026gt;= 60; //此时上来就不满足条件 } 这个例子中，第一个判断表达式就得到了false，此时不会再继续运行第二个表达式，而是直接得到结果false（逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点）\n同样的，比如我们现在要判断a要么大于10，要么小于0，这种关系就是一个或的关系：\npublic static void main(String[] args) { int a = 150; boolean b = a \u0026lt; 0 || a \u0026gt; 10; //或运算要求两边只要有至少一边满足，结果就为true，如果都不满足，那么就是false } 或运算同样会出现短路的情况，比如下面的例子：\npublic static void main(String[] args) { int a = -9; boolean b = a \u0026lt; 0 || a \u0026gt; 10; //此时上来就满足条件 } 因为第一个判断表达式就直接得到了true，那么第二个表达式无论是真还是假，结果都一定是true，所以说没必要继续向后进行判断了，直接得到结果true。\n我们来看看下面的结果是什么：\npublic static void main(String[] args) { int a = 10; boolean b = a++ \u0026gt; 10 \u0026amp;\u0026amp; ++a == 12; System.out.println(\u0026#34;a = \u0026#34;+a + \u0026#34;, b = \u0026#34;+b); } 得到结果为：\n这是为什么呢？很明显我们的判断中a进行了两次自增操作，但是最后a的结果却是11，这是因为第一个表达式判断的结果为false，由于此时进行的是与运算，所以说直接短路，不会再继续判断了，因此第二个表达式就不会执行。\n当然，除了与运算和或运算，还有一个非运算，这个就比较简单了，它可以将结果变成相反的样子，比如：\npublic static void main(String[] args) { int a = 10; boolean b = !(a \u0026gt; 5); //对a\u0026gt;5的判断结果，进行非运算 } 因为上面的a \u0026gt; 5判断为真，此时进行非运算会得到相反的结果，所以说最后b就是false了。\n最后我们还需要介绍一个叫做三元运算符的东西，三元运算符可以根据判断条件，返回不同的结果，比如我们想要判断：\n当a \u0026gt; 10时，给b赋值\u0026rsquo;A' 当a \u0026lt;= 10时，给b赋值\u0026rsquo;B' 我们就可以使用三元运算符来完成：\npublic static void main(String[] args) { int a = 10; char b = a \u0026gt; 10 ? \u0026#39;A\u0026#39; : \u0026#39;B\u0026#39;; //三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值 System.out.println(b); } 三元运算符：\n判断语句 ? 结果1 : 结果2 因此，上面的判断为假，所以说返回的是结果2，那么最后b得到的就是B这个字符了。\n最后，我们来总结整个运算符板块学习到的所有运算符：\n优先级 运算符 结合性 1 ( ) 从左向右 2 ~ - + (强制类型转换) ++ \u0026ndash; 从右向左 3 * / % 从左向右 4 + - 从左向右 5 \u0026laquo; \u0026raquo; \u0026raquo;\u0026gt; 从左向右 6 \u0026gt; \u0026lt; \u0026gt;= \u0026gt;= 从左向右 7 == != 从左向右 8 \u0026amp; 从左向右 9 ^ 从左向右 10 | 从左向右 11 \u0026amp;\u0026amp; 从左向右 12 || 从左向右 13 ? : 从右向左 14 = += -= *= /= %= \u0026amp;= |= ^= \u0026laquo;= \u0026raquo;= \u0026raquo;\u0026gt;= 从右向左 至此，我们已经学习了Java基础部分中所有的运算符。\n流程控制 我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！\n在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断。\n代码块与作用域 在开始流程控制语句之前，我们先来介绍一下代码块和作用域。\n不知道各位小伙伴是否在一开始就注意到了，为什么程序中会有一些成对出现的花括号？这些花括号代表什么意思呢？\npublic class Main { //外层花括号 public static void main(String[] args) { //内层花括号开始 } //内层花括号结束 } 我们可以在花括号中编写一句又一句的代码，实际上这些被大括号囊括起来的内容，我们就称为块（代码块），一个代码块中可以包含多行代码，我们可以在里面做各种各样的事情，比如定义变量、进行计算等等。\n我们可以自由地创建代码块：\npublic static void main(String[] args) { //现目前这个阶段，我们还是在主方法中编写代码，不要跑去外面写 System.out.println(\u0026#34;外层\u0026#34;); { //自由创建代码块 int a = 10; System.out.println(a); } } 虽然创建了代码块，但实际上程序依然是按照从上到下的顺序在进行的，所以说这里还是在逐行运行，即使使用花括号囊括。那咋一看这不就是没什么卵用吗？我们来看看变量。\n我们创建的变量，实际上是有作用域的，并不是在任何地方都可以使用，比如：\n变量的使用范围，仅限于其定义时所处的代码块，一旦超出对应的代码块区域，那么就相当于没有这个变量了。\npublic static void main(String[] args) { int a = 10; //此时变量在最外层定义 { System.out.println(a); //处于其作用域内部的代码块可以使用 } System.out.println(a); //这里肯定也可以使用 } 我们目前所创建的变量都是局部变量（有范围限制），后面我们会介绍更多种类型的变量，了解了代码块及作用域之后，我们就可以正式开启流程控制语句的学习了。\n选择结构 某些时候，我们希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先我们来认识一下if语句：\nif (条件判断) 判断成功执行的代码; public static void main(String[] args) { int a = 15; if(a == 15) //只有当a判断等于15时，才会执行下面的打印语句 System.out.println(\u0026#34;Hello World!\u0026#34;); System.out.println(\u0026#34;我是外层\u0026#34;); //if只会对紧跟着的一行代码生效，后续的内容无效 } if会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的。\npublic static void main(String[] args) { int a = 15; if(a \u0026gt; 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 System.out.println(\u0026#34;a大于10\u0026#34;); System.out.println(\u0026#34;a的值为：\u0026#34;+a); } System.out.println(\u0026#34;我是外层\u0026#34;); } 如果我们希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加else语句：\npublic static void main(String[] args) { int a = 15; if(a \u0026gt; 10) { //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过 System.out.println(\u0026#34;a大于10\u0026#34;); System.out.println(\u0026#34;a的值为：\u0026#34;+a); } else { //当判断不成功时，会执行else代码块中的代码 System.out.println(\u0026#34;a小于10\u0026#34;); System.out.println(\u0026#34;a的值为：\u0026#34;+a); } System.out.println(\u0026#34;我是外层\u0026#34;); } if-else语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。\n那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用else-if来完成：\npublic static void main(String[] args) { int score = 2; if(score \u0026gt;= 90) //90分以上才是优秀 System.out.println(\u0026#34;优秀\u0026#34;); else if (score \u0026gt;= 70) //当上一级if判断失败时，会继续判断这一级 System.out.println(\u0026#34;良好\u0026#34;); else if (score \u0026gt;= 60) System.out.println(\u0026#34;及格\u0026#34;); else //当之前所有的if都判断失败时，才会进入到最后的else语句中 System.out.println(\u0026#34;不及格\u0026#34;); } 当然，if分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：\npublic static void main(String[] args) { int score = 2; if(score \u0026lt; 60) { //先判断不及格 if(score \u0026gt; 30) //在内层再嵌套一个if语句进行进一步的判断 System.out.println(\u0026#34;学习C++\u0026#34;); else System.out.println(\u0026#34;学习Java\u0026#34;); } } 除了if自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，我们就可以灵活地使用if来进行各种条件判断了。\n前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用switch语句来实现，它更适用于多分支的情况：\nswitch (目标) { //我们需要传入一个目标，比如变量，或是计算表达式等 case 匹配值: //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码 代码... break; //代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码 } 比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：\npublic static void main(String[] args) { char c = \u0026#39;A\u0026#39;; switch (c) { //这里目标就是变量c case \u0026#39;A\u0026#39;: //分别指定ABC三个匹配值，并且执行不同的代码 System.out.println(\u0026#34;去尖子班！准备冲刺985大学！\u0026#34;); break; //执行完之后一定记得break，否则会继续向下执行下一个case中的代码 case \u0026#39;B\u0026#39;: System.out.println(\u0026#34;去平行班！准备冲刺一本！\u0026#34;); break; case \u0026#39;C\u0026#39;: System.out.println(\u0026#34;去职高深造。\u0026#34;); break; } } switch可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。\n当然除了精准匹配之外，其他的情况我们可以用default来表示：\nswitch (目标) { case: ... default: 其他情况下执行的代码 } 我们还是以刚才那个例子为例：\npublic static void main(String[] args) { char c = \u0026#39;A\u0026#39;; switch (c) { case \u0026#39;A\u0026#39;: System.out.println(\u0026#34;去尖子班！\u0026#34;); break; case \u0026#39;B\u0026#39;: System.out.println(\u0026#34;去平行班！\u0026#34;); break; case \u0026#39;C\u0026#39;: System.out.println(\u0026#34;去差生班！\u0026#34;); break; default: //其他情况一律就是下面的代码了 System.out.println(\u0026#34;去读职高，分流\u0026#34;); } } 当然switch中可以继续嵌套其他的流程控制语句，比如if：\npublic static void main(String[] args) { char c = \u0026#39;A\u0026#39;; switch (c) { case \u0026#39;A\u0026#39;: if(c == \u0026#39;A\u0026#39;) { //嵌套一个if语句 System.out.println(\u0026#34;去尖子班！\u0026#34;); } break; case \u0026#39;B\u0026#39;: System.out.println(\u0026#34;去平行班！\u0026#34;); break; } } 目前，我们已经认识了两种选择分支结构语句。\n循环结构 通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句：循环语句。\n我们在某些时候，可能需要批量执行某些代码：\npublic static void main(String[] args) { System.out.println(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); //把这句话给我打印三遍 System.out.println(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); System.out.println(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); } 遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么我们岂不是光CV代码就要搞一下午？\n现在，要解决这种问题，我们可以使用for循环语句来多次执行：\nfor (表达式1;表达式2;表达式3) 循环体; 介绍一下详细规则：\n表达式1：在循环开始时仅执行一次。 表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。 表达式3：每次循环完成后会执行一次。 循环体：每次循环都会执行一次循环体。 一个标准的for循环语句写法如下：\npublic static void main(String[] args) { //比如我们希望让刚刚的打印执行3次 for (int i = 0; i \u0026lt; 3; i++) //这里我们在for语句中定义一个变量i，然后每一轮i都会自增，直到变成3为止 System.out.println(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); //这样，就会执行三轮循环，每轮循环都会执行紧跟着的这一句打印 } 我们可以使用调试来观察每一轮的变化，调试模式跟普通的运行一样，也会执行我们的Java程序，但是我们可以添加断点，也就是说当代码运行到断点位置时，会在这里暂停，我们可以观察当代码执行到这个位置时各个变量的值：\n调试模式在我们后面的学习中非常重要，影响深远，所以说各位小伙伴一定要学会。调试也很简单，我们只需要点击右上角的调试选项即可（图标像一个小虫子一样，因为调试的英文名称是Debug）\n调试开始时，我们可以看到程序在断点位置暂停了：\n此时我们可以观察到当前的局部变量i的值，也可以直接在下方的调试窗口中查看：\n随着循环的进行，i的值也会逐渐自增：\n当i增长到2时，此时来到最后一轮循环，再继续向下运行，就不再满足循环条件了，所以说此时就会结束循环。\n当然，如果要执行多条语句的话，只需要使用花括号囊括就行了：\nfor (int i = 0; i \u0026lt; 3; i++) { System.out.println(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); System.out.println(\u0026#34;当前i的值为：\u0026#34;+i); } 注意这里的i仅仅是for循环语句中创建的变量，所以说其作用域被限制在了循环体中，一旦离开循环体，那么就无法使用了：\n但是我们可以将i的创建放到外面：\npublic static void main(String[] args) { int i = 0; //在外面创建变量i，这样全部范围内都可以使用了 for (; i \u0026lt; 3; i++) { //for循环的三个表达式并不一定需要编写 System.out.println(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); System.out.println(\u0026#34;当前i的值为：\u0026#34;+i); } System.out.println(\u0026#34;当前i的值为：\u0026#34;+i); } 和之前的if一样，for循环同样支持嵌套使用：\npublic static void main(String[] args) { for (int i = 0; i \u0026lt; 3; i++) //外层循环执行3次 for (int j = 0; j \u0026lt; 3; j++) //内层循环也执行3次 System.out.println(\u0026#34;1！5！\u0026#34;); } 上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。\n实际上，for循环的三个表达式并不一定需要编写，我们甚至可以三个都不写：\npublic static void main(String[] args) { for (;;) //如果什么都不写，相当于没有结束条件，这将会导致无限循环 System.out.println(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); } 如果没有表达式2，那么整个for循环就没有结束条件，默认会判定为真，此时就会出现无限循环的情况（无限循环是很危险的，因为它会疯狂地消耗CPU资源来执行循环，可能很快你的CPU就满载了，一定要避免）\n当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：\npublic static void main(String[] args) { for (int i = 0; i \u0026lt; 3; i++) { if(i == 1) continue; //比如我们希望当i等于1时跳过这一轮，不执行后面的打印 System.out.println(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); System.out.println(\u0026#34;当前i的值为：\u0026#34;+i); } } 我们可以使用continue关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行continue进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。\n在某些情况下，我们可能希望提前结束循环：\nfor (int i = 0; i \u0026lt; 3; i++) { if(i == 1) break; //我们希望当i等于1时提前结束 System.out.println(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); System.out.println(\u0026#34;当前i的值为：\u0026#34;+i); } 我们可以使用break关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。\n虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：\nfor (int i = 1; i \u0026lt; 4; ++i) { for (int j = 1; j \u0026lt; 4; ++j) { if(i == j) continue; //当i == j时加速循环 System.out.println(i+\u0026#34;, \u0026#34;+j); } } 这里的continue加速的对象并不是外层的for，而是离它最近的内层for循环，break也是同样的规则：\nfor (int i = 1; i \u0026lt; 4; ++i) { for (int j = 1; j \u0026lt; 4; ++j) { if(i == j) break; //当i == j时终止循环 System.out.println(i+\u0026#34;, \u0026#34;+j); } } 那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记：\nouter: for (int i = 1; i \u0026lt; 4; ++i) { //在循环语句前，添加 标签: 来进行标记 inner: for (int j = 1; j \u0026lt; 4; ++j) { if(i == j) break outer; //break后紧跟要结束的循环标记，当i == j时终止外层循环 System.out.println(i+\u0026#34;, \u0026#34;+j); } } 如果一个代码块中存在多个循环，那么直接对当前代码块的标记执行break时会直接跳出整个代码块：\nouter: { //直接对整个代码块打标签 for (int i = 0; i \u0026lt; 10; i++) { if (i == 7){ System.out.println(\u0026#34;Test\u0026#34;); break outer; //执行break时，会直接跳出整个代码块，而不是第一个循环 } } System.out.println(\u0026#34;？？？\u0026#34;); } 虽然效果挺奇特的，但是一般情况下没人这么玩，所以说了解就行了。\n前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：\nwhile(循环条件) 循环体; 相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当i大于10时需要结束循环，但是i在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。\npublic static void main(String[] args) { int i = 100; //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 while (i \u0026gt; 0) { //现在唯一知道的是循环条件，只要大于0那么就可以继续除 System.out.println(i); i /= 2; //每次循环都除以2 } } 上面的这种情况就非常适合使用while循环。\n和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用：\npublic static void main(String[] args) { int i = 100; while (i \u0026gt; 0) { if(i \u0026lt; 10) break; System.out.println(i); i /= 2; } } 我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到do-while语句：\npublic static void main(String[] args) { int i = 0; //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 do { //无论满不满足循环条件，先执行循环体里面的内容 System.out.println(\u0026#34;Hello World!\u0026#34;); i++; } while (i \u0026lt; 10); //再做判断，如果判断成功，开启下一轮循环，否则结束 } 至此，面向过程相关的内容就讲解完毕了，从下一章开始，我们将进入面向对象编程的学习（类、数组、字符串）\n实战练习 面向过程的内容全部学习完成，我们来做几个练习题吧！\n寻找水仙花数 “水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指**一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。**例如：1^3 + 5^3+ 3^3 = 153。”\n现在请你设计一个Java程序，打印出所有1000以内的水仙花数。\n打印九九乘法表 现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个Java程序来实现它。\n斐波那契数列 斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：**1、1、2、3、5、8、13、21、34、……*在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。\n斐波那契数列：1，1，2，3，5，8，13，21，34，55，89\u0026hellip;，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个Java程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。\npublic static void main(String[] args) { int target = 7, result; //target是要获取的数，result是结果 //请在这里实现算法 System.out.println(result); } ","permalink":"https://blog.l50.top/posts/javase%E7%AC%94%E8%AE%B0%E4%BA%8C%E9%87%8D%E5%88%B6%E7%89%88/","summary":"面向过程篇 前面我们已经认识了Java语言的相关特性，并且已经成功配置好了开发环境，从这节课开始，我们就可以正式进入到Java语言的学习当中了。Java语言是一门面向对象的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。\nJava程序基础 首先我们还是从最基本的Java程序基础开始讲解。\n程序代码基本结构 还记得我们之前使用的示例代码吗？\npublic class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } 这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。\n由于我们还没有学习到类的相关性质，所以在第二章之前，各位小伙伴直接记住固定模式即可，首先我们创建的源文件名称需要为Main.java然后编写的代码第一行：\npublic class Main { } 注意需要区分大小写，Java语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错：\n只要源代码中存在报错的地方，就无法正常完成编译得到二进制文件，会提示构建失败：\n注意最后还有一个花括号，并且此花括号是成对出现的，一一对应。\n所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是：\npublic static void main(String[] args) { } 这是我们整个Java程序的入口点，我们称为主方法（如果你学习过C肯定能够联想到主函数，只不过Java中不叫函数，叫方法）最后也会有一个花括号成对出现，而在主方法的花括号中编写的代码，就是按照从上往下的顺序依次执行的。\n比如我们之前编写的：\nSystem.out.println(\u0026#34;Hello World!\u0026#34;); 这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上，可以看到最后还加上了一个;符号，表示这一句代码结束。我们每一段代码结束时都需要加上一个分号表示这一句的结束，就像我们写作文一样。\n比如下面的代码，我们就可以实现先打印Hello World!，然后再打印YYDS!到控制台。\npublic class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); System.out.println(\u0026#34;YYDS!\u0026#34;); } } 效果如下：\n如果两段代码没有加上分号分割，那么编译器会认为这两段代码是同一句代码中的，即使出现换行或者是空格：\n这里IDEA很聪明，会提醒我们这里少加了分号，所以说这个IDEA能够在初期尽可能地帮助新手。\n再比如下面的代码：\n这里我们尝试在中途换行和添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意进行换行编写或者是添加没必要的空格。\n同样的，如果添加了分号，即使在同一行，也会被认为是两句代码：","title":"JavaSE笔记（二）重制版"},{"content":" 新手入门篇 **注意：**开始学习JavaSE之前建议学习的前置课程《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》\n欢迎各位小伙伴来到JavaSE视频教程，期待与各位小伙伴共度这一旅程！视频中所有的文档、资料，都可以直接在视频下方简介中找到，视频非培训机构出品，纯个人录制，不需要加任何公众号、小程序，直接自取即可。\n教程开始之前，提醒各位小伙伴：\n如果你对某样东西不熟悉，请务必保证跟视频中使用一模一样的环境、一模一样的操作方式去使用，不要自作主张，否则出现某些奇怪的问题又不知道怎么办，就会浪费很多时间。 视频依然是基于Java 8进行讲解，不要自己去安装一个其他的版本，想要了解新版本特性可以在另一个视频里面观看。 在学习过程中，尽可能避免出现中文文件夹，包括后面的环境安装、项目创建，都尽量不要放在中文路径下（因为使用中文常常出现奇奇怪怪的问题）建议使用对应的英文单词代替，或者是用拼音都可以，最好只出现英文字母和数字。 本系列教程使用 IDEA社区版（免费）即可，不需要申请终极版。 如果觉得本视频对你有帮助，请一键三连支持一下UP主！\n计算机思维导论 计算机自1946年问世以来，几乎改变了整个世界。\n现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。各位可以看看最顶上的这张图片，如果你在小时候接触过计算机，那么一定对这张图片（照片拍摄于1996年，在美国加利福尼亚州加利福尼亚州的锁诺玛县）印象深刻，这张壁纸作为WindowsXP系统的默认壁纸，曾经展示在千家万户的电脑屏幕上。\n也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习C语言之前，先让我们来了解一下计算机的世界。\n计算机的世界 **注意：**如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。\n计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。\n这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。\n很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。\n用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的基本单元。\n计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。\n数字电路引入了逻辑判断，我们来看看简单的数字电路：\n数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。\n二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。\n比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）\n当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是与门、或门和非门，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了）\n比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用\u0026amp;表示）要求两个数参与进来，比如：\n1 \u0026amp; 1 = 1 必须两边都是真，结果才为真。\n1 \u0026amp; 0 = 0 两边任意一个或者都不是真，结果为假。\n或运算（用 | 表示）：\n1 | 0 = 1 两边只要有一个为真，结果就为真\n0 | 0 = 0 两边同时为假，结果才是假\n非运算实际上就是取反操作（可以是 ! 表示）\n!1 = 0\n!0 = 1 非运算会将真变成假，假变成真\n有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。\n前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。\n相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看：\n我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。\n当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone13 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G/6G/8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。\n计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。\n操作系统概述 **注意：**如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。\n前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。\n操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互操作的界面。\n一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。\n一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了：\n有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。\n不过操作系统最开始并不是图形化界面，它类似于Windows中的命令提示符：\n没有什么图标这些概念，只有一个简简单单的黑框让我们进行操作，通过输入命令来进行一些简单的使用，程序的运行结果也会在黑框框（命令行）中打印出来，不过虽然仅仅是一个黑框，但是能运行的程序可是非常非常多的，只需要运行我们编写好的程序，就能完成各种各样复杂的计算任务，并且计算机的计算速度远超我们的人脑。\n中国超级计算机系统天河二号，计算速度达到每秒5.49亿亿次。\n当然，除了我们常见的Windows和MacOS系统之外，还有我们以后需要经常打交道的Linux操作系统，这种操作系统是开源的，意思是所有的人都可以拿到源代码进行修改，于是就出现了很多发行版：\n这些发行版有带图形化界面的，也有不带图形化界面的，不带图形化界面的Linux将是我们以后学习的重点。\n不同操作系统之间的软件并不是通用的，比如Windows下我们的软件一般是.exe后缀名称，而MacOS下则不是，并且也无法直接运行.exe文件，这是因为不同操作系统的具体实现会存在一些不同，程序编译（我们之后会介绍到）之后的格式也会不同，所以是无法做到软件通用的。\n正是因为有了操作系统，才能够组织我们计算机的底层硬件（包括CPU、内存、输入输出设备等）进行有序工作，没有操作系统电脑就如同一堆废铁，只有躯壳没有灵魂。\n计算机编程语言 **注意：**如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。\n现在我们大致了解了我们的电脑的运作原理，实际上是一套完整的硬件+一个成形的操作系统共同存在的。接着我们就可以开始了解一下计算机的编程语言了。我们前面介绍的操作系统也是由编程语言写出来的，操作系统本身也算是一个软件。\n那么操作系统是如何让底层硬件进行工作的呢？实际上就是通过向CPU发送指令来完成的。\n计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。\n我们电脑中的CPU有多种多样的，不同的CPU之间可能也会存在不同的架构，比如现在最常用的是x86架构，还有我们手机平板这样的移动设备使用的arm架构，不同的架构指令集也会有不同。\n我们知道，计算机底层硬件都是采用的0和1这样的二进制表示，所以指令也是一样的，比如（这里随便写的）：\n000001 - 代表开机\n000010 - 代表关机\n000011 - 代表进行加法运算\n当我们通过电路发送给CPU这样的二进制指令，CPU就能够根据我们的指令执行对应的任务，而我们编写的程序保存在硬盘中也是这样的二进制形式，我们只需要将这些指令组织好，按照我们的思路一条一条执行对应的命令，就能够让计算机计算任何我们需要的内容了，这其实就是机器语言。\n不过随着时代的进步，指令集越来越大，CPU支持的运算类型也越来越多，这样的纯二进制编写实在是太累了，并且越来越多的命令我们根本记不住，于是就有了汇编语言。汇编语言将这些二进制的操作码通过助记符来替换：\nMOV 传送字或字节。\nMOVSX 先符号扩展,再传送。\nMOVZX 先零扩展,再传送。\nPUSH 把字压入堆栈。\n把这些原有的二进制命令通过一个单词来代替，这样是不是就好记多了，在程序编写完成后，我们只需要最后将这些单词转换回二进制指令就可以了，这也是早期出现的低级编程语言。\n不过虽然通过这些助记符就能够很轻松地记住命令，但是还是不够方便，因为可能我们的程序需要完成一个很庞大的任务，但是如果还是这样一条一条指令进行编写，是不是太慢了点，有时候可能做一个简单的计算，都需要好几条指令来完成。于是，高级编程语言——C语言，终于诞生了。\nC语言诞生于美国的贝尔实验室，由丹尼斯·里奇（Dennis MacAlistair Ritchie）以肯尼斯·蓝·汤普森（Kenneth Lane Thompson）设计的B语言为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX操作系统，且随着UNIX操作系统的发展，C语言也得到了不断的完善。\n高级语言不同于低级语言，低级语言的主要操作对象是指令本身，而高级语言却更加符合我们人脑的认知，更像是通过我们人的思维，去告诉计算机你需要做什么，包括语法也会更加的简单易懂。下面是一段简单的C语言代码：\nint main() { int a = 10; //定义一个a等于10 int b = 10; //定义一个b等于10 int c = a + b; //语义非常明确，c就是a加上b计算出来的结果。 return 0; } 不过现在看不懂没关系，我们后面慢慢学。\nC语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。\n当然，除了C语言之外，还有很多其他的高级语言，比如Java、Python、C#、PHP等等，相比其他编程语言，C算是比较古老的一种了，但是时隔多年直至今日，其他编程语言也依然无法撼动它的王者地位：\n可以看到在2021年9月，依然排在编程语言排行榜的第一名（Python和Java紧随其后），可见这门语言是多么的不可撼动，很多操作系统、高级编程语言底层实现，几乎都是依靠C语言去编写的（包括Java的底层也是C/C++实现的）所以学习这一门语言，对于理工科尤其是计算机专业极为重要，学好C语言你甚至可以融汇贯通到其他语言，学起来也会轻松很多。\n走进Java语言 前面我们介绍了C语言，它实际上就是通过编译，将我们可以看懂的代码，翻译为计算机能够直接执行的指令，这样计算机就可以按照我们想要的方式去进行计算了。当然，除了C语言之外，也有其他的语言，比如近几年也很火的Python，它跟C语言不同，它并不会先进行编译，而是直接交给解释器解释执行：\nprint(\u0026#34;Hello World!\u0026#34;) 可见，这种方式也可以让计算机按照我们的想法去进行工作。\n一般来说，编程语言就分为两大类：\n**编译型语言：**需要先编译为计算机可以直接执行的命令才可以运行。优点是计算机直接运行，性能高；缺点是与平台密切相关，在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如Windows下的exe程序在Mac上就无法运行。 **解释型语言：**只需要通过解释器代为执行即可，不需要进行编译。优点是可以跨平台，因为解释是解释器的事情，只需要在各个平台上安装对应的解释器，代码不需要任何修改就可以直接运行；缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。 那么我们来看看我们今天要介绍的主角，Java语言（Java之父：James Gosling，詹姆斯·高斯林）\nWrite Once, Run Anywhere.\n这是Java语言的标语，它的目标很明确：一次编写，到处运行，它旨在打破平台的限制，让Java语言可以运行在任何平台上，并且不需要重新编译，实现跨平台运行。\nJava自1995年正式推出以来，已经度过了快28个春秋，而基于Java语言，我们的生活中也有了各种各样的应用：\n诺基亚手机上的很多游戏都是使用Java编写的。 安卓系统中的各种应用程序也是使用Java编写的。 著名沙盒游戏《Minecraft》也有对应的Java版本，得益于Java跨平台特性，无论在什么操作系统上都可以玩到这款游戏。 \u0026hellip; （有关Java的详细发展历程，可以参考《Java核心技术·卷I》第一章）\n可见，Java实际上早已在我们生活中的各个地方扎根。那么，Java语言是什么样的一个运行机制呢？\n实际上我们的Java程序也是需要进行编译才可以运行的，这一点与C语言是一样的，Java程序编译之后会变成.class结尾的二进制文件：\n不过不同的是，这种二进制文件计算机并不能直接运行，而是需要交给JVM（Java虚拟机）执行。\nJVM是个什么东西呢？简单来说，它就像我们前面介绍的解释器一样，我们可以将编译完成的.class文件直接交给JVM去运行，而程序中要做的事情，也都是由它来告诉计算机该如何去执行。\n在不同的操作系统下，都有着对应的JVM实现，我们只需要安装好就可以了，而我们程序员只需要将Java程序编译为.class文件就可以直接交给JVM运行，无论是什么操作系统，JVM都采用的同一套标准读取和执行.class文件，所以说我们编译之后，在任何平台都可以运行，实现跨平台。\n由于Java又需要编译同时还需要依靠JVM解释执行，所以说Java既是编译型语言，也是解释型语言。\nJava分为很多个版本：\n**JavaSE：**是我们本教程的主要学习目标，它是标准版的Java，也是整个Java的最核心内容，在开始后续课程之前，这是我们不得不越过的一道坎，这个阶段一定要认真扎实地将Java学好，不然到了后面的高级部分，会很头疼。 **JavaME：**微缩版Java，已经基本没人用了。 **JavaEE：**企业级Java，比如网站开发，它是JavaSE阶段之后的主要学习方向。 从下节课开始，我们就正式地进行Java环境的安装和IDE的使用学习。\n环境安装与IDE使用 前面我们介绍了Java语言，以及其本身的一些性质，这一部分我们就开始进行学习环境安装（这一部分请务必跟着操作，不要自作主张地去操作，一开始就出问题其实是最劝退新手的）\nJDK下载与安装 首先我们来介绍一下JDK和JRE，各位小伙伴一定要能够区分这两者才可以。\nJRE（Java Runtime Environment）：Java的运行环境，安装了运行环境之后，Java程序才可以运行，一般不做开发，只是需要运行Java程序直接按照JRE即可。 JDK（Java Development Kit）：包含JRE，并且还附带了大量开发者工具，我们学习Java程序开发就使用JDK即可。 它们的关系如下：\n那么现在我们就去下载JDK吧，这里推荐安装免费的ZuluJDK：https://www.azul.com/downloads/?version=java-8-lts\u0026amp;package=jdk\n在这里选择自己的操作系统对应的安装包：\n比如Windows下，我们就选择.msi的安装包即可（MacOS、Linux下同样选择对应的即可）\n下载完成后，我们直接双击安装：\n**注意，这里不建议各位小伙伴去修改安装的位置！**新手只建议安装到默认位置（不要总担心C盘不够，该装的还是要装，尤其是这种环境，实在装不下就去将其他磁盘的空间分到C盘一部分）如果是因为没有安装到默认位置出现了任何问题，你要是找不到大佬问的话，又得重新来一遍，就很麻烦。\n剩下的我们只需要一路点击Next即可，安装完成之后，我们打开CMD命令窗口（MacOS下直接打开“终端”）来验证一下（要打开CMD命令窗口，Windows11可以直接在下面的搜索框搜索cmd即可，或者直接在文件资源管理器路径栏输入cmd也可以）\n我们直接输入java命令即可：\n如果能够直接输出内容，说明环境已经安装成功了，正常情况下已经配置好了，我们不需要手动去配置什么环境变量，所以说安装好就别管了。\n输入java -version可以查看当前安装的JDK版本：\n只要是1.8.0就没问题了，后面的小版本号可能你们会比我的还要新。\n这样我们就完成了Java环境的安装，我们可以来体验一下编写并且编译运行一个简单的Java程序，我们新建一个文本文档，命名为Main.txt（如果没有显示后缀名，需要在文件资源管理器中开启一下）然后用记事本打开，输入以下内容：\npublic class Main{ public static void main(String[] args){ System.out.println(\u0026#34;Hello World!\u0026#34;); } } 现在看不懂没关系，直接用就行，我们后面会一点一点讲解的。\n编辑好之后，保存退出，接着我们将文件的后缀名称修改为.java这是Java源程序文件的后缀名称：\n此时我们打开CMD，注意要先进入到对应的路径下，比如我们现在的路径：\n我们使用cd命令先进入到这个目录下：\n要编译一个Java程序，我们需要使用javac命令来进行：\n执行后，可以看到目录下多出来了一个.class文件：\n这样我们就成功编译了一个Java程序，然后我们就可以将其交给JVM运行了，我们直接使用java命令即可：\n注意不要加上后缀名称，直接输入文件名字即可，可以看到打印了一个 Hello World! 字样，我们的第一个Java程序就可以运行了。\nIDEA安装与使用 前面我们介绍了JDK开发环境的安装以及成功编译运行了我们的第一个Java程序。\n但是我们发现，如果我们以后都使用记事本来进行Java程序开发的话，是不是效率太低了点？我们还要先编辑，然后要改后缀，还要敲命令来编译，有没有更加方便一点的写代码的工具呢？这里我们要介绍的是：IntelliJ IDEA（这里不推荐各位小伙伴使用Eclipse，因为操作上没有IDEA这么友好）\nIDEA准确来说是一个集成开发环境（IDE），它集成了大量的开发工具，编写代码的错误检测、代码提示、一键完成编译运行等，非常方便。\n下载地址：IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE（如果你之前学习C语言程序设计篇使用过CLion，你会发现界面一模一样，这样就能方便你快速上手）\n我们直接点击下载即可：\n这个软件本身是付费的，比较贵，而且最近还涨价了，不过这里我们直接下载面的社区版本就行了（JavaSE学习阶段不需要终极版，但是建议有条件的还是申请一个，因为后面JavaWeb开始就需要终极版了，学生和教师可以直接免费申请一年的使用许可，并且每个学期都可以续一年）\n下载好之后，直接按照即可，这个不强制要求安装到C盘，自己随意，但是注意路径中不要出现中文！\n这里勾选一下创建桌面快捷方式就行：\n安装完成后，我们直接打开就可以了：\n此时界面是全英文，如果各位小伙伴看得惯，可以直接使用全英文的界面（使用英文界面可以认识更多的专业术语词汇，但是可能看起来没中文那么直观，而且IDEA本身功能就比较多，英语不好的小伙伴就很头疼）这里还是建议英语不好的小伙伴使用中文界面，要使用中文只需要安装中文插件即可：\n我们打开Plugins插件这一栏，然后直接在插件市场里面搜索Chinese，可以找到一个中文语言包的插件，我们直接Install安装即可，安装完成后点击重启，现在就是中文页面了：\n如果各位小伙伴不喜欢黑色主题，也可以修改为白色主题，只需要在自定义中进行修改即可，一共四种主题。\n如果你之前使用过其他IDE编写代码，这里还支持按键映射（采用其他IDE的快捷键方案）有需要的可以自己修改一下：\n接下来，我们来看看如何使用IDEA编写Java程序，IDEA是以项目的形式对一个Java程序进行管理的，所以说我们直接创建一个新的项目，点击新建项目：\n此时来到创建页面：\n**名称：**你的Java项目的名称，随便起就行，尽量只带英文字母和数字，不要出现特殊字符和中文。 **位置：**项目的存放位置，可以自己根据情况修改，同样的，路径中不要出现中文。 **语言：**IDEA支持编写其他语言的项目，但是这里我们直接选择Java就行了。 **构建系统：**在JavaSE阶段一律选择IntelliJ就行了，Maven我们会在JavaWeb之后进行讲解，Gradle会在安卓开发教程中介绍。 **JDK：**就是我们之前安装好的JDK，如果是默认路径安装，这里会自动识别（所以说不要随便去改，不然这些地方就很麻烦） 当然，如果JDK这里没有自动识别到，那么就手动添加一下：\n没问题之后，我们直接创建项目：\n进入之后，可以看到已经自动帮助我们创建好了一个java源文件，跟我们之前的例子是一样的。要编译运行我们的Java程序，只需要直接点击左边的三角形（启动按钮）即可：\n点击之后，会在下方自动开始构建：\n完成之后，就可以在控制台看到输出的内容了：\n我们可以看到新增加了一个out目录，这里面就是刚刚编译好的.class文件：\nIDEA非常强大，即使是编译之后的二进制文件，也可以反编译回原代码的样子：\n如果我们想写一个新的Java项目，可以退出当前项目重新创建：\n此时项目列表中就有我们刚刚创建的Java项目了：\n如果你还想探索IDEA的其他功能，可以点击欢迎页最下方的学习：\n会有一个专门的引导教程项目，来教你如何使用各项功能：\nIDEA新UI介绍和外观设置 IDEA在2022年开启了界面新UI的测试，并将在年底前实装，所以说我们将老UI界面改为新的UI界面进行介绍（如果已经是新UI的样式，那么就不需要像下面一样开启了）\n我们随便进入一个项目，然后双击Shift出现搜索框（这个搜索框很好用，什么都能搜）输入registry\n找到ide.experimental.ui，将其勾选上，然后重启IDEA就变成新的UI样式了（你不说这是IDEA我还以为是VS呢）\n这里介绍一下新UI的各个功能，首先是运行项目，依然是点击左侧三角形：\n在第一次运行后，会自动生成一个运行配置，我们也可以直接点击右上角的运行：\n效果是一样的，都可以编译运行Java项目。上面一排工具栏被丢到了一个菜单里面：\n如果各位小伙伴觉得代码字体太小了，可以在设置中进行调整：\nIDEA的所有通知都可以在通知中查看：\n我们来看右下角，第一个三角形图标是运行的结果：\n第二栏是终端（其实就是内嵌的一个CMD命令窗口）可以自由敲命令，默认是位于项目根目录下：\n至此，学习前准备就完成了，从下节课开始，我们将正式进入到Java语言的学习中。\n","permalink":"https://blog.l50.top/posts/javase%E7%AC%94%E8%AE%B0%E4%B8%80%E9%87%8D%E5%88%B6%E7%89%88/","summary":"新手入门篇 **注意：**开始学习JavaSE之前建议学习的前置课程《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》\n欢迎各位小伙伴来到JavaSE视频教程，期待与各位小伙伴共度这一旅程！视频中所有的文档、资料，都可以直接在视频下方简介中找到，视频非培训机构出品，纯个人录制，不需要加任何公众号、小程序，直接自取即可。\n教程开始之前，提醒各位小伙伴：\n如果你对某样东西不熟悉，请务必保证跟视频中使用一模一样的环境、一模一样的操作方式去使用，不要自作主张，否则出现某些奇怪的问题又不知道怎么办，就会浪费很多时间。 视频依然是基于Java 8进行讲解，不要自己去安装一个其他的版本，想要了解新版本特性可以在另一个视频里面观看。 在学习过程中，尽可能避免出现中文文件夹，包括后面的环境安装、项目创建，都尽量不要放在中文路径下（因为使用中文常常出现奇奇怪怪的问题）建议使用对应的英文单词代替，或者是用拼音都可以，最好只出现英文字母和数字。 本系列教程使用 IDEA社区版（免费）即可，不需要申请终极版。 如果觉得本视频对你有帮助，请一键三连支持一下UP主！\n计算机思维导论 计算机自1946年问世以来，几乎改变了整个世界。\n现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。各位可以看看最顶上的这张图片，如果你在小时候接触过计算机，那么一定对这张图片（照片拍摄于1996年，在美国加利福尼亚州加利福尼亚州的锁诺玛县）印象深刻，这张壁纸作为WindowsXP系统的默认壁纸，曾经展示在千家万户的电脑屏幕上。\n也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习C语言之前，先让我们来了解一下计算机的世界。\n计算机的世界 **注意：**如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。\n计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。\n这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。\n很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。\n用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的基本单元。\n计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。\n数字电路引入了逻辑判断，我们来看看简单的数字电路：\n数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。\n二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。\n比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）\n当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是与门、或门和非门，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了）\n比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用\u0026amp;表示）要求两个数参与进来，比如：\n1 \u0026amp; 1 = 1 必须两边都是真，结果才为真。\n1 \u0026amp; 0 = 0 两边任意一个或者都不是真，结果为假。\n或运算（用 | 表示）：\n1 | 0 = 1 两边只要有一个为真，结果就为真\n0 | 0 = 0 两边同时为假，结果才是假\n非运算实际上就是取反操作（可以是 ! 表示）\n!1 = 0\n!0 = 1 非运算会将真变成假，假变成真\n有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。\n前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。\n相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看：\n我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。","title":"JavaSE笔记（一）重制版"},{"content":" C语言高级特性 前面我们了解了C语言的相关基础内容，我们来看看C语言的高级部分。这一章的学习难道会比较大，尤其是指针板块，因为需要理解计算机内存模型，所以说是很多初学者的噩梦。\n函数 其实函数我们在一开始就在使用了：\nint main() { //这是定义函数 ... } 我们程序的入口点就是main函数，我们只需要将我们的程序代码编写到主函数中就可以运行了，不够这个函数只是由我们来定义，而不是我们自己来调用。当然，除了主函数之外，我们一直在使用的printf也是一个函数，不过这个函数是标准库中已经实现好了的，现在是我们在调用这个函数：\nprintf(\u0026#34;Hello World!\u0026#34;); //直接通过 函数名称(参数...) 的形式调用函数 那么，函数的具体定义是什么呢？\n函数是完成特定任务的独立程序代码单元。\n其实简单来说，函数时为了完成某件任务而生的，可能我们要完成某个任务并不是一行代码就可以搞定的，但是现在可能会遇到这种情况：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; printf(\u0026#34;H\u0026#34;); //比如下面这三行代码就是我们要做的任务 printf(\u0026#34;A\u0026#34;); a += 10; if(a \u0026gt; 20) { printf(\u0026#34;H\u0026#34;); //这里我们还需要执行这个任务 printf(\u0026#34;A\u0026#34;); a += 10; } switch (a) { case 30: printf(\u0026#34;H\u0026#34;); //这里又要执行这个任务 printf(\u0026#34;A\u0026#34;); a += 10; } } 我们每次要做这个任务时，都要完完整整地将任务的每一行代码都写下来，如果我们的程序中多处都需要执行这个任务，每个地方都完整地写一遍，实在是太臃肿了，有没有一种更好的办法能优化我们的代码呢？\n这时我们就可以考虑使用函数了，我们可以将我们的程序逻辑代码全部编写到函数中，当我们执行函数时，实际上执行的就是函数中的全部内容，也就是按照我们制定的规则执行对应的任务，每次需要做这个任务时，只需要调用函数即可。\n我们来看看，如何创建和使用函数。\n创建和使用函数 首先我们来看看如何创建一个函数，其实创建一个函数是很简单的，格式如下：\n返回值类型 函数名称([函数参数...]); 其中函数名称也是有要求的，并不是所有的字符都可以用作函数名称，它的命名规则与变量的命名规则基本一致，所以这里就不一一列出了。\n函数不仅仅需要完成我们的任务，可能某些函数还需要告诉我们结果，比如我们之前认识的getchar函数，这个函数实际上返回了一个int值作为结果（也就是我们输入的字符）我们同样可以将函数返回的结果赋值给变量或是参与运算等等。\n当然如果我们的函数只需要完成任务，不需要告诉我们结果，返回值类型可以写成void表示为空。\n函数参数我们放在下一个小节中讲解，所以这里我们不使用任何参数，所以这里也将参数设定为void表示没有参数（当然为了方便，我们也可以直接什么都不写）\n#include \u0026lt;stdio.h\u0026gt; void test(void); //定义函数原型，因为C语言是从上往下的，所以如果要在下面的主函数中使用这个函数，一定要定义到它的上面。 int main() { } void test(void){ //函数具体定义，添加一个花括号并在其中编写程序代码，就和我们之前在main中编写一样 printf(\u0026#34;我是测试函数!\u0026#34;); } 或是直接在上方写上函数的具体定义：\n#include \u0026lt;stdio.h\u0026gt; void test(void){ //函数具体定义，添加一个花括号并在其中编写程序代码，就和我们之前在main中编写一样 printf(\u0026#34;我是测试函数!\u0026#34;); } int main() { } 那么现在我们将函数定义好之后，该如何去使用呢？\nint main() { test(); //这里我们只需要使用 函数名称(); 就可以调用函数了 printf(\u0026#34;Hello World!\u0026#34;); //实际上printf也是一个函数，功能是向控制台打印字符串，只不过这个函数是系统提供的，已经提前实现好了，其中的参数我们后续还会进行介绍。 } 这样，我们就可以很好解决上面的代码复用性的问题，我们只需要将会重复使用的逻辑代码定义到函数中，当我们需要执行时，直接调用编写好的函数就可以了，这样是不是简单多了？\nint main() { int a = 10; test(); //多次使用的情况下，函数会让我们的程序简单很多 if(a \u0026gt; 20) test(); switch (a) { case 30: test(); } } 当然函数除了可以实现代码的复用之外，也可以优化我们的程序，让我们的代码写得更有层次感，我们的程序可能会有很多很多的功能，需要写很多的代码，但是谁愿意去看一个几百行上千行的main函数呢？我们可以将每个功能都写到一个对应的函数中，这样就可以大大减少main函数中的代码量了。\nint main() { func1(); //直接把多行代码写到一个函数中，在main中调用对应的函数，这样能够大幅度减少代码量 func2(); func3(); } 而我们从一开始就在编写main函数实际上是一种比较特殊的函数，C语言规定程序一律从主函数开始执行，所以这也是为什么我们一定要写成int main()的形式。\n全局变量和局部变量 现在我们已经了解了如何创建和调用函数，在继续学习后续内容之前，我们需要先认识一下全局变量和局部变量这两个概念（啊这，变量就变量，还分这么细啊？）\n我们首先来看看局部变量，实际上我们之前使用的都是局部变量，比如：\nint main() { int i = 10; //这里定义的变量i实际上是main函数中的局部变量，它的作用域只能是main函数中，也就是说其他地方是无法使用的 } 局部变量只会在其作用域中生效：\n可以看到在其他函数中，无法使用main函数中的变量，因为局部变量的作用域是有限的，比如位于某个函数内部的变量，那么它的作用域就是整个函数内部，而在其他位置均无法访问。又比如我们之前学习的for循环，当我们这样定义时：\n可以看到，在for循环中定义的变量i，只能在for循环内部使用，而出了这个花括号之后就用不了了，当然由于作用域不同，所以下面这种写法是完全没问题的：\nint main() { for (int i = 0; i \u0026lt; 10; ++i) { //虽然这里写了两个for都使用了i，但是由于处于两个不同的作用域，所以这两个i半毛钱关系都没有 } for (int i = 0; i \u0026lt; 20; ++i) { } } 所以，清楚了局部变量的作用域之后，我们在编写程序的时候就很清楚了：\n那么如果现在我们想要在任何位置都能使用一个变量，该怎么办呢？这时就要用到全局变量了：\n#include \u0026lt;stdio.h\u0026gt; void test(); int a = 10; //我们可以直接将变量定义放在外面，这样所有的函数都可以访问了 int main() { a += 10; test(); //现在各位觉得，这两个操作完成后，a会是多少呢？ printf(\u0026#34;%d\u0026#34;, a); } void test(){ a += 10; } 因为现在所有函数都能使用全局变量，所以这个结果不难得到。\n函数参数和返回 我们的函数可以接受参数来完成任务，比如我们现在想要实现用一个函数计算两个数的和并输出到控制台。\n这种情况我们就需要将我们需要进行加法计算的两个数，告诉函数，这样函数才能对这两个数求和，那么怎么才能告诉函数呢？我们可以通过设定参数：\n#include \u0026lt;stdio.h\u0026gt; void test(int, int); //函数原型中需要写上需要的参数类型，多个参数用逗号隔开，比如这里我们需要的就是两个int类型的参数 int main() { } void test(int a, int b){ //函数具体定义中也要写上，这里的a和b我们称为形式参数（形参），等价于函数中的局部变量，作用域仅限此函数 printf(\u0026#34;%d\u0026#34;, a + b); } 那么现在定义完成了，该如何使用这个函数呢，还记得我们怎么使用printf函数的吗？我们只需要把它所需要的参数填入即可：\nint main() { test(10, 20); //这里直接填写一个常量、变量或是运算表达式都是可以的，我们称实际传入的值为实际参数（实参） } 可以看到，成功计算出结果：\n实际上我们传入的实参在进入到函数时，会自动给函数中形参（局部变量）进行赋值，这样我们在函数中就可以得到外部传入的参数值了。\n我们来看看printf函数是怎么写的：\nint printf(const char * __restrict, ...) __printflike(1, 2); //看起来比较高级 这里我们主要关心它的两个参数，一个是char *由于还没有学习指针，这里就把它当做const char[]就行了，表示一个不可修改的字符串，而第二个参数我们看到是...，这三个点是个啥？\n我们知道，如果我们想要填写具体需要打印的值时，可以一直往后写：\nprintf(\u0026#34;%d, %d\u0026#34;, 1, 2); //参数可以一直写 正常情况下我们函数的参数列表都是固定的，怎么才能像这样写很多个呢？这就要用到可变长参数了，不过可变长参数的使用比较麻烦，这里我们就不做讲解了。\n这里给大家提一个问题，如果我们修改形式参数的值，外面的实参值会跟着发生修改吗？\n#include \u0026lt;stdio.h\u0026gt; void swap(int, int); int main() { int a = 10, b = 20; swap(a, b); printf(\u0026#34;a = %d, b = %d\u0026#34;, a, b); //最后会得到什么结果？ } void swap(int a, int b){ int tmp = a; //这里对a和b的值进行交换 a = b; b = tmp; } 通过结果发现，虽然调用了函数对a和b的值进行交换，但貌似并没有什么卵用。这是为什么呢？\n还记得我们前面说的吗，函数的形参实际上就是函数内的局部变量，它的作用域仅仅是这个函数，而我们外面传入的实参，仅仅知识将值赋值给了函数内的形参而已，并且外部的变量跟函数内部的变量作用域都不同，所以半毛钱关系都没有，这里交换的仅仅是函数内部的两个形参变量值，跟外部作实参的变量没有任何关系。\n那么，怎么样才能实现通过函数交换两个变量的值呢？这个问题我们会在指针部分进行讨论。\n不过数组却不受限制，我们在函数中修改数组的值，是直接可以生效的：\n#include \u0026lt;stdio.h\u0026gt; void test(int arr[]); int main() { int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0}; test(arr); printf(\u0026#34;%d\u0026#34;, arr[0]); //打印的是修改后的值了 } void test(int arr[]) { arr[0] = 999; //数组就可以做到这边修改，外面生效 } 我们再来看一个例子：\n#include \u0026lt;stdio.h\u0026gt; void test(int a){ a += 10; printf(\u0026#34;%d\\n\u0026#34;, a); } int main() { int a = 10; test(a); test(a); //连续两次调用，那么这两次的结果会是什么？ } 可以看到结果都是20，（如果猜对了可以直接跳过，如果你猜测的是20和30的话，需要听我解释了）注意每次调用函数都是单独进行的，并不是复用函数中的形参，不要认为第一次调用函数test就将函数的局部变量变成20了，再次调用就是20+10变成30。实际上这两次调用都是单独进行的，形参a都是在一开始的时候被赋值为实参的值的，这两次调用没有任何关系，并且函数执行完毕后就自动销毁了。\n那要是我就希望每次调用函数时保留变量的值呢？我们可以使用静态变量：\n#include \u0026lt;stdio.h\u0026gt; void test(); int main() { test(); test(); } void test() { static int a = 20; //静态变量并不会在函数结束时销毁其值，而是保持 a += 20; printf(\u0026#34;%d \u0026#34;, a); } 我们接着来看函数的返回值，并不是所有的函数都是执行完毕就结束了的，可能某些时候我们需要函数告诉我们执行的结果如何，这时我们就需要用到返回值了，比如现在我们希望实现一个函数计算a+b的值：\n#include \u0026lt;stdio.h\u0026gt; int sum(int ,int ); //现在我们要返回a和b的和（那么肯定也是int类型）所以这里需要将返回值类型修改为int int main() { int a = 10, b = 20; //计算a和b的和 int result = sum(a, b); //函数执行后，会返回一个int类型的结果，我们可以接收它，也可以像下面一样直接打印，当然也可以参与运算等等。 printf(\u0026#34;a+b=%d\u0026#34;, sum(a, b)); } int sum(int a, int b) { return a + b; //通过return关键字来返回计算的结果 } 我们接着来看下一个例子，现在我们希望你通过函数找到数组中第一个小于0的数字并将其返回，如果没有找到任何小于0的数，就返回0即可：\n#include \u0026lt;stdio.h\u0026gt; int findMin(int arr[], int len); //需要两个参数，一个是数组本身，还有一个是数组的长度 int main() { int arr[] = {1, 4, -9, 2, -4, 7}; int min = findMin(arr, 6); printf(\u0026#34;第一个小于0的数是：%d\u0026#34;, min); } int findMin(int arr[], int len) { for (int i = 0; i \u0026lt; len; ++i) { if(arr[i] \u0026lt; 0) return arr[i]; //当判断找到后，直接return返回即可，这样的话函数会直接返回结果，无论后面还有没有代码没有执行完，整个函数都会直接结束。 } return 0; //如果没有找到就返回0 } 这里我们使用了return关键字来返回结果，注意当我们的程序走到return时，无论还有什么内容没执行完，整个函数都将结束，并返回结果。注意带返回值（非void）的函数中的所有情况都需要有一个对应的返回值：\nint test(int a) { if (a \u0026gt; 0) { return 10; //当a大于0时有返回语句 } else{ //但是当a不大于0时就没有返回值了，这样虽然可以编译通过，但是会有警告（黄标），运行后可能会出现一些无法预知的问题 } } 如果是没有返回值的函数，我们也可以调用return来返回，不过默认情况下是可以省略的：\nvoid test(int a){ if(a == 10) return; //因为是void，所以什么都不需要加，直接return printf(\u0026#34;%d\u0026#34;, a); } 递归调用 我们的函数除了在其他地方被调用之外，也可以自己调用自己（好家伙，套娃是吧），这种玩法我们称为递归。\n#include \u0026lt;stdio.h\u0026gt; void test(){ printf(\u0026#34;Hello World!\\n\u0026#34;); test(); //函数自己在调用自己，这样的话下一轮又会进入到这个函数中 } int main() { test(); } 我们可以尝试运行一下上面的程序，会发现程序直接无限打印Hello World!这个字符串，这是因为函数自己在调用自己，不断地重复进入到这个函数，理论情况下，它将永远都不会结束，而是无限地执行这个函数的内容。\n但是到最后我们的程序还是终止了，这是因为函数调用有最大的深度限制，因为计算机不可能放任函数无限地进行下去。\n（选学）我们来大致了解一下函数的调用过程，实际上在程序运行时会有一个叫做函数调用栈的东西，它用于控制函数的调用：\n#include \u0026lt;stdio.h\u0026gt; //我们以下面的调用关系为例 void test2(){ printf(\u0026#34;giao\u0026#34;); } void test(){ test2(); //main -\u0026gt; test -\u0026gt; test2 printf(\u0026#34;giao\u0026#34;); } int main() { test(); printf(\u0026#34;giao\u0026#34;); } 其实我们可以很轻易地看出整个调用关系，首先是从main函数进入，然后调用test函数，在test函数中又调用了test2函数，此时我们就需要等待test2函数执行完毕，test才能继续，而main则需要等待test执行完毕才能继续。而实际上这个过程是由函数调用栈在控制的：\n而当test2函数执行完毕后，每个栈帧又依次从栈中出去：\n当所有的栈全部出去之后，程序结束。\n所以这也就不难解释为什么无限递归会导致程序出现错误，因为栈的空间有限，而函数又一直在进行自我调用，所以会导致不断地有新的栈帧进入，最后塞满整个栈的空间，就爆炸了，这种问题我们称为栈溢出（Stack Overflow）\n当然，如果我们好好地按照规范使用递归操作，是非常方便的，比如我们现在需要求某个数的阶乘：\n#include \u0026lt;stdio.h\u0026gt; int test(int n); int main() { printf(\u0026#34;%d\u0026#34;, test(3)); } int test(int n){ if(n == 1) return 1; //因为不能无限制递归下去，所以我们这里添加一个结束条件，在n = 1时返回 return test(n - 1) * n; //每次都让n乘以其下一级的计算结果，下一级就是n-1了 } 通过给递归调用适当地添加结束条件，这样就不会无限循环了，并且我们的程序看起来无比简洁，那么它是如何执行的呢：\n它看起来就像是一个先走到底部，然后拿到问题的钥匙后逐步返回的一个过程，并在返回的途中不断进行计算最后得到结果（妙啊）\n所以，合理地使用递归反而是一件很有意思的事情。\n实战：斐波那契数列解法其三 前面我们介绍了函数的递归调用，我们来看一个具体的实例吧，我们还是以解斐波那契数列为例。\n既然每个数都是前两个数之和，那么我们是否也可以通过递归的形式不断划分进行计算呢？我们依然可以借鉴之前动态规划的思想，通过划分子问题，分而治之来完成计算。\n实战：汉诺塔 什么是汉诺塔？\n汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始\n按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。\n这三根柱子我们就依次命名为A、B、C，现在请你设计一个C语言程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。\n这个问题看似很难，实际上我们也可以对每一步进行推理：\n当汉诺塔只有1阶的情况下：直接把A上的圆盘移动到C，搞定。\n当汉诺塔只有2阶的情况下：我们的最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，我们得先把这个圆盘给处理了，所以我们得把这上面的1个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的1个圆盘丢到C上去\n当汉诺塔只有3阶的情况下：我们的最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，我们得先把这个圆盘给处理了，所以我们得把这上面的2个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的2个圆盘丢到C上\n实际上我们发现，把A移动到C是一定要进行的，而在进行之前需要先把压在上面全部的圆盘全部放到B去。而移动之后也要把B上的圆盘全部移动到C上去。其实所有的情况下最终都会有一个n=1的情况，将A上的最后一个圆盘移动到C，只是多了一个前面的步骤和后面的步骤。\n不过难点就是，怎么把A上的n-1个圆盘移动到B去呢？其实这时我们可以依靠C作为中间商，来帮助我们移动（比如n = 3，那么先把最上面的移动到C，然后把第二大的移动到B，再从C上把最小的移动到B上，这样就借助了C完成了两个圆盘的转移），而最后又怎么把B上的圆盘全部移到C去呢，这时就可以依靠A作为中间商，方法同理；实际上大问题最后都会变成n = 2时这样的小问题，只不过是要移动目标不同罢了。\n只要想通了怎么去借助中间商进行移动，就很好写出程序了。\n递归函数如下设计：\n//a存放圆盘的初始柱子，b作为中间柱子存放使用，c作为目标柱子，n表示要从a移动到c的圆盘数 void hanoi(char a, char b, char c, int n){ } 现在我们来实现一下吧。\nvoid move(char start, char end, int n){ //用于打印移动操作到控制台，start是起始柱子，end是结束柱子，n是哪一个圆盘 printf(\u0026#34;第%d个圆盘：%c --\u0026gt; %c\\n\u0026#34;, n, start, end); } void hanoi(char a, char b, char c, int n){ //刚进来的时候，B作为中间柱子，C作为目标柱子，要移动A上的n个圆盘到C去 if(n == 1) { move(a, c, n); //无论a,b,c如何变换，通过递归，最后都会变成一个n = 1的问题，直接移动就完事了 } else{ hanoi(a, c ,b, n - 1); //首要目标是先把上面n-1个圆盘全部放到B去，这里就变换一下，让B作为目标柱子，C作为中间 move(a, c, n); //现在A上只剩下一个最大的圆盘了，接着把A最下方的一个圆盘移到C去 hanoi(b, a, c, n - 1); //最后需要把B上的全部搬到C上去，这里就可以以C为目标柱子，A为中间柱子 } } 简化一波：\nvoid hanoi(char a, char b, char c, int n){ if(n == 0) return; hanoi(a, c ,b, n - 1); printf(\u0026#34;第%d个圆盘：%c --\u0026gt; %c\\n\u0026#34;, n, a, c); hanoi(b, a, c, n - 1); } 看似如此复杂的问题，其实只需要4行就可以解决了。\n实战：快速排序算法（选学） 有一个数组：\nint arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0}; 现在请你设计一个C语言程序，对数组按照从小到大的顺序进行排序。这里我们使用冒泡排序的进阶版本——快速排序来完成，它的核心思想是分而治之，每一轮排序都会选出一个基准，一轮排序完成后，所以比基准小的数一定在左边，比基准大的数一定在右边，在分别通过同样的方法对左右两边的数组进行排序，不断划分，最后完成整个数组的排序。它的效率相比冒泡排序的双重for循环有所提升。\n#include \u0026lt;stdio.h\u0026gt; void quickSort(int arr[], int left, int right){ //arr是数组，left是起始下标，right是结束下标 //请实现这一部分 } int main() { int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0}; quickSort(arr, 0, 9); //10个数字下标就是0-9 for (int i = 0; i \u0026lt; 10; ++i) { printf(\u0026#34;%d \u0026#34;, arr[i]); } } 不过虽然这种排序算法很快，但是极端情况下（比如遇到了刚好倒序的数组）还是会退化成冒泡排序的。\n指针 指针可以说是整个C语言中最难以理解的部分了，不过其实说简单也简单，你会发现也并没有想象中的那么难，你与它的距离可能只差了那么一些基础知识，这一部分都会及时进行补充的。\n什么是指针 还记得我们在上一个部分谈到的通过函数交换两个变量的值吗？\n#include \u0026lt;stdio.h\u0026gt; void swap(int, int); int main() { int a = 10, b = 20; swap(a, b); printf(\u0026#34;a = %d, b = %d\u0026#34;, a, b); //最后会得到什么结果？ } void swap(int a, int b){ int tmp = a; //这里对a和b的值进行交换 a = b; b = tmp; } 实际上这种写法是错误的，因为交换的并非是真正的a和b，而是函数中的局部变量。那么有没有办法能够直接对函数外部的变量进行操作呢？这就需要指针的帮助了。\n我们知道，程序中使用的变量实际上都在内存中创建的，每个变量都会被保存在内存的某一个位置上（具体在哪个位置是由系统分配的），就像我们最终会在这个世界上的某个角落安家一样，所有的变量在对应的内存位置上都有一个地址（地址是独一无二的），而我们可以通过这个地址寻找到这个变量本体，比如int占据4字节，因此int类型变量的地址就是这4个字节的起始地址，后面32个bit位全部都是用于存放此变量的值的。\n这里的0x是十六进制的表示形式（10-15用字母A - F表示）如果我们能够知道变量的内存地址，那么无论身在何处，都可以通过地址找到这个变量了。而指针的作用，就是专门用来保存这个内存地址的。\n我们来看看如何创建一个指针变量用于保存变量的内存地址：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 10; //指针类型需要与变量的类型相同，且后面需要添加一个*符号（注意这里不是乘法运算）表示是对于类型的指针 int * p = \u0026amp;a; //这里的\u0026amp;并不是进行按位与运算，而是取地址操作，也就是拿到变量a的地址 printf(\u0026#34;a在内存中的地址为：%p\u0026#34;, p); //地址使用%p表示 } 可以看到，我们通过取地址操作\u0026amp;，将变量a的地址保存到了一个地址变量p中。\n拿到指针之后，我们可以很轻松地获取指针所指地址上的值：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 666; int * p = \u0026amp;a; printf(\u0026#34;内存%p上存储的值为：%d\u0026#34;, p, *p); //我们可以在指针变量前添加一个*号（间接运算符，也可以叫做解引用运算符）来获取对应地址存储的值 } 注意这里访问指针所指向地址的值时，是根据类型来获取的，比如int类型占据4个字节，那么就读取地址后面4个字节的内容作为一个int值，如果指针是char类型的，那么就只读取地址后面1个字节作为char类型的值。\n同样的，我们也可以直接像这样去修改对应地址存放的值：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 666; int * p = \u0026amp;a; *p = 999; //通过*来访问对应地址的值，并通过赋值运算对其进行修改 printf(\u0026#34;a的值为：%d\u0026#34;, a); } 实际上拿到一个变量的地址之后，我们完全不需要再使用这个变量，而是可以通过它的指针来对其进行各种修改。因此，现在我们想要实现对两个变量的值进行交换的函数就很简单了：\n#include \u0026lt;stdio.h\u0026gt; // 这里是两个指针类型的形参，其值为实参传入的地址， // 虽然依然是值传递，但是这里传递的可是地址啊， // 只要知道地址改变量还不是轻轻松松？ void swap(int * a, int * b){ int tmp = *a; //先暂存一下变量a地址上的值 *a = *b; //将变量b地址上的值赋值给变量a对应的位置 *b = tmp; //最后将a的值赋值给b对应位置，OK，这样就成功交换两个变量的值了 } int main(){ int a = 10, b = 20; swap(\u0026amp;a, \u0026amp;b); //只需要把a和b的内存地址给过去就行了，这里取一下地址 printf(\u0026#34;a = %d, b = %d\u0026#34;, a, b); } 通过地址操作，我们就轻松实现了使用函数交换两个变量的值了。\n了解了指针的相关操作之后，我们再来看看scanf函数，实际上就很好理解了：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); //这里就是取地址，我们需要告诉scanf函数变量的地址，这样它才能通过指针访问变量的内存地址，对我们变量的值进行修改，这也是为什么scanf里面的变量（除数组外）前面都要进行一个取地址操作 printf(\u0026#34;%d\u0026#34;, a); } 当然，和变量一样，要是咱们不给指针变量赋初始值的话，就不知道指的哪里了，因为指针变量也是变量，存放的其他变量的地址值也在内存中保存，如果不给初始值，那么存放别人地址的这块内存可能在其他地方使用过，这样就不知道初始值是多少了（那么指向的地址可能是一个很危险的地址，随意使用可能导致会出现严重错误），所以一定要记得给个初始值或是将其设定为NULL，表示空指针，不指向任何内容。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int * a = NULL; } 我们接着来看看const类型的指针，这种指针比较特殊：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 9, b = 10; const int * p = \u0026amp;a; *p = 20; //这里直接报错，因为被const标记的指针，所指地址上的值不允许发生修改 p = \u0026amp;b; //但是指针指向的地址是可以发生改变的 } 我们再来看另一种情况：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 9, b = 10; int * const p = \u0026amp;a; //const关键字被放在了类型后面 *p = 20; //允许修改所指地址上的值 p = \u0026amp;b; //但是不允许修改指针存储的地址值，其实就是反过来了。 } 当然也可以双管齐下：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 9, b = 10; const int * const p = \u0026amp;a; *p = 20; //两个都直接报错，都不让改了 p = \u0026amp;b; } 指针与数组 前面我们介绍了指针的基本使用，我们来回顾一个问题，为什么数组可以以原身在函数之间进行传递呢？先说结论，数组表示法实际上是在变相地使用指针，你甚至可以将其理解为数组变量其实就是一个指针变量，它存放的就是数组中第一个元素的起始地址。\n为什么这么说？\n#include \u0026lt;stdio.h\u0026gt; int main(){ char str[] = \u0026#34;Hello World!\u0026#34;; char * p = str; //？？？啥情况，为什么能直接把数组作为地址赋值给指针变量p？？？ printf(\u0026#34;%c\u0026#34;, *p); //还能正常使用，打印出第一个字符？？？ } 你以为这就完了？还能这样玩呢：\nint main(){ char str[] = \u0026#34;Hello World!\u0026#34;; char * p = str; printf(\u0026#34;%c\u0026#34;, p[1]); //？？？怎么像在使用数组一样用指针？？？ } 太迷了吧，怎么数组和指针还能这样混着用呢？我们先来看看数组在内存中是如何存放的：\n数组在内存中是一块连续的空间，所以为什么声明数组一定要明确类型和大小，因为这一块连续的内存空间生成后就固定了。\n而我们的数组变量实际上存放的就是首元素的地址，而实际上我们之前一直使用的都是数组表示法来操作数组，这样可以很方便地让我们对内存中的各个元素值进行操作：\nint main(){ char str[] = \u0026#34;Hello World!\u0026#34;; printf(\u0026#34;%c\u0026#34;, str[0]); //直接在中括号中输入对应的下标就能访问对应位置上的数组了 } 而我们知道实际上str表示的就是数组的首地址，所以我们完全可以将其赋值给一个指针变量，因为指针变量也是存放的地址：\nchar str[] = \u0026#34;Hello World!\u0026#34;; char * p = str; //直接把str代表的首元素地址给到p 而使用指针后，实际上我们可以使用另一种表示法来操作数组，这种表示法叫做指针表示法：\nint main(){ char str[] = \u0026#34;Hello World!\u0026#34;; char * p = str; printf(\u0026#34;第一个元素值为：%c，第二个元素值为：%c\u0026#34;, *p, *(p+1)); //通过指针也可以表示对应位置上的值 } 比如我们现在需要表示数组中的第二个元素：\n数组表示法：str[1] 指针表示法：*(p+1) 虽然写法不同，但是他们表示的意义是完全相同的，都代表了数组中的第二个元素，其中指针表示法使用了p+1的形式表示第二个元素，这里的+1操作并不是让地址+1，而是让地址+ 一倍的对应类型大小，也就是说地址后移一个char的长度，所以正好指向了第二个元素，然后通过*取到对应的值（注意这种操作仅对数组是有意义的，如果是普通的变量，虽然也可以通过这种方式获得后一个char的长度的数据，但是毫无意义）\n*(p+i) \u0026lt;=\u0026gt; str[i] //实际上就是可以相互转换的 这两种表示法都可以对内存中存放的数组内容进行操作，只是写法不同罢了，所以你会看到数组和指针混用也就不奇怪了。了解了这些东西之后，我们来看看下面的各个表达式分别代表什么：\n*p //数组的第一个元素 p //数组的第一个元素的地址 p == str //肯定是真，因为都是数组首元素地址 *str //因为str就是首元素的地址，所以这里对地址加*就代表第一个元素，使用的是指针表示法 \u0026amp;str[0] //这里得到的实际上还是首元素的地址 *(p + 1) //代表第二个元素 p + 1 //第二个元素的内存地址 *p + 1 //注意*的优先级比+要高，所以这里代表的是首元素的值+1，得到字符\u0026#39;K\u0026#39; 所以不难理解，为什么printf函数的参数是一个const char * 了，实际上就是需要我们传入一个字符串而已，只不过这里采用的是指针表示法而已。\n当然指针也可以进行自增和自减操作，比如：\n#include \u0026lt;stdio.h\u0026gt; int main(){ char str[] = \u0026#34;Hello World!\u0026#34;; char * p = str; p++; //自增后相当于指针指向了第二个元素的地址 printf(\u0026#34;%c\u0026#34;, *p); //所以这里打印的就是第二个元素的值了 } 一维数组看完了，我们来看看二维数组，那么二维数组在内存中是如何表示的呢？\nint arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; 这是一个2x3的二维数组，其中存放了两个能够容纳三个元素的数组，在内存中，是这样的：\n所以虽然我们可以使用二维数组的语法来访问这些元素，但其实我们也可以使用指针来进行访问：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int arr[][3] = {{1, 2, 3}, {4, 5, 6}}; int * p = arr[0]; //因为是二维数组，注意这里要指向第一个元素，来降一个维度才能正确给到指针 //同理如果这里是arr[1]的话那么就表示指向二维数组中第二个数组的首元素 printf(\u0026#34;%d = %d\u0026#34;, *(p + 4), arr[1][1]); //实际上这两种访问形式都是一样的 } 多级指针 我们知道，实际上指针本身也是一个变量，它存放的是目标的地址，但是它本身作为一个变量，它也要将地址信息保存到内存中，所以，实际上当我们有指针之后：\n实际上，我们我们还可以继续创建一个指向指针变量地址的指针，甚至可以创建更多级（比如指向指针的指针的指针）比如现在我们要创建一个指向指针的指针：\n落实到咱们的代码中：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 20; int * p = \u0026amp;a; //指向普通变量的指针 //因为现在要指向一个int *类型的变量，所以类型为int* 再加一个* int ** pp = \u0026amp;p; //指向指针的指针（二级指针） int *** ppp = \u0026amp;pp; //指向指针的指针的指针（三级指针） } 那么我们如何访问对应地址上的值呢？\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 20; int * p = \u0026amp;a; int ** pp = \u0026amp;p; printf(\u0026#34;p = %p, a = %d\u0026#34;, *pp, **pp); //使用一次*表示二级指针指向的指针变量，继续使用一次*会继续解析成指针变量所指的普通变量 } 本质其实就是一个套娃而已，只要把各个层次分清楚，实际上还是很好理解的。\n**特别提醒：**一级指针可以操作一维数组，那么二级指针是否可以操作二维数组呢？不能！因为二级指针的含义都不一样了，它是表示指针的指针，而不是表示某个元素的指针了。下面我们会认识数组指针，准确的说它才更贴近于二维数组的形式。\n指针数组与数组指针 前面我们了解了指针的一些基本操作，包括它与数组的一些关系。我们接着来看指针数组和数组指针，这两词语看着就容易搞混，不过哪个词在后面就哪个，我们先来看指针数组，虽然名字很像数组指针，但是它本质上是一个数组，不过这个数组是用于存放指针的数组。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a, b, c; int * arr[3] = {\u0026amp;a, \u0026amp;b, \u0026amp;c}; //可以看到，实际上本质还是数组，只不过存的都是地址 } 因为这个数组中全都是指针，比如现在我们想要访问数组中第一个指针指向的地址：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a, b, c; int * arr[3] = {\u0026amp;a, \u0026amp;b, \u0026amp;c}; *arr[0] = 999; //[]运算符的优先级更高，所以这里先通过[0]取出地址，然后再使用*将值赋值到对应的地址上 printf(\u0026#34;%d\u0026#34;, a); } 当然我们也可以用二级指针变量来得到指针数组的首元素地址：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int * p[3]; //因为数组内全是指针 int ** pp = p; //所以可以直接使用指向指针的指针来指向数组中的第一个指针元素 } 实际上指针数组还是很好理解的，那么数组指针呢？可以看到指针在后，说明本质是一个指针，不过这个指针比较特殊，它是一个指向数组的指针（注意它的目标是整个数组，和我们之前认识的指针不同，之前认识的指针是指向某种类型变量的指针）\n比如：\nint * p; //指向int类型的指针 而数组指针则表示指向整个数组：\nint (*p)[3]; //注意这里需要将*p括起来，因为[]的优先级更高 注意它的目标是整个数组，而不是普通的指针那样指向的是数组的首个元素：\nint arr[3] = {111, 222, 333}; int (*p)[3] = \u0026amp;arr; //直接对整个数组再取一次地址（因为数组指针代表的是整个数组的地址，虽然和普通指针都是指向首元素地址，但是意义不同） 那么现在已经取到了指向整个数组的指针，该怎么去使用呢？\n#include \u0026lt;stdio.h\u0026gt; int main(){ int arr[3] = {111, 222, 333}; int (*p)[3] = \u0026amp;arr; //直接对整个数组再取一次地址 printf(\u0026#34;%d, %d, %d\u0026#34;, *(*p+0), *(*p+1), *(*p+2)); //要获取数组中的每个元素，稍微有点麻烦 } 注意此时：\np代表整个数组的地址 *p表示所指向数组中首元素的地址 *p+i表示所指向数组中第i个（0开始）元素的地址（实际上这里的*p就是指向首元素的指针） *(*p + i)就是取对应地址上的值了 虽然在处理一维数组上感觉有点麻烦，但是它同样也可以处理二维数组：\nint arr[][3] = {{111, 222, 333}, {444, 555, 666}}; int (*p)[3] = arr; //二维数组不需要再取地址了，因为现在维度提升，数组指针指向的是二维数组中的其中一个元素（因为元素本身就是一个数组） 比如现在我们想要访问第一个数组的第二个元素，根据上面p各种情况下的意义：\nprintf(\u0026#34;%d\u0026#34;, *(*p+1)); //因为上面直接指向的就是第一个数组，所以想要获取第一个元素和之前是一模一样的 那么要是我们现在想要获取第二个数组中的最后一个元素呢？\nprintf(\u0026#34;%d\u0026#34;, *(*(p+1)+2); //首先*(p+1)为一个整体，表示第二个数组（因为是数组指针，所以这里+1一次性跳一个数组的长度），然后再到外层+2表示数组中的第三个元素，最后再取地址，就是第二个数组的第三个元素了 当然也可以使用数组表示法：\nprintf(\u0026#34;%d\u0026#34;, p[1][2]); //好家伙，这不就是二维数组的用法吗，没错，看似很难，你甚至可以认为这两用着是同一个东西 指针函数与函数指针 我们的函数可以返回一个指针类型的结果，这种函数我们就称为指针函数。\n#include \u0026lt;stdio.h\u0026gt; int * test(int * a){ //函数的返回值类型是int *指针类型的 return a; } int main(){ int a = 10; int * p = test(\u0026amp;a); //使用指针去接受函数的返回值 printf(\u0026#34;%d\u0026#34;, *p); printf(\u0026#34;%d\u0026#34;, *test(\u0026amp;a)); //当然也可以直接把间接运算符在函数调用前面表示直接对返回的地址取地址上的值 } 不过要注意指针函数不要尝试去返回一个局部变量的地址：\n#include \u0026lt;stdio.h\u0026gt; int * test(int a){ int i = a; return \u0026amp;i; //返回局部变量i的地址 } int main(){ int * p = test(20); //连续调用两次test函数 test(30); printf(\u0026#34;%d\u0026#34;, *p); //最后结果可能并不是我们想的那样 } 为什么会这样呢？还记得我们前面说的吗？函数一旦返回，那么其中的局部变量就会全部销毁了，至于这段内存之后又会被怎么去使用，我们也就不得而知了。\n局部变量其实是存放在栈帧中的，如果前面的选学部分听了之后，你就知道为什么这里得到的是第二次的30了，因为第二次调用的栈帧入栈后就覆盖了这段内存，又因为是同一个函数所以栈帧结构是一样的，最后在同样的位置就存放了新的30这个值。\n我们接着来看函数指针，实际上指针除了指向一个变量之外，也可以指向一个函数，当然函数指针本身还是一个指针，所以依然是用变量表示，但是它代表的是一个函数的地址（编译时系统会为函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址）\n我们来看看如何定义：\n#include \u0026lt;stdio.h\u0026gt; int sum(int a, int b) { return a + b; } int main(){ //类型 (*指针变量名称)(函数参数...) //注意一定要把*和指针变量名称括起来，不然优先级不够 int (*p)(int, int) = sum; printf(\u0026#34;%p\u0026#34;, p); } 这样我们就拿到了函数的地址，既然拿到函数的地址，那么我们就可以通过函数的指针调用这个函数了：\n#include \u0026lt;stdio.h\u0026gt; int sum(int a, int b) { return a + b; } int main(){ int (*p)(int, int) = sum; int result = (*p)(1, 2); //就像我们正常使用函数那样，(*p)表示这个函数，后面依然是在小括号里面填上实参 int result = p(1, 2); //当然也可以直接写函数指针变量名称，效果一样（咋感觉就是给函数换了个名呢） printf(\u0026#34;%d\u0026#34;, result); } 有了函数指针，我们就可以编写函数回调了（所谓回调就让别人去调用我们提供的函数，而不是我们主动来调别人的函数），比如现在我们定义了一个函数，不过这个函数需要参数通过一个处理的逻辑才能正常运行：\nint sum(int (*p)(int, int), int a, int b){ //将函数指针作为参数传入 //函数回调 return p(a, b); //就像你进了公司然后花钱请别人帮你写代码，工资咱们五五开，属于是直接让别人帮你实现 } 于是我们就还要给他一个其他函数的地址：\n#include \u0026lt;stdio.h\u0026gt; int sum(int (*p)(int, int), int a, int b){ return p(a, b); } int sumImpl(int a, int b){ //这个函数实现了a + b return a + b; } int main(){ int (*p)(int, int) = sumImpl; //拿到实现那个函数的地址 printf(\u0026#34;%d\u0026#34;, sum(p, 10, 20)); } 当然，函数指针也可以保存一组函数的地址，成为函数指针数组，但是这里就不多说了，相信各位已经快顶不住了吧。\n实战：合并两个有序数组 来源：力扣 No.88 合并两个有序数组：https://leetcode.cn/problems/merge-sorted-array/\n给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n示例 1：\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n示例 2：\n输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。\n示例 3：\n输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n现在请你设计一个C语言程序，实现下面的函数（要求全程使用指针，不允许出现数组用法）：\nvoid merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){ } 实战：二维数组中的查找 来源：剑指Offer 04. 二维数组中的查找：https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n示例:\n现有矩阵 matrix 如下：\n[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ]\n给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n现在请你设计一个C语言程序，实现下面的函数（要求全程使用指针，不允许出现数组用法）：\n/* * 输入 **matrix 是长度为 matrixSize 的数组指针的数组，其中每个元素（也是一个数组） * 的长度组成 *matrixColSize 数组作为另一输入，*matrixColSize 数组的长度也为 matrixSize */ bool findNumberIn2DArray(int** matrix, int matrixSize, int* matrixColSize, int target){ } 结构体、联合体和枚举 终于熬过了最难的一个部分，后面的内容就相对简单多了，我们接着来看结构体。\n我们之前认识过很多种数据类型，包括整数、小数、字符、数组等，通过使用对应的数据类型，我们就可以很轻松地将我们的数据进行保存了，但是有些时候，这种简单类型很难去表示一些复杂结构。\n创建和使用结构体 比如现在我们要保存100个学生的信息（学生信息包括学号、姓名、年龄）我们发现似乎找不到一种数据类型能够同时保存这三种数据（数组虽然能保存一些列的元素，但是只能保存同种类型的）。但是如果把它们拆开单独存在，就可以使用对应的类型存放了，不过这样也太不方便了吧，这些数据应该是捆绑在一起的，而不是单独地去存放。所以，为了解决这种问题，C语言提供了结构体类型，它能够将多种类型的数据集结到一起，让他们形成一个整体。\nstruct Student { //使用 (struct关键字 + 结构体类型名称) 来声明结构体类型，这种类型是我们自己创建的（同样也可以作为函数的参数、返回值之类的） int id; //结构体中可以包含多个不同类型的数据，这些数据共同组成了整个结构体类型（当然结构体内部也能包含结构体类型的变量） int age; char * name; //用户名可以用指针指向一个字符串，也可以用char数组来存，如果是指针的话，那么数据不会存在结构体中，只会存放字符串的地址，但是如果是数组的话，数据会存放在结构体中 }; int main() { struct Student { //也可以以局部形式存在 }; } 定义好结构体后，我们只需要使用结构体名称作为类型就可以创建一个结构体变量了：\n#include \u0026lt;stdio.h\u0026gt; struct Student { int id; int age; char * name; }; int main() { //类型需要写为struct Student，后面就是变量名称 struct Student s = {1, 18, \u0026#34;小明\u0026#34;}; //结构体包含多种类型的数据（它们是一个整体），只需要把这些数据依次写好放在花括号里面就行了 } struct Student { int id; int age; char * name; } s; //也可以直接在花括号后面写上变量名称（多个用逗号隔开），声明一个全局变量 这样我们就创建好了一个结构体变量，而这个结构体表示的就是学号为1、年龄18、名称为小明的结构体数据了。\n当然，结构体的初始化需要注意：\nstruct Student s = {1, 18}; //如果只写一半，那么只会初始化其中一部分数据，剩余的内容相当于没有初始值，跟数组是一样的 struct Student s = {1, .name = \u0026#34;小红\u0026#34;}; //也可以指定去初始化哪一个属性 .变量名称 = 初始值 那么现在我们拿到结构体变量之后，怎么去访问结构体内部存储的各种数据呢？\nprintf(\u0026#34;id = %d, age = %d, name = %s\u0026#34;, s.id, s.age, s.name); //结构体变量.数据名称 (这里.也是一种运算符) 就可以访问结构体中存放的对应的数据了 是不是很简单？当然我们也可以通过同样的方式对结构体中的数据进行修改：\nint main() { struct Student s = {1, 18, \u0026#34;小明\u0026#34;}; s.name = \u0026#34;小红\u0026#34;; s.age = 17; printf(\u0026#34;id = %d, age = %d, name = %s\u0026#34;, s.id, s.age, s.name); } 那么结构体在内存中占据的大小是如何计算的呢？比如下面的这个结构体\nstruct Object { int a; short b; char c; }; 这里我们可以借助sizeof关键字来帮助我们计算：\nint main() { printf(\u0026#34;int类型的大小是：%lu\u0026#34;, sizeof(int)); //sizeof能够计算数据在内存中所占据的空间大小（字节为单位） } 当然也可以计算变量的值占据的大小：\nint main() { int arr[10]; printf(\u0026#34;int arr[10]占据的大小是：%lu\u0026#34;, sizeof (arr)); //在判断非类型时，sizeof 括号可省 } 同样的，它也能计算我们的结构体类型会占用多少的空间：\n#include \u0026lt;stdio.h\u0026gt; struct Object { char a; int b; short c; }; int main() { printf(\u0026#34;%lu\u0026#34;, sizeof(struct Object)); //直接填入struct Object作为类型 } 可以看到结果是8，那么，这个8字节是咋算出来的呢？\nint（4字节）+ short（2字节）+ char（1字节） = 7字节（这咋看都算不出来12啊？）\n实际上结构体的大小是遵循下面的规则来进行计算的：\n结构体中的各个数据要求字节对齐，规则如下： **规则一：**结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列的。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上（0默认是所有大小的整数倍） **规则二：**如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。 **规则三：**基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。 这里我们以下面的为例：\nstruct Object { char a; //char占据1个字节 int b; //int占据4个字节，因为前面存了一个char，按理说应该从第2个字节开始存放，但是根据规则一，必须在自己的整数倍位置上存放，所以2不是4的整数倍位置，这时离1最近的下一个整数倍地址就是4了，所以前面空3个字节的位置出来，然后再放置 short c; //前面存完int之后，就是从8开始了，刚好满足short（2字节）的整数倍，但是根据规则二，整个结构体大小必须是最大对齐大小的整数倍（这里最大对齐大小是int，所以是4），存完short之后，只有10个字节，所以屁股后面再补两个空字节，这样就可以了 }; 这样，就不难得出为什么结构体的大小是12了。\n结构体数组和指针 前面我们介绍了结构体，现在我们可以将各种类型的数据全部安排到结构体中一起存放了。\n不过仅仅只是使用结构体，还不够，我们可能需要保存很多个学生的信息，所以我们需要使用结构体类型的数组来进行保存：\n#include \u0026lt;stdio.h\u0026gt; struct Student { int id; int age; char * name; }; int main() { struct Student arr[3] = {{1, 18, \u0026#34;小明\u0026#34;}, //声明一个结构体类型的数组，其实和基本类型声明数组是一样的 {2, 17, \u0026#34;小红\u0026#34;}, //多个结构体数据用逗号隔开 {3, 18, \u0026#34;小刚\u0026#34;}}; } 那么现在如果我们想要访问数组中第二个结构体的名称属性，该怎么做呢？\nint main() { struct Student arr[3] = {{1, 18, \u0026#34;小明\u0026#34;}, {2, 17, \u0026#34;小红\u0026#34;}, {3, 18, \u0026#34;小刚\u0026#34;}}; printf(\u0026#34;%s\u0026#34;, arr[1].name); //先通过arr[1]拿到第二个结构体，然后再通过同样的方式 .数据名称 就可以拿到对应的值了 } 当然，除了数组之外，我们可以创建一个指向结构体的指针。\nint main() { struct Student student = {1, 18, \u0026#34;小明\u0026#34;}; struct Student * p = \u0026amp;student; //同样的，类型后面加上*就是一个结构体类型的指针了 } 我们拿到结构体类型的指针后，实际上指向的就是结构体对应的内存地址，和之前一样，我们也可以通过地址去访问结构体中的数据：\nint main() { struct Student student = {1, 18, \u0026#34;小明\u0026#34;}; struct Student * p = \u0026amp;student; printf(\u0026#34;%s\u0026#34;, (*p).name); //由于.运算符优先级更高，所以需要先使用*p得到地址上的值，然后再去访问对应数据 } 不过这样写起来太累了，我们可以使用简便写法：\nprintf(\u0026#34;%s\u0026#34;, p-\u0026gt;name); //使用 -\u0026gt; 运算符来快速将指针所指结构体的对应数据取出 我们来看看结构体作为参数在函数之间进行传递时会经历什么：\nvoid test(struct Student student){ student.age = 19; //我们对传入的结构体中的年龄进行修改 } int main() { struct Student student = {1, 18, \u0026#34;小明\u0026#34;}; test(student); printf(\u0026#34;%d\u0026#34;, student.age); //最后会是修改后的值吗？ } 可以看到在其他函数中对结构体内容的修改并没有对外面的结构体生效，因此，实际上结构体也是值传递。我们修改的只是另一个函数中的局部变量而已。\n所以如果我们需要再另一个函数中处理外部的结构体，需要传递指针：\nvoid test(struct Student * student){ //这里使用指针，那么现在就可以指向外部的结构体了 student-\u0026gt;age = 19; //别忘了指针怎么访问结构体内部数据的 } int main() { struct Student student = {1, 18, \u0026#34;小明\u0026#34;}; test(\u0026amp;student); //传递结构体的地址过去 printf(\u0026#34;%d\u0026#34;, student.age); } 当然一般情况下推荐传递结构体的指针，而不是直接进行值传递，因为如果结构体非常大的话，光是数据拷贝就需要花费很大的精力，并且某些情况下我们可能根本用不到结构体中的所有数据，所以完全没必要浪费空间，使用指针反而是一种更好的方式。\n联合体 联合体也可以在内部定义很多种类型的变量，但是它与结构体不同的是，所以的变量共用同一个空间。？？？？啥意思？\nunion Object { //定义一个联合体类型唯一不同的就是前面的union了 int a; char b; float c; }; 我们来看看一个神奇的现象：\n#include \u0026lt;stdio.h\u0026gt; union Object { int a; char b; float c; }; int main() { union Object object; object.a = 66; //先给a赋值66 printf(\u0026#34;%d\u0026#34;, object.b); //访问b } ？？？？\n我修改的是a啊，怎么b也变成66了？这是因为它们共用了内存空间，实际上我们先将a修改为66，那么就将这段内存空间上的值修改为了66，因为内存空间共用，所以当读取b时，也会从这段内存空间中读取一个char长度的数据出来，所以得到的也是66。\nint main() { union Object object; object.a = 128; printf(\u0026#34;%d\u0026#34;, object.b); } 因为：128 = 10000000，所以用char读取后，由于第一位是符号位，于是就变成了-128。\n那么联合体的大小又是如何决定的呢？\nunion Object { int a; char b; float c; }; int main() { printf(\u0026#34;%lu\u0026#34;, sizeof(union Object)); } 实际上，联合体的大小至少是其内部最大类型的大小，这里是int所以就是4，当然，当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。\n当然联合体的其他使用基本与结构体差不多，这里就不提了。\n枚举 最后我们来看一下枚举类型，枚举类型一般用于表示一些预设好的整数常量，比如我们风扇有低、中、高三个档位，我们总是希望别人使用我们预设好的这三个档位，而不希望使用其他的档位，因为我们风扇就只设计了这三个档位。\n这时我们就可以告诉别人，我们的风扇有哪几个档位，这种情况使用枚举就非常适合。在我们的程序中，只能使用基本数据类型对这三种档位进行区分，这样显然可读性不够，别人怎么知道哪个代表哪个档位呢？而使用枚举就没有这些问题了：\n/** * 比如现在我们设计： * 1 = 低档位 * 2 = 中档位 * 3 = 高档位 */ enum status {low = 1, middle = 2, high = 3}; //enum 枚举类型名称 {枚举 = 初始值, 枚举...} 我们可以创建多个自定义名称的枚举，命名规则和变量差不多。我们可以当每一个枚举对应一个整数值，这样的话，我们就不需要去记忆每个数值代表的是什么档位了，我们可以直接根据枚举的名称来进行分辨，是不是很方便？\n使用枚举也非常地方便：\nenum status {low = 1, middle = 2, high = 3}; int main() { enum status a = low; //和之前一样，直接定义即可，类型为enum + 枚举名称，后面是变量名称，值可以直接写对应的枚举 printf(\u0026#34;%d\u0026#34;, a); } int main() { enum status a = high; if(a == low) { //判断起来就方便多了 printf(\u0026#34;低档位\u0026#34;); } else if (a == high){ printf(\u0026#34;高档位\u0026#34;); } else { printf(\u0026#34;中档位\u0026#34;); } } 当然也可以直接加入到switch语句中：\nint main() { enum status a = high; switch (a) { case low: case high: case middle: default: ; } } 不过在枚举变量定义时需要注意：\nenum status {low, middle, high}; //如果不给初始值的话，那么会从第一个枚举开始，默认值为0，后续依次+1 所以这里的low就是0，middle就是1，high就是2了。\n如果中途设定呢？\nenum status {low, middle = 6, high}; //这里我们给middle设定为6 这时low由于是第一个，所以还是从0开始，不过middle这里已经指定为6了，所以紧跟着的high初始值就是middle的值+1了，因此low现在是0，middle就是6，high就是7了。\ntypedef关键字 这里最后还要提一下typedef关键字，这个关键字用于给指定的类型起别名。怎么个玩法呢？\ntypedef int lbwnb; //食用方式：typedef 类型名称 自定义类型别名 比如这里我们给int起了一个别名，那么现在我们不仅可以使用int来表示一个int整数，而且也可以使用别名作为类型名称了：\n#include \u0026lt;stdio.h\u0026gt; typedef int lbwnb; int main() { lbwnb i = 666; //类型名称直接写成别名，实际上本质还是int printf(\u0026#34;%d\u0026#34;, i); } typedef const char * String; //const char * 我们就起个名称为String表示字符串 int main() { String str = \u0026#34;Hello World!\u0026#34;; //是不是有Java那味了 printf(str); } 当然除了这种基本类型之外，包括指针、结构体、联合体、枚举等等都可以使用这个关键字来完全起别名操作：\n#include \u0026lt;stdio.h\u0026gt; typedef struct test { int age; char name[10]; } Student; //为了方便可以直接写到后面，当然也可以像上面一样单独声明 int main() { Student student = {18, \u0026#34;小明\u0026#34;}; //直接使用别名，甚至struct关键字都不用加了 } 在数据结构的学习总，typedef使用会更加地频繁。\n预处理 虽然我们的C语言学习已经快要接近尾声了，但是有一个东西迟迟还没有介绍，就是我们一直在写的：\n#include \u0026lt;stdio.h\u0026gt; 这到底是个什么东西，为什么每次都要加上呢？这一部分，我们将详细讨论它缘由。\n#include实际上是一种预处理指令，在我们的程序运行之前，会有一个叫做\u0026quot;C预处理器\u0026quot;的东西，根据我们程序中的预处理指令，预处理器能把对应的指令替换为指令想要表示的内容。我们先来看看#include做了什么。\n文件包含 当预处理器发现#include指令时，会查看后面的文件名并把文件的内容包含到当前文件中，来替换掉#include指令。比如：\nint main() { printf(\u0026#34;Hello World!\u0026#34;); //一个很普通的printf打印函数 } 我们说了，这个函数是由系统为我们提供的函数，实际上这个函数实在其他源文件中定义好的，而定义这个函数的源文件，就是stdio.h，我们可以点进去看看：\n除了printf之外，我们看到还有很多很多的函数原型定义，他们都写到这个源文件中，而这个文件并不是以.c结尾的，而是以.h结尾的，这种文件我们称为头文件。头文件一般仅包含定义一类的简单信息，只要能让编译器认识就行了。\n而#include则是将这些头文件中提供的信息包含到我们的C语言源文件中，这样我们才能使用定义好的printf函数，如果我们不添加这个指令的话，那么会：\n直接不认识了，printf是啥，好吃吗？说白了就是，我们如果不告诉编译器我们的这个函数是从哪来的，它怎么知道这个函数的具体定义什么是，程序又该怎么执行呢？\n#include的具体使用格式如下：\n#include \u0026lt;文件名称\u0026gt; 当然也可以写成：\n#include \u0026#34;文件名称\u0026#34; 这两种写法虽然都能引入头文件，但是区别还是有的：\n**尖括号：**引用的是编译器的库路径里面的头文件。 **双引号：**引用的是程序目录中相对路径中的头文件，如果找不到再去上面的库里面找。 可以看到系统已经为我们提供好了多种多样的头文件了，通过这些系统提供的库，我们就可以做很多的事情了。\n当然我们也可以自己编写一个头文件，直接在项目根目录下创建一个新的C/C++头文件：\n// // Created by Nago Coler on 2023/6/26. // #ifndef UNTITLED_TEST_H #define UNTITLED_TEST_H #endif //UNTITLED_TEST_H 可以看到系统自动为我们生成好了这些内容，只不过现在还没学到（后面会介绍），现在直接删掉：\nint test(int a, int b); 我们直接在头文件中随便声明一个函数原型，接着我们就可以引入这个头文件了：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;test.h\u0026#34; //因为是我们自己项目目录中的，所以需要使用双引号 int main() { int c = test(1, 2); //这样就可以使用头文件中声明的函数了 } 通过导入头文件，我们就可以使用定义好的各种内容了，当然，不仅仅局限于函数。\n不过现在还没办法执行，因为我们这里只是引入了头文件中定义的函数原型，具体的函数实现我们一般还是使用.c源代码文件去进行编写，这里我们创建一个同名的C源文件（不强制要求同名，但是这样看着整齐一点）去实现一下：\n#include \u0026#34;test.h\u0026#34; //这里也需要把定义引入 int test(int a, int b) { //编写函数具体实现 return a + b; } 这样，我们再次运行程序就可以正确得到结果了：\n实际上预处理器正是通过头文件得到编译代码时所需的一些信息，然后才能把我们程序需要的内容（比如这里要用到的test函数）替换到我们的源文件中，最后才能正确编译为可执行程序。\n比如现在我们要做一个学生管理库，这个库中提供了学生结构体的定义，以及对学生信息相关操作：\nstruct stu { //学生结构体定义 int id; int age; char name[20]; } typedef Student; void print(Student * student); //打印学生信息 void modifyAge(Student * student, int newAge); //修改年龄 void modifyId(Student * student, int newId); //修改学号 #include \u0026lt;stdio.h\u0026gt; //函数具体实现源文件 #include \u0026#34;student.h\u0026#34; void print(Student * student) { printf(\u0026#34;ID: %d, 姓名: %s, 年龄: %d岁\\n\u0026#34;, student-\u0026gt;id, student-\u0026gt;name, student-\u0026gt;age); } void modifyAge(Student * student, int newAge) { student-\u0026gt;age = newAge; } void modifyId(Student * student, int newId) { student-\u0026gt;id = newId; } 最后我们就可以愉快地使用了：\n#include \u0026#34;student.h\u0026#34; int main() { Student student = {1, 18, \u0026#34;小明\u0026#34;}; modifyAge(\u0026amp;student, 19); print(\u0026amp;student); //打印 } 通过使用#include我们就可以将我们的项目拆分成多个模块去进行编写了。\n系统库介绍 前面我们了解了如何使用#include引入其他文件，我们接着来了解一下系统为我们提供的一些常用库。实际上我们已经用过不少官方库提供的内容了：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\u0026#34;, a); getchar(); putchar(\u0026#39;A\u0026#39;); ... } 包括前面我们在实战中用到了一次string.h中提供的计算字符串长度的函数：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char * c = \u0026#34;Hello World!\u0026#34;; printf(\u0026#34;%lu\u0026#34;, strlen(c)); //使用strlen计算长度，注意返回值类型是size_t（别名而已，本质上就是unsigned long） } 当然除了这个函数之外，实际上还有很多实用的字符串处理函数，都在这里定义了：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char a[20] = \u0026#34;Hello\u0026#34;,* b = \u0026#34;World!\u0026#34;; //现在有两个字符串，但是我们希望把他们拼接到一起 //注意不能这样写 char * a = \u0026#34;Hello\u0026#34;,* b = \u0026#34;World!\u0026#34;; 如果直接用指针指向字符串常量，是无法进行拼接的，因为大小已经固定了 //这里需要两个参数，第一个是目标字符串，一会会将第二个参数的字符串拼接到第一个字符串中（注意要装得下才行） strcat(a, b); printf(\u0026#34;%s\u0026#34;, a); } int main() { char str[10], * c = \u0026#34;Hello\u0026#34;; strcpy(str, c); //使用cpy会直接将后面的字符串拷贝到前面的字符串数组中（同样需要前面装得下才行） printf(\u0026#34;%s\u0026#34;, str); } int main() { char * a = \u0026#34;AAA\u0026#34;, * b = \u0026#34;AAB\u0026#34;; int value = strcmp(a, b); //strcmp会比较两个字符串，并返回结果 printf(\u0026#34;%d\u0026#34;, value); } 这里需要说一下的比较规则：把字符串str1和str2从首字符开始逐个字符的进行比较，直到某个字符不相同或者其中一个字符串比较完毕才停止比较，字符的比较按照ASCII码的大小进行判断。\n比较完成后，会返回不匹配的两个字符的ASCII码之差：\n我们接着来看用于处理数学问题的相关库：\n#include \u0026lt;math.h\u0026gt; 这里要用到math.h，它提供了我们场景的数学计算函数，比如求算术平方根、三角函数、对数等。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main() { int a = 2; double d = sqrt(a); //使用sqrt可以求出非负数的算术平方根（底层采用牛顿逼近法计算） printf(\u0026#34;%lf\u0026#34;, d); } 当然能够开根，也可以做乘方：\nint main() { int a = 2; double d = pow(a, 3); //使用pow可以快速计算乘方，这里求的是a的3次方 printf(\u0026#34;%lf\u0026#34;, d); } 有了这个函数，写个水仙花数更简单了：\nint main() { for (int i = 0; i \u0026lt; 1000; ++i) { int a = i % 10, b = i / 10 % 10, c = i / 10 / 10; if(pow(a, 3) + pow(b, 3) + pow(c, 3) == i) { printf(\u0026#34;%d 是水仙花数！\\n\u0026#34;, i); } } } 当然也可以计算三角函数：\nint main() { printf(\u0026#34;%f\u0026#34;, tan(M_PI)); //这里我们使用正切函数计算tan180度的值，注意要填入的是弧度值 //M_PI也是预先定义好的π的值，非常精确 } 当然某些没有不存在的数可能算出来会得到一个比较奇怪的结果：\nint main() { printf(\u0026#34;%f\u0026#34;, tan(M_PI / 2)); //这里计算tan90°，我们知道tan90° = sin90°/cos90° = 1/0 不存在 } 当然还有两个比较常用的函数：\nint main() { double x = 3.14; printf(\u0026#34;不小于x的最小整数：%f\\n\u0026#34;, ceil(x)); printf(\u0026#34;不大于x的最大整数：%f\\n\u0026#34;, floor(x)); } 当然也有快速求绝对值的函数：\nint main() { double x = -3.14; printf(\u0026#34;x的绝对值是：%f\u0026#34;, fabs(x)); } 我们最后再来介绍一下通用工具库stdlib，这个库里面为我们提供了大量的工具函数：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int arr[] = {5, 2, 4, 0, 7, 3, 8, 1, 9, 6}; //工具库已经为我们提供好了快速排序的实现函数，直接用就完事 //参数有点多，第一个是待排序数组，第二个是待排序的数量（一开始就是数组长度），第三个是元素大小，第四个是排序规则（我们提供函数实现） qsort(); } 当然在开始使用之前我们还要先补充一点知识，我们发现qsort的原型定义，使用的是void类型的指针。\n怎么void还有指针呢？void不是空吗？\nvoid 指针是一种特殊的指针，表示为“无类型指针”，由于 void 指针没有特定的类型，因此它可以指向任何类型的数据。也就是说，任何类型的指针都可以直接赋值给 void 指针，而无需进行其他相关的强制类型转换。\n所以这里之所以需要void指针，其实就是为了可以填入任何类型的数组，而我们发现第三个参数实际上就是因为是void指针不知道具体给进来的类型是什么，所以需要我们来告诉函数我们使用的类型所占大小是多少。\n而最后一个参数实际上就是我们前面介绍的函数回调了，因为函数不知道你的比较规则是什么，是从小到大还是从大到小呢？所以我们需要编写一个函数来对两个待比较的元素进行大小判断。\n好了，现在了解了之后，我们就可以开始填入参数了：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int compare(const void * a, const void * b) { //参数为两个待比较的元素，返回值负数表示a比b小，正数表示a比b大，0表示相等 int * x = (int *) a, * y = (int *) b; //这里因为判断的是int所以需要先强制类型转换为int *指针 return *x - *y; //其实直接返回a - b就完事了，因为如果a比b大的话算出来一定是正数，反之同理 } int main() { int arr[] = {5, 2, 4, 0, 7, 3, 8, 1, 9, 6}; //工具库已经为我们提供好了快速排序的实现函数，直接用就完事 //参数有点多，第一个是待排序数组，第二个是待排序的数量（一开始就是数组长度），第三个是元素大小，第四个是排序规则（我们提供函数实现） qsort(arr, 10, sizeof(int), compare); for (int i = 0; i \u0026lt; 10; ++i) { printf(\u0026#34;%d \u0026#34;, arr[i]); } } 这样，我们就可以对数组进行快速排序了。\n当然工具库中还提供了exit函数用于终止程序：\n#include \u0026lt;stdlib.h\u0026gt; int main() { exit(EXIT_SUCCESS); //直接终止程序，其中参数是传递给父进程的（但是现在我们只是简单程序） } 不过乍一看，貌似和我直接在main里面return没啥区别，反正都会结束。\n当然还有两个我们会在后续学习数据结构中用的较多的函数：\nint main() { int * p = (int *) malloc(sizeof(int)); //我们可以使用malloc函数来动态申请一段内存空间 //申请后会返回申请到的内存空间的首地址 *p = 128; printf(\u0026#34;%d\u0026#34;, *p); } malloc用于向系统申请分配指定size个字节的内存空间，返回类型是 void * 类型，如果申请成功返回首地址，如果失败返回NULL空地址（比如系统内存不足了就可能会申请失败）\n申请到一段内存空间后，这段内存空间我们就可以往上面随便读写数据了，实际上就是和变量一样，只不过这个内存空间是我们自主申请的，并不是通过创建变量得到的，但是使用上其实没啥大的区别。\n不过要注意，这段内存使用完之后记得清理，就像函数执行完会自动销毁其中的局部变量一样，如果不清理那么这段内存会被一直占用：\nint main() { int * p = (int *)malloc(sizeof(int)); *p = 128; printf(\u0026#34;%d\u0026#34;, *p); free(p); //使用free函数对内存空间进行释放，归还给系统，这样这段内存又可以被系统分配给别人用了 p = NULL; //指针也不能再指向那个地址了，因为它已经被释放了 } 内存资源是很宝贵的（不像硬盘几个T随便用，我们的电脑可能32G的内存都算高配了），不能随便浪费，所以一般情况下malloc和free都是一一对应的，这样才能安全合理地使用内存。\n宏定义 我们前面认识了#include指令，我们接着来看#define指令，它可以实现宏定义。我语文不好，宏是啥意思？\n把参数批量替换到文本中，这种实现通常称为宏（macro）或定义宏 (define macro)\n我们可以通过#define来定义宏，规则如下：\n#define 宏名(记号) 内容 比如现在我们想通过宏定义一个PI：\n#define PI 3.1415926 这样就可以了，那么怎么去使用它呢？\n#include \u0026lt;stdio.h\u0026gt; #define PI 3.1415926 int main() { printf(\u0026#34;π的值为：%f\u0026#34;, PI); //就像使用变量一样，我们可以直接将PI放到这个位置 } 在编译时，预处理程序会进行宏替换操作，也就是将程序中所有的PI全部替换为3.1415926，注意这个跟类型无关，是赤裸裸的纯文本替换，也就是相当于把我们的代码修改了，PI那里直接变成3.1415926，当然如果你定义为其他任意的内容，同样会替换到那个位置，但是至于替换之后程序还正不正常就不知道了。\n我们通过下面这个例子来加深对文本替换这句话的理解：\n#include \u0026lt;stdio.h\u0026gt; #define M a + b int main() { int a = 10, b = 20; printf(\u0026#34;%d\u0026#34;, M * a); //各位觉得计算结果会是多少呢？ } 如果按照我们的正常思维，M是a+b，那么替换上去之后应该就是30了吧？然后30 x 10最后得到的应该是300才对。\n不过最后貌似并不是这样的，怎么会算出来是210的呢？\n实际上还是那句话，在编译时仅仅是做了文本替换，相当于最后我们的代码是：\nprintf(\u0026#34;%d\u0026#34;, a + b * a); 所以先计算的是a x b然后再加a，最后结果就是210了。\n当然任何地方都可以使用宏替换，包括类型，反正最后都会变成被替换的内容：\n#define lbwnb long int main() { lbwnb a = 10L; } 当然除了这种简单的替换之外我们还可以添加参数，就像函数那样：\n#include \u0026lt;stdio.h\u0026gt; #define MUL(x) x * x int main() { printf(\u0026#34;%d\u0026#34;, MUL(9)); } 虽然这里搞得像函数一样，但是最后还是会被替换为x * x，而这个x就是我们填写的参数，所以最后会变成 9 * 9 替换上去，程序运行出来的结果就是81了。\n直接调函数肯定也是没问题的，反正就纯替换：\n#include \u0026lt;stdio.h\u0026gt; #define bb(i) printf(\u0026#34;我是宏替换的：%d\u0026#34;, i); int main() { bb(666); } 那要是我想在字符串里面加一个宏定义中的参数呢？\n#include \u0026lt;stdio.h\u0026gt; #define bb(str) printf(\u0026#34;我是宏替换的：\u0026#34;#str\u0026#34; \u0026lt;\u0026#34;); //使用#直接在字符串中进行宏替换，否则默认情况下会被当做一个字符 int main() { bb(\u0026#34;你看这不就替换了吗\u0026#34;); } 当然还可以替换宏中的部分：\n#define TEST(n) x ##n //##会使用参数进行拼接 int main() { int TEST(1) = 10; //这里传入1，那么实际上就是被替换为x1 x1 = 20; //所以上面其实是int x1 = 10 } 宏既然可以定义出来，那么也可以取消定义，我们可以使用#undef来取消已有的宏定义：\n可以看到在使用#undef之后，直接不认识了。\n当然除了我们自己可以去定义之外，系统也为我们提供了一些预定义的宏：\n宏名称 含义 _ _ DATE _ _ 当前的日期，格式为类似 Jun 27 2023 的字符串 _ _ TIME _ _ 当前的时间，格式为类似 10:23:12 的字符串 _ _ FILE _ _ 当前源代码文件的名称（含路径）的字符串 _ _ LINE _ _ 当前所处的行号是多少就替换为多少，整数 这里只列出了一部分。\n条件编译 我们来看看条件编译，我们还可以根据条件，选择性地对某些内容进行忽略。\n收我们我们来认识一下#ifdef、#else、#endif这三种条件编译指令：\n#include \u0026lt;stdio.h\u0026gt; #ifdef PI //ifdef用于判断是否定义了符号PI，如果没有的话则处理以下的指令 #define M 666 #else //如果定义了符号PI，那么就处理这个分支的语句 #define M 777 #endif //最后需要以endif指令结束整个判断 int main() { printf(\u0026#34;%d\u0026#34;, M); //最后打印M } 可以看到，在我们没有定义PI的情况下，执行的是#define M 777，那要是现在定义了呢？我们编写一个新的头文件：\n#define PI 3.1415 现在我们引入这个头文件，那么对应的预编译指令也会跟着包含进来：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;test.h\u0026#34; #ifdef PI #define M 666 #else #define M 777 #endif int main() { printf(\u0026#34;%d\u0026#34;, M); } 可以看到此时得到的结果就是666了，因为现在PI在引入的头文件中已经定义了（当然直接在当前源文件中定义也是一样的）\n那如果我现在希望判断某个符号没定义呢？没错，还有#ifndef表示判断是否未定义某个符号：\n#include \u0026lt;stdio.h\u0026gt; #ifndef PI //ifndef 就是 if not define，跟ifdef反着的 #define M 666 #else #define M 777 #endif int main() { printf(\u0026#34;%d\u0026#34;, M); } 当然，除了判断某个符号是否存在之外，我们也可以像条件语句那样直接进行逻辑判断，这里需要使用到#if和#elif指令：\n#define M 666 #if M == 666 //若M等于666那么定义K = 999 #define K 999 #elif M == 777 //等同于else if语句 #define K 888 #else //else语句 #define K 000 #endif 并且这些分支还支持嵌套使用：\n#define M 666 #if M == 666 #ifdef L #include \u0026#34;test.h\u0026#34; #endif #elif M == 777 #define K = 888 #else #define K = 000 #endif 文件输入/输出（选学） **注意：**本小节作为选学内容，不强制要求。\n我们的电脑上其实存放了多种多样的文件，比如我们办公经常需要打交道的Word文档、PPT幻灯片、Excel表格等，包括我们的C程序源文件，图片、视频等等，这些都是文件，由于文件需要被长期保存，所以它们被统一存放到我们电脑上的硬盘中。硬盘不像内存，虽然它们都可以存放数据，但是内存中的数据断电即失（在学习完数字电路中的锁存器后，你就知道为什么了）而硬盘却支持长期保存数据，当然也是以二进制的形式进行保存的。\n文本读写操作 现代计算机使用的硬盘大致分为固态硬盘和机械硬盘两种，其中固态硬盘的读写速度远超机械硬盘，但是寿命（硬盘是有读写次数限制的，如果读写次数超标，那么就无法使用了）不如机械硬盘，所以一般重要数据都是在机械硬盘中存放，而系统文件一般是在固态硬盘中存放，这样电脑的启动速度会很快。\n不过文件并不是随便在硬盘中进行保存的，而是根据不同的文件系统按规则进行存放的，比如Windows下采用的就是NTFS文件系统，而MacOS采用的是APFS文件系统。\n文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。\n其中某些文件是以文本格式存储的，比如我们的C语言源文件、普通的文本文档等；而有些文件是二进制格式，比如图片、视频、应用程序等，但是他们最终都是以二进制的形式存储到硬盘上的。当然，普通的文本文件我们直接打开记事本都可以直接进行编辑，而图片这类二进制文件，需要使用专门读取图片的软件来查看，根据格式的不同（图片有png、jpg等格式）对文件的解读方式也不一样，但是最后都会被专门的图片查看软件展示出来。\n通过使用C语言，我们也可以读取硬盘上的文件，这里我们先创建一个简单的文本文件：\n接着我们可以使用stdio.h中为我们提供的函数打开一个文件：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;rw\u0026#34;); //使用fopen函数来打开一个文件 } 这里我们先来介绍一下参数：\n第一个参数：文件的名称，这里我填写的是相对路径，也可以写成绝对路径 第二个参数：打开文件的模式，其中模式有以下这些： 模式字符串 含义 “r” 以读模式打开文件 “w” 以写模式打开文件，把现有文件的长度截为0，如果文件不存在，则创建一个新文件 “a” 以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件 “r+” 以更新模式打开文件（即可以读写文件）该文件必须存在 “w+” 以更新模式打开文件（即可以读写文件），如果文件存在，则将其长度截为0；如果文件不存在，则创建一个新文件 “a+” 以更新模式打开文件（即，读写），在现有文件的末尾添加内容，如果文件不存在则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 “rb”,“wb”,“ab”,“ab+”,“a+b”,“wb+”,“w+b” 与“a+”模式类似，但是以二进制模式打开文件而不是以文本模式打开文件 具体的不同打开模式会影响到后续的操作，我们后面再说。这里我们使用r表示可读。\n然后这个函数返回的是一个FILE结构体指针：\ntypedef struct __sFILE { unsigned char *_p; /* current position in (some) buffer */ int _r; /* read space left for getc() */ ... } FILE; 定义非常复杂，这里我们就不详细介绍了，这样我们就成功打开了这个文件，那么如何对文件进行读取操作呢？\n我们可以使用getc来快速读取文件中的字符：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;r\u0026#34;); int c; while ((c = getc(file)) != EOF) { //通过一个while循环来不断读取文件，使用getc从文件中读取一个字符，如果到末尾了，那么会返回一个特殊值EOF putchar(c); //使用putchar来快速打印字符到控制台 } } 可以看到成功输出：\n当然如果没有这个文件或是文件打开失败的话，可能会返回一个空指针，所以我们需要进一步判断：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;r\u0026#34;); if(file != NULL) { //如果打开失败会返回NULL int c; while ((c = getc(file)) != EOF) { putchar(c); } } else{ puts(\u0026#34;文件打开失败！\u0026#34;); } } 最后我们在使用完文件后，记得关闭文件来释放资源，不然一直会被占用：\nfclose(file); //fclose用于关闭文件 那么读取文件我们知道了，写入呢？写入我们同样可以使用putc来完成：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;w\u0026#34;); //注意这里需要修改为写模式 if(file != NULL) { for (int i = 0; i \u0026lt; 10; ++i) putc(\u0026#39;A\u0026#39; + i, file); //从A开始依次写入10个字符 fclose(file); } else{ puts(\u0026#34;文件打开失败！\u0026#34;); } } 可以看到最后我们的文件变成了：\n原来的文本被覆盖为了我们输入的新文本，那要是我们现在不想覆盖原来的，而是希望在后面追加输入呢？\nFILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;a\u0026#34;); //我们可以将其修改为a表示append追加输入 这样就不会覆盖原有内容而是追加填写了：\n不过这里要补充一下，文件的读写实际上并不是直接对文件进行操作的，在这之间还有一个缓冲区：\n我们所有的读操作，首先是从文件读取到缓冲区中，再从缓冲区中读取到程序中的；写操作就是先写入到缓冲区，然后再从缓冲区中写入到文件中。这样做的目的是，因为内存和硬盘的速度差距有点大，为了解决这种速度差异导致的性能问题，所以设定一个缓冲区，这样就算速度不一样，但是内容被放在缓冲区中慢慢消化就没问题了。\n虽然缓冲区能够解决这些问题，但是也会带来一些不便之处，比如下面的例子：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;a+\u0026#34;); //注意这里需要修改为写模式 if(file != NULL) { while (1) { int c = getchar(); //不断从控制台读取字符 if(c == \u0026#39;q\u0026#39;) break; putc(c, file); //写入到文件中 } fclose(file); } } 我们发现当我们敲了一个字符之后，可能并不会马上更新到文件中，这就是由于缓冲区没有及时同步到文件中，所以我们需要调用一个函数来刷新缓冲区，将那些缓冲区的没有同步的数据全部同步到文件中：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;a+\u0026#34;); if(file != NULL) { while (1) { int c = getchar(); if(c == \u0026#39;q\u0026#39;) break; putc(c, file); fflush(file); //使用fflush来刷新缓冲区 } fclose(file); } } 这样我们就可以看到输入一个字符马上就能同步更新了。当然我们也可以手动设定缓冲区的大小：\nchar buf[3]; setvbuf(file, buf, _IOFBF, 3); 其中：\n_IONBF：表示不使用缓冲区 _IOFBF：表示只有缓冲区填满了才会更新到文件 _IOLBF：表示遇到换行就更新到文件 除了使用getc之外，标准库中还提供了fprintf和fgets系列函数：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;a+\u0026#34;); if(file != NULL) { fprintf(file, \u0026#34;树脂%d\u0026#34;, 666); //fprintf就像普通的打印一样，但是它并不是打印到控制台，而是文件中 fclose(file); } } #include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;w\u0026#34;); if(file != NULL) { fputs(\u0026#34;小黑子苏珊\u0026#34;, file); //就像使用puts一样，同样是输出到文件中 fclose(file); } } 这样，对于文本文件的基础读写操作就讲解到这里。\n随机访问 前面我们介绍了文本文件的基础读写操作，我们接着来看随机访问。首先什么是随机访问？\n我们在前面读取文件时，实际上是按照顺序，每次读取都会往后移动一个字符继续读取，那么如果现在我希望直接跳到某个位置进行读取是否可以实现呢？\n我们可以使用fseek来跳转到指定位置：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;r\u0026#34;); if(file != NULL) { fseek(file, -2L, SEEK_SET); //第二个参数为偏移量，根据后面的参数而定 putchar(getc(file)); fclose(file); } } 这里介绍一下起始点：\nSEEK_SET：从文件开始处开始 SEEK_CUR：从当前位置开始（就是已经读到哪个位置就是哪个位置） SEEK_END：从文件末尾开始 而上面的使用的是SEEK_SET，那么就是从文件开始，往后偏移2个字符的位置，也就是字符l。\n那么我们怎么知道当前已经读取到文件第几个字符了呢？\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;r\u0026#34;); if(file != NULL) { fseek(file, 2L, SEEK_SET); printf(\u0026#34;%ld\u0026#34;, ftell(file)); //可以使用ftell来直接返回当前位置，返回类型为long fclose(file); } } 当然除了fseek和ftell之外，还有fgetpos和fsetpos这两个函数，它们也可以获取位置和设定位置：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;r\u0026#34;); if(file != NULL) { fpos_t pos; //位置需要使用fpos_t进行存储（主要用于处理大文件） fgetpos(file, \u0026amp;pos); //获取位置，并设定给pos，此时位置为0 fseek(file, -2L, SEEK_END); //通过fseek移动到倒数第二个位置 fsetpos(file, \u0026amp;pos); //设定位置为pos位置 printf(\u0026#34;%ld\u0026#34;, ftell(file)); //最后得到的就是经过fsetpos设定的新位置了 fclose(file); } } 了解了这些函数，这样我们就可以实现对文件的随机读写了。\n前面我都是对文本文件进行操作，我们接着来看如何直接读写二进制文件，比如现在我们想要复制一个文件：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;hello.txt\u0026#34;, \u0026#34;r\u0026#34;); FILE * target = fopen(\u0026#34;hello2.txt\u0026#34;, \u0026#34;w\u0026#34;); if(file != NULL) { char buf[1024]; //这里我们使用char类型的数组作为暂存 size_t s; while ((s = fread(buf, sizeof(char), 1024, file)) \u0026gt; 0) { //使用fread函数进行读取，每次都会从文件中读取指定大小的数据到暂存数组中，返回值为实际读取的值，如果读取的值小于0表示读完了 fwrite(buf, sizeof(char), s, target); //使用fwrite将数据写入到指定文件中 } fclose(file); } } 可以看到我们成功将hello.txt中的内容复制到另一个文本文件中了。当然我们也可以用来拷贝大型文件：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * file = fopen(\u0026#34;22000.318.211104-1236.co_release_svc_refresh_CLIENTCONSUMER_RET_A64FRE_zh-cn.iso\u0026#34;, \u0026#34;r\u0026#34;); FILE * target = fopen(\u0026#34;22000.318.211104-1236.co_release_svc_refresh_CLIENTCONSUMER_RET_A64FRE_zh-cn-2.iso\u0026#34;, \u0026#34;w\u0026#34;); if(file != NULL) { //计算文件的大小 fseek(file, 0L, SEEK_END); long size = ftell(file); fseek(file, 0L, SEEK_SET); char buf[1024 * 1024]; size_t s, all = 0; while ((s = fread(buf, sizeof(char), 1024, file)) \u0026gt; 0) { fwrite(buf, sizeof(char), s, target); all += s; printf(\u0026#34;当前进度 %.1f%%\\n\u0026#34;, (double) all / (double) size * 100); } fclose(file); } } 是不是感觉有内味了：\n这样我们就实现了文件的拷贝。\n程序编译和调试（选学） **注意：**本小节作为选学内容，不强制要求。\n有关C语言语言层面的教学基本就结束了，最后让我们来了解一下如何不借助IDE，通过最原始的方式手动完成程序的编译。\nC语言程序的编译 在开始之前，我们需要介绍一个编译器：\nGCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）\n那么gcc编译器是如何将我们的程序一步步编译为可执行文件的呢？\n预处理（Pre-Processing）：首先会经过预处理器将程序中的预编译指令进行处理，然后把源文件中的注释这些没用的东西都给扬了。 编译（Compiling）：处理好之后，就可以正式开始编译，首先会编译为汇编代码。 汇编（Assembling）：接着就该将汇编代码编译为机器可以执行的二进制机器指令了，会得到一个二进制目标文件。 链接（Linking）：最后需要将这个二进制目标文件与系统库和其他库的OBJ文件、库文件链接起来，最终生成了可以在特定平台运行的可执行文件。 比如在Windows操作系统下完成这四步，就会生成一个Windows的.exe可执行文件。\n我们来一步一步尝试一下，首先我们把CLion自带的GCC工具目录配置到环境变量中（Mac系统直接自带，不需要任何配置）：\n位置在你的CLion安装目录/bin/mingw/bin，打开高级系统设置，添加环境变量：\n配置完成后，打开CLion，我们随便编写一点内容：\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, World!\\n\u0026#34;); return 0; } 然后我们点击IDE下方的终端面板：\n可以看到这里打开的是Windows自带的PowerShell终端，如果不是的可以在设置中修改：\n现在我们就可以手动开始对我们的C源文件进行编译了，首先是第一步，我们需要对源文件进行预处理：\ngcc -E main.c -o main.i 其中 -E 后面的是我们的源文件名称，-o 是我们预处理后生成的文件名称：\n生成后，我们可以直接查看这个文件（因为此时依然是普通文本）可以看到，我们的代码在经过预处理之后，#include \u0026lt;stdio.h\u0026gt;中的内容都替换过来了。最下面大约1000行左右的位置就是我们的代码了：\n现在我们已经完成了预处理，接着就可以将其编译为汇编程序了：\ngcc -S main.i -o main.s 这里的-S就是预处理之后的文件，我们可以直接将其编译为汇编代码：\n可以看到这里都是汇编代码，各种各样的汇编指令。接着我们就可以将这个汇编代码继续编译为二进制文件了：\ngcc -c main.s -o main.o 这里-c后的就是我们的汇编程序，直接生成为二进制文件：\n不过现在我们还没办法直接运行它，因为还需要进一步链接，变成Windows操作系统可以执行的程序：\ngcc main.o -o main 这里直接将刚刚生成的目标文件编译为可执行文件，我们就可以直接运行了：\n成功生成.exe文件，我们直接在控制台输入它的名字就可以运行了：\n这样我们就实现了手动编译一个C语言程序。当然如果我们要更快速一点地完成编译，可以直接将源文件进行编译：\ngcc main.c -o main 当然这种只是简单的单源文件下的编译，要是遇到多文件的情况下呢？\nvoid swap(int * a, int * b); #include \u0026#34;test.h\u0026#34; void swap(int * a, int * b) { int tmp = *a; *a = *b; *b = tmp; } #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;test.h\u0026#34; int main() { int arr[] = {4, 2, 1, 9, 5, 0, 3, 8, 7, 6}; for (int i = 0; i \u0026lt; 9; ++i) { for (int j = 0; j \u0026lt; 9 - i; ++j) { if(arr[j] \u0026gt; arr[j + 1]) swap(\u0026amp;arr[j], \u0026amp;arr[j + 1]); } } for (int i = 0; i \u0026lt; 10; ++i) { printf(\u0026#34;%d \u0026#34;, arr[i]); } } 我们还是按照刚刚的方式直接进行编译：\n可以看到，编译错误，无法识别到swap这个函数，说明肯定还需要把引入的其他文件也给一起带上，所以：\ngcc main.c test.c -o main 或是将两个文件单独编译为对应的二进制文件，最后再放到一起编译也是可以的：\ngcc main.o test.o -o main OK，现在多个文件就可以在一起编译了，最后同样生成了一个可执行文件：\n使用Make和CMake进行构建 我们的项目可能会有很多很多的内容需要去进行编译，如何去进行组织成了一个大问题，比如让谁先编译，谁后编译，这时，我们就需要一个构建工具来帮助我们对程序的构建流程进行组织。\nMake是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。\n要使用Make对我们的项目进行构建，我们需要先告诉Make我们的程序应该如何去进行构建，这时我们就要编写一下Makefile了：\n我们只需要把需要执行的命令按照我们想要的顺序全部写到里面就可以了，但是需要遵循以下格式：\ntargets : prerequisites command 一个Makefile中可以有很多个目标，比如我们现在要分别编译main.c和test.c，那么就需要创建两个目标：\ntargets：构建的目标，可以是一个普通的标签、文件名称等 prerequisites：前置条件，可以设定要求完成其他目标才能开始构建当前目标 command：构建需要执行的命令 比如现在我们想要分别先编译test.c和main.c，最后将他们变成一个可执行文件，那么makefile可以这样编写：\nmain.exe: test.o main.o #目标1：构建最终的程序，要求完成下面两个目标（注意最终目标需要写在第一个） gcc test.o main.o -o main main.o: main.c #目标2：构建目标为main.o，前置要求必须有main.c文件 gcc -E main.c -o main.i gcc -S main.i -o main.s gcc -c main.s -o main.o test.o: test.c #目标3：同样的，要求必须有test.c文件才能开始 gcc -E test.c -o test.i gcc -S test.i -o test.s gcc -c test.s -o test.o 接着我们只需要在控制台输入make命令（CLion自带环境需要输入mingw32-make命令，Mac下直接输入make）就可以进行编译了：\n命令执行的每一步都会详细打印出来，我们可以看到构建确实是按照我们的顺序在进行，并且成功编译出最终目标：\n当然，如果我们没有做任何的修改，那么再次执行make命令不会做任何事情：\n但是如果我们修改一下源文件的话，执行make将会重新构建目标：\n再次执行：\n通过使用Make，即使没有如此高级的IDE，哪怕我们纯靠记事本写C代码，都可以很方便地完成对一个项目的构建了。当然这只是Make的简单使用，它还支持使用变量、逻辑判断等高级玩法，这里我们就不多做介绍了。\n虽然使用Make可以很方便地对项目构建流程进行配置，但是貌似CLion并没有采用这种方式来组织我们的项目进行构建，而是使用了CMake，我们来看看它又是做什么的。\nCMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。\n简而言之， CMake是一个跨平台的Makefile生成工具!\n实际上当我们创建一个项目后，CLion会自动为我们配置CMake，而具体的配置都是写在CMakeList.txt中的：\ncmake_minimum_required(VERSION 3.22) project(untitled C) set(CMAKE_C_STANDARD 99) add_executable(untitled main.c test.c test.h) 我们逐行来进行解读：\n第一行使用cmake_minimum_required来指定当前项目使用的CMake最低版本，如果使用的CMake程序低于此版本是无法构建的。 第二行project指定项目名称，名称随意，后面的是项目使用的语言，这里是C。 第三行set用于设定一些环境变量等，这里设定的是C 99标准。 第四行add_executable用于指定一个编译出来的可执行文件，这里名称为untitled，后面的都是需要编译的源文件（头文件可以不写） 当然除了这些语法之外，还有各种各样的设定，比如设定库目录或是外部动态连接库等，这里就不多说了，感兴趣的可以自行了解。\n这里我们来手动执行一下cmake：\n首先还是添加环境变量，添加完成后重启CLion，我们输入cmake命令进行生成：\ncmake -S . -B test -G \u0026#34;MinGW Makefiles\u0026#34; 其中-S后面的是源文件目录，这里.表示当前目录，-B后面是构建目录，一会构建的文件都在这里面存放，最后-G是选择生成器（生成器有很多，甚至可以直接生成一个VS项目，我们可以直接使用Visual Studio打开），这里我们需要生成Makefile，所以填写\u0026quot;MinGW Makefiles\u0026quot;：\n可以看到已经成功在我们的构建目录中生成了：\n只不过它这个自动生成的Makefile写的就比较复杂了，我们也不需要去关心，接着我们像之前一样直接使用make就可以编译了：\n这里要先进入一下test目录，使用cd test命令修改当前工作目录：\n可以看到它生成的Makefile还是挺高级的，还能输出进度，现在我们的程序就构建好了，直接启动把：\n当然CLion并没有使用Makefile的编译方式，而是Ninja，并且生成的构建文件默认存放在cmake-build-debug中，跟make比较类似，但是速度会更快一些，不过最后都会成功构建出我们的可执行程序。\n这下，我们就清楚整个项目中个个文件是干嘛的了。\n使用LLDB调试工具 最后我们来说一下LLDB调试工具（与之类似的还有GDB），首先还是配置一下环境变量：\nLLDB调试工具用于对我们的程序进行逐步调试使用，实际上我们之前也使用调试，只不过是在IDE中的图形化界面中操作的，那么如果没有IDE呢，我们可以使用LLDB调试工具来进行调试：\nlldb .\\untitled.exe 注意在编译时需要需要添加-g参数来附带调试信息，这样才可以使用gdb进行调试，否则不能（CLion默认生成的是可以调试的程序，所以直接使用就行了）\n进入后，可以看到是这样的一个界面，我们需要输入命令来进行逐步调试，输入r就可以开始运行了：\n成功运行出结果，那么具体怎么进行断点调试呢？我们可以使用b 行号的形式在对应的行号打上断点，比如这里对第9行进行断点：\n接着我们再输入r之后，程序会暂时卡在断点位置，此时我们可以通过输入v来查看当前所有的局部变量信息：\n可以看到现在是冒泡排序的第一轮，所以i和j都还是0，并且数组是乱序的，我们输入c可以继续运行：\n继续运行一轮后，此时j就变成1了，因为内层循环执行了一次，我们可以通过p来打印变量的值：\n当我们不需要再调试时，可以直接结束掉程序：\n当然这仅仅是展示lldb的简单使用，通过使用lldb我们就可以很轻松地在控制台进行调试了。\n至此，包括编译、构建、调试的所有操作，我们完全可以脱离IDE纯靠命令行进行操作了（其实在没有图形化界面的年代基本上都是这样写代码的）\n结束语 到这里，我们C语言的学习就结束了，感谢各位小伙伴一直以来的支持，希望在下一期视频中，还能见到各位的身影。\n之后我们还会开放C语言系列数据结构篇教程，敬请期待。\n","permalink":"https://blog.l50.top/posts/c%E8%AF%AD%E8%A8%80%E4%B8%89/","summary":"C语言高级特性 前面我们了解了C语言的相关基础内容，我们来看看C语言的高级部分。这一章的学习难道会比较大，尤其是指针板块，因为需要理解计算机内存模型，所以说是很多初学者的噩梦。\n函数 其实函数我们在一开始就在使用了：\nint main() { //这是定义函数 ... } 我们程序的入口点就是main函数，我们只需要将我们的程序代码编写到主函数中就可以运行了，不够这个函数只是由我们来定义，而不是我们自己来调用。当然，除了主函数之外，我们一直在使用的printf也是一个函数，不过这个函数是标准库中已经实现好了的，现在是我们在调用这个函数：\nprintf(\u0026#34;Hello World!\u0026#34;); //直接通过 函数名称(参数...) 的形式调用函数 那么，函数的具体定义是什么呢？\n函数是完成特定任务的独立程序代码单元。\n其实简单来说，函数时为了完成某件任务而生的，可能我们要完成某个任务并不是一行代码就可以搞定的，但是现在可能会遇到这种情况：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; printf(\u0026#34;H\u0026#34;); //比如下面这三行代码就是我们要做的任务 printf(\u0026#34;A\u0026#34;); a += 10; if(a \u0026gt; 20) { printf(\u0026#34;H\u0026#34;); //这里我们还需要执行这个任务 printf(\u0026#34;A\u0026#34;); a += 10; } switch (a) { case 30: printf(\u0026#34;H\u0026#34;); //这里又要执行这个任务 printf(\u0026#34;A\u0026#34;); a += 10; } } 我们每次要做这个任务时，都要完完整整地将任务的每一行代码都写下来，如果我们的程序中多处都需要执行这个任务，每个地方都完整地写一遍，实在是太臃肿了，有没有一种更好的办法能优化我们的代码呢？\n这时我们就可以考虑使用函数了，我们可以将我们的程序逻辑代码全部编写到函数中，当我们执行函数时，实际上执行的就是函数中的全部内容，也就是按照我们制定的规则执行对应的任务，每次需要做这个任务时，只需要调用函数即可。\n我们来看看，如何创建和使用函数。\n创建和使用函数 首先我们来看看如何创建一个函数，其实创建一个函数是很简单的，格式如下：\n返回值类型 函数名称([函数参数...]); 其中函数名称也是有要求的，并不是所有的字符都可以用作函数名称，它的命名规则与变量的命名规则基本一致，所以这里就不一一列出了。\n函数不仅仅需要完成我们的任务，可能某些函数还需要告诉我们结果，比如我们之前认识的getchar函数，这个函数实际上返回了一个int值作为结果（也就是我们输入的字符）我们同样可以将函数返回的结果赋值给变量或是参与运算等等。\n当然如果我们的函数只需要完成任务，不需要告诉我们结果，返回值类型可以写成void表示为空。\n函数参数我们放在下一个小节中讲解，所以这里我们不使用任何参数，所以这里也将参数设定为void表示没有参数（当然为了方便，我们也可以直接什么都不写）","title":"C语言（三）"},{"content":" C语言基础 前面我们已经搭建好了基本的学习环境，现在就让我们开始C语言的学习吧！\nC语言的语法层面内容相比其他语言来说，其实算少的了，但是它的难点在于很多概念上的理解，这也是为什么上一章一直在说一些计算机基础相关内容（包括这一章还会继续补一点），这样会有助于各位对于语言的理解，C语言可以说是步入编程领域的分水岭，跨过了这道坎，后续其他编程语言的学习都会无比轻松。\n学习编程的过程可能会很枯燥，但是请各位一定不要心急，一步一个脚印，相信大家一定能通关。\nC程序基本格式 前面我们在创建项目之后自动生成了一个.c文件，这个就是我们编写的程序代码文件：\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World!\u0026#34;); return 0; } 操作系统需要执行我们的程序，但是我们的程序中可能写了很多很多的代码，那么肯定需要知道从哪里开始执行才可以，也就是程序的入口，所以我们需要提供一个入口点，我们的C语言程序入口点就是main函数（不过现在还没有讲到函数，所以各位就理解为固定模式即可）它的写法是：\nint main() { //所有的符号一律采用英文的，别用中文 程序代码... } 注意是int后面空格跟上main()，我们的程序代码使用花括号{}进行囊括（有的人为了方便查阅，会把前半个花括号写在下面）\n然后我们看到，如果我们需要打印一段话到控制台，那么就需要使用printf(内容)来完成，这其实就是一种函数调用，但是现在我们还没有接触到，我们注意到括号里面的内容就是我们要打印到控制台的内容：\nprintf(\u0026#34;Hello World!\u0026#34;); //注意最后需要添加;来结束这一行，注意是英文的分号，不是中文的！ 我们要打印的内容需要采用双引号进行囊括，被双引号囊括的这一端话，我们称为字符串，当然我们现在还没有学到，所以各位也是记固定模式就好，当我们需要向控制台打印一段话时，就要用双引号囊括这段话，然后放入printf即可。我们会在后续的学习中逐渐认识printf函数。\n最顶上还有一句：\n#include \u0026lt;stdio.h\u0026gt; 这个是引入系统库为我们提供的函数，包括printf在内，所以我们以后编写一个C语言程序，就按照固定模式：\n#include \u0026lt;stdio.h\u0026gt; int main() { 程序代码 } 除了程序代码部分我们会进行编写之外，其他的地方采用固定模式就好。\n我们在写代码的过程中可以添加一些注释文本，这些文本内容在编译时自动忽略，所以比如我们想边写边记点笔记，就可以添加注释，注释的格式为：\n#include \u0026lt;stdio.h\u0026gt; //引入标准库头文件 int main() { //主函数，程序的入口点 printf(\u0026#34;Hello World!\u0026#34;); //向控制台打印字符串 } 当然我们也可以添加多行注释：\n#include \u0026lt;stdio.h\u0026gt; /* * 这是由IDE自动生成的测试代码 * 还是可以的 */ int main() { printf(\u0026#34;Hello World!\u0026#34;); //最后还有一句 return 0; 但是我们可以不用写，编译器会自动添加，所以后面讲到之后我们再来说说这玩意。 } OK，基本的一些内容就讲解完毕了。\n基本数据类型 我们的程序离不开数据，比如我们需要保存一个数字或是字母，这时候这些东西就是作为数据进行保存，不过不同的数据他们的类型可能不同，比如1就是一个整数，0.5就是一个小数，A就是一个字符，C语言提供了多种数据类型供我们使用，我们就可以很轻松的使用这些数据了。\n不同的数据类型占据的空间也会不同，这里我们需要先提一个概念，就是字、字节是什么？\n我们知道，计算机底层实际上只有0和1能够表示，这时如果我们要存储一个数据，比如十进制的3，那么就需要使用2个二进制位来保存，二进制格式为11，占用两个位置，再比如我们要表示十进制的15，这时转换为二进制就是1111占用四个位置（4个bit位）来保存。一般占用8个bit位表示一个字节（B），2个字节等于1个字，所以一个字表示16个bit位，它们是计量单位。\n我们常说的内存大小1G、2G等，实际上就是按照下面的进制进行计算的：\n8 bit = 1 B ，1024 B = 1KB，1024 KB = 1 MB，1024 MB = 1GB，1024 GB = 1TB，1024TB = 1PB（基本上是1024一个大进位，但是有些硬盘生产厂商是按照1000来计算的，所以我们买电脑的硬盘容量可能是512G的但是实际容量可能会缩水）\n在不同位数的系统下基本数据类型的大小可能会不同，因为现在主流已经是64位系统，本教程统一按照64位系统进行讲解。\n原码、反码和补码 原码 上面我们说了实际上所有的数字都是使用0和1这样的二进制数来进行表示的，但是这样仅仅只能保存正数，那么负数怎么办呢？\n比如现在一共有4个bit位来保存我们的数据，为了表示正负，我们可以让第一个bit位专门来保存符号，这样，我们这4个bit位能够表示的数据范围就是：\n最小：1111 =\u0026gt; - (2^2+2^1+2^0) =\u0026gt; -7 最大：0111 =\u0026gt; + (2^2+2^1+2^0) =\u0026gt; +7 =\u0026gt; 7 虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：\n1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道，计算机顶多知道1+1需要进位！）\n我们得创造一种更好的表示方式！于是我们引入了反码：\n反码 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反 经过上面的定义，我们再来进行加减法：\n1+(-1) = 0001 + 1110 = 1111 =\u0026gt; -0 （直接相加，这样就简单多了！）\n思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？\n0既不是正数也不是负数，那么显然这样的表示依然不够合理！\n补码 根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：\n正数的补码就是其本身 （不变！） 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) 其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：\n1+(-1) = 0001 + 1111 = (1)0000 =\u0026gt; +0 （现在无论你怎么算，也不会有-0了！）\n所以现在，4bit位能够表示的范围是：-8~+7（C使用的就是补码！）\n整数类型 我们首先来看看整数类型，整数就是不包含小数点的数据，比如1，99，666等数字，整数包含以下几种类型：\nint - 占用 4 个字节，32个bit位，能够表示 -2,147,483,648 到 2,147,483,647 之间的数字，默认一般都是使用这种类型 long - 占用 8 个字节，64个bit位。 short - 占用2个字节，16个bit位。 浮点类型 浮点类一般用于保存小数，不过为啥不叫小数类型而是浮点类型呢？因为我们的一个小数分为整数部分和小数部分，我们需要用一部分的bit位去表示整数部分，而另一部分去表示小数部分，至于整数部分和小数部分各自占多少并不是固定的，而是浮动决定的（在计算机组成原理中会深入学习，这里就不多介绍了）\nfloat - 单精度浮点，占用4个字节，32个bit位。 double - 双精度浮点，占用8个字节，64个bit位。 字符类型 除了保存数字之外，C语言还支持字符类型，我们的每一个字符都可以使用字符类型来保存：\nchar - 占用1个字节（-128~127），可以表示所有的ASCII码字符，每一个数字对应的是编码表中的一个字符： 编码表中包含了所有我们常见的字符，包括运算符号、数字、大小写字母等（注意只有英文相关的，没有中文和其他语言字符，包括中文的标点符号也没有）\n某些无法直接显示的字符（比如换行，换行也算一个字符）需要使用转义字符来进行表示：\n有关基本类型的具体使用我们放到下一节进行讲解。\n变量 前面我们了解了C语言中的基本类型，那么我们如何使用呢？这时我们就可以创建不同类型的变量了。\n变量的使用 变量就像我们在数学中学习的x，y一样，我们可以直接声明一个变量，并利用这些变量进行基本的运算，声明变量的格式为：\n数据类型 变量名称 = 初始值; //其中初始值可以不用在定义变量时设定 // = 是赋值操作，可以将等号后面的值赋值给前面的变量，等号后面可以直接写一个数字（常量）、变量名称、算式 比如我们现在想要声明一个整数类型的变量：\nint a = 10; //变量类型为int（常用），变量名称为a，变量的初始值为10 int a = 10, b = 20; //多个变量可以另起一行编写，也可以像这样用逗号隔开，注意类型必须是一样的 其中，变量的名称并不是随便什么都可以的，它有以下规则：\n不能重复使用其他变量使用过的名字。 只能包含英文字母或是下划线、数字，并且严格区分大小写，比如a和A不算同一个变量。 虽然可以包含数字，但是不能以数字开头。 不能是关键字（比如我们上面提到的所有基本数据类型，当然还有一些关键字我们会在后面认识） （建议）使用英文单词，不要使用拼音，多个词可以使用驼峰命名法或是通过下划线连接。 初始值可以是一个常量数据（比如直接写10、0.5这样的数字）也可以是其他变量，或是运算表达式的结果，这样会将其他变量的值作为初始值。\n我们可以使用变量来做一些基本的运算：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; //将10作为a的值 int b = 20; int c = a + b; //注意变量一定要先声明再使用，这里是计算a + b的结果（算式），并作为c的初始值 } 这里使用到了+运算符（之后我们还会介绍其他类型的运算符）这个运算符其实就是我们数学中学习的加法运算，会将左右两边的变量值加起来，得到结果，我们可以将运算结果作为其他变量的初始值，还是很好理解的。\n但是现在虽然做了运算，我们还不知道运算的具体结果是什么，所以这里我们通过前面认识的printf函数来将结果打印到控制台：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; int b = 20; int c = a + b; printf(c); //直接打印变量c } 但是我们发现这样似乎运行不出来结果，不对啊，前面你不是说把要打印到控制台的内容写到printf中吗，怎么这里不行呢？实际上printf是用于格式化打印的，我们来看看如何进行格式化打印，输出我们的变量值：\nprintf(\u0026#34;c的结果是：%d\u0026#34;, ); //使用%d来代表一个整数类型的数据（占位符），在打印时会自动将c的值替换上去 我们来看看效果：\n这样，我们就知道该如何打印我们变量的值了，当然，除了使用%d打印有符号整数之外，还有其他的：\n格式控制符 说明 %c 输出一个单一的字符 %hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数 %hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数 %ho、%o、%lo 以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数 %#ho、%#o、%#lo 以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数 %hx、%x、%lx %hX、%X、%lX 以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。 %#hx、%#x、%#lx %#hX、%#X、%#lX 以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。 %f、%lf 以十进制的形式输出 float、double 类型的小数 %e、%le %E、%lE 以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。 %g、%lg %G、%lG 以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。 %s 输出一个字符串 比如现在我们要进行小数的运算，还记得我们前面介绍的小数类型有哪些吗？\n#include \u0026lt;stdio.h\u0026gt; int main() { double a = 0.5; float b = 2.5f; //注意直接写2.5默认表示的是一个double类型的值，我们需要再后面加一个f或是F表示是flaot类型值 printf(\u0026#34;a + b的结果是：%f\u0026#34;, a + b); //根据上表得到，小数类型需要使用%f表示，这里我们可以直接将a + b放入其中 } 可以看到，结果也是正确的：\n当然，我们也可以一次性打印多个，只需要填写多个占位符表示即可：\n#include \u0026lt;stdio.h\u0026gt; int main() { double a = 0.5; float b = 2.5f; //整数类型默认是int，如果要表示为long类型的值，也是需要在最后添加一个l或L printf(\u0026#34;a = %f, b = %f\u0026#34;, a, b); //后面可以一直添加（逗号隔开），但是注意要和前面的占位符对应 } 结果也是正常的：\n我们再来看看字符类型：\nchar c = \u0026#39;A\u0026#39;; //字符需要使用单引号囊括，且只能有一个字符，不能写成\u0026#39;AA\u0026#39;，这就不是单个字符了 //注意这里的A代表的是A这个字符，对应的ASCII码是65，实际上c存储的是65这个数字 我们也可以通过格式化打印来查看它的值：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = \u0026#39;A\u0026#39;; printf(\u0026#34;变量c的值为：%c 对应的ASCII码为：%d\u0026#34;, c, c); //这里我们使用%c来以字符形式输出，%d输出的是变量数据的整数形式，其实就是对应的ASCII码 } 当然，我们也可以直接让char存储一个数字（ASCII码），同样也可以打印出对应的字符：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = 66; printf(\u0026#34;变量c的值为：%c 对应的ASCII码为：%d\u0026#34;, c, c); } 那么现在请各位小伙伴看看下面这段代码会输出什么：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; char c = \u0026#39;a\u0026#39;; printf(\u0026#34;变量c的ASCII码为：%d\u0026#34;, c); } 没错，这里得到的结果就是字符a的ASCII码值，注意千万不要认为c得到的是变量a的值，这里使用的是字符a，跟上面的变量a半毛钱关系都没有：\n但是如果我们去掉引号，就相当于把变量a的值给了c，c现在的ASCII码就是10了，所以这里一定要分清楚。\n对于某些无法表示的字符，比如换行这类字符，我们没办法直接敲出来，只能使用转义字符进行表示：\nchar c = \u0026#39;\\n\u0026#39;; 详细的转义字符表参见前面的基本数据类型章节。\n变量除了有初始值之外，也可以在后续的过程中得到新的值：\n#include \u0026lt;stdio.h\u0026gt; int main() { short s = 10; s = 20; //重新赋值为20，注意这里就不要再指定类型了，指定类型只有在声明变量时才需要 printf(\u0026#34;%d\u0026#34;, s); //打印结果 } 可以看到，得到的是我们最后一次对变量修改的结果：\n那要是我们不对变量设定初始值呢？那么变量会不会有默认值：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a, b, c, d; printf(\u0026#34;%d,%d,%d,%d\u0026#34;, a, b, c, d); } 可以看到，虽然定义变量但是我们没有为其设定初始值，那么它的值就是不确定的了（千万注意并不是不设定值默认就是0）：\n所以各位小伙伴以后在使用时一定要注意这个问题，至于为什么不是0，这是因为内存分配机制，我们在下一章高级篇再进行讲解。\n我们再来看一个例子：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = 127; //已经到达c的最大值了 c = c + 1; //我不管，我就要再加 printf(\u0026#34;%d\u0026#34;, c); //这时会得到什么结果？ } 怎么127加上1还变成-128了呢？这是由于位数不够，导致运算结果值溢出：\n127 + 1= 01111111 + 1 由于现在是二进制，满2进1，所以最后变成 10000000 = 补码形式的 -128 所以，了解上面这些计算机底层原理是很重要的，我们能够很轻松地知道为什么会这样。\n在我们的运算中，可能也会存在一些一成不变的值，比如π的值永远都是3.1415....，在我们的程序中，也可以使用这样不可变的变量，我们成为常量。\n定义常量和变量比较类似，但是需要在前面添加一个const关键字，表示这是一个常量：\n可以看到，常量在一开始设定初始值后，后续是不允许进行修改的。\n无符号数 我们知道，所有的数据底层都是采用二进制来进行保存的，而第一位则是用于保存符号位，但是如果我们不考虑这个符号位，那么所有的数都是按照正数来表示，比如考虑了符号位的char类型：\n考虑符号表示范围：-128~127 不考虑符号：0~255 我们也可以直接使用这些不带符号位的数据类型：\nint main() { unsigned char c = -65; //数据类型前面添加unsigned关键字表示采用无符号形式 printf(\u0026#34;%u\u0026#34;, c); //%u以无符号形式输出十进制数据 } 可以看到这里给了无符号char类型c一个-65的值，但是现在很明显符号位也是作为数值的表示部分，所以结果肯定不是-65：\n结合我们前面学习的基础知识，我们来看看为什么得到的是191这个数字。首先char类型占据一个字节，8个bit位：\n00000000 -\u0026gt; 现在赋值-65 -\u0026gt; -65的补码形式 -\u0026gt; 10111111 由于现在没有符号位，一律都是正数，所以，10111111 = 128 + 32 + 16 + 8 + 4 + 2 + 1 = 191 我们也可以直接以无符号数形式打印：\n#include \u0026lt;stdio.h\u0026gt; int main() { int i = -1; printf(\u0026#34;%u\u0026#34;, i); //%u以无符号形式输出十进制数据 } 得到无符号int的最大值。\n类型转换 一种类型的数据可以转换为其他类型的数据，这种操作我们称为类型转换，类型转换分为自动类型转换和强制类型转换，比如我们现在希望将一个short类型的数据转换为int类型的数据：\n#include \u0026lt;stdio.h\u0026gt; int main() { short s = 10; int i = s; //直接将s的值传递给i即可，但是注意此时s和i的类型不同 } 这里其实就是一种自动类型转换，自动类型转换就是编译器隐式地进行的数据类型转换，这种转换不需要我们做什么，我们直接写就行，会自动进行转换操作。\nfloat a = 3; //包括这里我们给的明明是一个int整数3但是却可以赋值给float类型，说明也是进行了自动类型转换 如果我们使用一个比转换的类型最大值都还要大的值进行类型转换，比如：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 511; char b = a; //最大127 printf(\u0026#34;%d\u0026#34;, b); } 很明显char类型是无法容纳大于127的数据的，因为只占一个字节，而int占4个字节，如果需要进行转换，那么就只能丢掉前面的就只保留char所需要的那几位了，所以这里得到的就是-1：\n511 = int -\u0026gt; 00000000 00000000 00000001 11111111 char -\u0026gt; 11111111 -\u0026gt; -1 我们也可以将整数和小数类型的数据进行互相转换：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 99; double d = a; printf(\u0026#34;%f\u0026#34;, d); } 不过这里需要注意的是，小数类型在转换回整数类型时，会丢失小数部分（注意，不是四舍五入，是直接丢失小数！）：\n#include \u0026lt;stdio.h\u0026gt; int main() { double a = 3.14; int b = a; //这里编译器还提示了黄标，我们可以通过之后讲到的强制类型转换来处理 printf(\u0026#34;%d\u0026#34;, b); } 除了赋值操作可以进行自动类型转换之外，在运算中也会进行自动类型转换，比如：\n#include \u0026lt;stdio.h\u0026gt; int main() { float a = 2; int b = 3; double c = b / a; // \u0026#34;/\u0026#34; 是除以的意思，也就是我们数学中的除法运算，这里表示a除以b printf(\u0026#34;%f\u0026#34;, c); } 可以看到，这里得到的结果是小数1.5，但是参与运算的既有整数类型，又有浮点类型，结果为什么就确定为浮点类型了呢？这显然是由于类型转换导致的。那么规则是什么呢？\n不同的类型优先级不同（根据长度而定） char和short类型在参与运算时一律转换为int再进行运算。 浮点类型默认按双精度进行计算，所以就算有float类型，也会转换为double类型参与计算。 当有一个更高优先级的类型和一个低优先级的类型同时参与运算时，统一转换为高优先级运算，比如int和long参与运算，那么int转换为long再算，所以结果也是long类型，int和double参与运算，那么先把int转换为double再算。 我们接着来看看强制类型转换，我们可以为手动去指定类型，强制类型转换格式如下：\n(强制转换类型) 变量、常量或表达式; 比如：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = (int) 2.5; //2.5是一个double类型的值，但是我们可以强制转换为int类型赋值给a，强制转换之后小数部分丢失 printf(\u0026#34;%d\u0026#34;, a); } 我们也可以对一个算式的结果进行类型转换：\n#include \u0026lt;stdio.h\u0026gt; int main() { double a = 3.14; int b = (int) (a + 2.8); //注意得括起来表示对整个算式的结果进行类型转换（括号跟数学中的挺像，也是提升优先级使用的，我们会在运算符部分详细讲解），不然强制类型转换只对其之后紧跟着的变量生效 printf(\u0026#34;%d\u0026#34;, b); } 在我们需要得到两个int相除之后带小数的结果时，强制类型转换就显得很有用：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10, b = 4; double c = a / b; //不进行任何的类型转换，int除以int结果仍然是int，导致小数丢失 double d = (double) a / b; //对a进行强制类型转换，现在是double和int计算，根据上面自动类型转换规则，后面的int自动转换为double，结果也是double了，这样就是正确的结果了 printf(\u0026#34;不进行类型转换: %f, 进行类型转换: %f\u0026#34;, c, d); } 合理地使用强制类型转换，能够解决我们很多情况下的计算问题。\n运算符 前面我们了解了如何声明变量以及变量的类型转换，那么我们如何去使用这些变量来参与计算呢？这是我们本小节的重点。\n基本运算符 基本运算符包含我们在数学中常用的一些操作，比如加减乘除，分别对应：\n加法运算符：+ 减法运算符：- 乘法运算符：* 除法运算符：/（注意不是“\\”，看清楚一点） 当然，还有我们之前使用的赋值运算符=，我们先来看看赋值运算符的使用，其实在之前我们已经学习过了：\n变量 = 值 //其中，值可以直接是一个数字、一个变量、表达式的结果等 实际上等号左边的内容准确的说应该是一个左值，不过大部分情况下都是变量，这里就不展开左值和右值的话题了（感兴趣的小伙伴可以去详细了解，有助于后面学习C++理解右值引用）\n最简单的用法就是我们前面所说的，对一个变量进行赋值操作：\nint a = 10; 也可以连续地使用赋值操作，让一连串的变量都等于后面的值：\nint a, b; a = b = 20; //从右往左依次给b和a赋值20 可以看出，实际上=运算除了赋值之外，和加减乘除运算一样也是有结果的，比如上面的 a = 就是b = 20 运算的结果（可以看着一个整体），只不过运算的结果就是b被赋值的值，也就是20。\n我们接着来看加减法，这个就和我们数学中的是一样的了：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10, b = 5; printf(\u0026#34;%d\u0026#34;, a + b); //打印 a + b 的结果 } 当然也可以像数学中那样写在一个数或是变量的最前面，表示是正数：\nint a = +10, b = +5; 不过默认情况下就是正数，所以没必要去写一个+号。减法运算符其实也是一样的：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10, b = 5; printf(\u0026#34;%d\u0026#34;, a - b); //打印 a - b 的结果 } #include \u0026lt;stdio.h\u0026gt; int main() { int a = -10; //等于 -10 printf(\u0026#34;%d\u0026#34;, -a); //输出 -a 的值，就反着来嘛 } 接着我们来看看乘法和除法运算：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 20, b = 10; printf(\u0026#34;%d, %d\u0026#34;, a * b, a / b); //使用方式和上面的加减法是差不多的 } 还有一个比较有意思的取模运算：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 20, b = 8; printf(\u0026#34;%d\u0026#34;, a % b); //取模运算实际上就是计算a除以b的余数 } 不过很遗憾，在C中没有指数相关的运算符（比如要计算5的10次方），在后面学习了循环语句之后，我们可以尝试来自己实现一个指数运算。\n运算符优先级 和数学中一样，运算符是有优先级的：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 20, b = 10; printf(\u0026#34;%d\u0026#34;, a + a * b); //如果没有优先级，那么结果应该是400 } 很明显这里的结果是考虑了优先级的：\n在数学中，加减运算的优先级是没有乘除运算优先级高的，所以我们需要先计算那些乘除法，最后再来进行加减法的计算，而C语言中也是这样，运算符之间存在优先级概念。我们在数学中，如果需要优先计算加减法再计算乘除法，那么就需要使用括号来提升加减法的优先级，C语言也可以：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 20, b = 10; printf(\u0026#34;%d\u0026#34;, (a + a) * b); //优先计算 a + a 的结果，再乘以 b } 那要是遇到多重的呢？类似于下面的这种：\n数学上的写法：[1 - (3 + 4)] x (-2 ÷ 1) = ? 那么我们在C中就可以这样编写：\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\u0026#34;, (1 - (3 + 4)) * (-2 / 1)); //其实写法基本差不多，只需要一律使用小括号即可 } 这样，我们就可以通过()运算符，来提升运算优先级了。\n我们来总结一下，上面运算符优先级如下，从左往右依次递减：\n() \u0026gt; + - (做符号表示，比如-9) \u0026gt; * / % \u0026gt; + - (做加减运算) \u0026gt; = 根据上面的优先级，我们来看看下面a的结果是什么：\nint c; int a = (3 + (c = 2)) * 6; int b, c; int a = (b = 5, c = b + 8); //逗号运算符从前往后依次执行，赋值结果是最后边的结果 自增自减运算符 我们可以快速使用自增运算符来将变量的值+1，正常情况下我们想要让一个变量值自增需要：\nint a = 10; a = a + 1; 现在我们只需要替换为：\nint a = 10; ++a; //使用自增运算符，效果等价于 a = a + 1 并且它也是有结果的，除了做自增运算之外，它的结果是自增之后的值：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; //int b = a = a + 1; 下面效果完全一致 int b = ++a; printf(\u0026#34;%d\u0026#34;, b); } 当然我们也可以将自增运算符写到后面，和写在前面的区别是，它是先返回当前变量的结果，再进行自增的，顺序是完全相反的：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; int b = a++; //写在后面和写在前面是有区别的 printf(\u0026#34;a = %d, b = %d\u0026#34;, a, b); } 重点内容：自增运算符++在前，那么先自增再出结果；自增运算符++在后，那么先出结果再自增。各位小伙伴可以直接记运算符的位置，来方便记忆。\n那要是现在我们不想自增1而是自增2或是其他的数字呢？我们可以使用复合赋值运算符，正常情况下依然是使用普通的赋值运算符：\nint a = 10; a = a + 5; 但是现在我们可以简写：\nint a = 10; a += 5; 效果和上面是完全一样的，并且得到的结果也是在自增之后的：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; int b = a += 5; printf(\u0026#34;a = %d\u0026#34;, b); } 复合赋值运算符不仅仅支持加法，还支持各种各样的运算：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; a %= 3; //可以复合各种运算，比如加减乘除、模运算、包括我们我们还要讲到的位运算等 printf(\u0026#34;a = %d\u0026#34;, a); } 当然，除了自增操作之外，还有自减操作：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; a--; //--是自减操作，相当于a = a - 1，也可以在前后写，规则和上面的自增是一样的 printf(\u0026#34;a = %d\u0026#34;, a); } 注意自增自减运算符和+、-做符号是的优先级一样，仅次于()运算符，所以在编写时一定要注意：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; int b = 5 * --a; printf(\u0026#34;b = %d\u0026#34;, b); } 位运算符 前面我们学习了乘法运算符*，当我们想要让一个变量的值变成2倍，只需要做一次乘法运算即可：\nint a = 10; a *= 2; //很明显算完之后a就是20了 但是我们现在可以利用位运算来快速进行计算：\nint a = 10; a = a \u0026lt;\u0026lt; 1; //也可以写成复合形式 a \u0026lt;\u0026lt;= 1 我们会发现这样运算之后得到的结果居然也是20，这是咋算出来的呢？实际上\u0026lt;\u0026lt;是让所有的bit位进行左移操作，上面就是左移1位，我们可以来看看：\n10 = 00001010 现在所以bit位上的数据左移一位 00010100 = 20 是不是感觉特别神奇？就像我们在十进制中，做乘以10的操作一样：22乘以10那么就直接左移了一位变成220，而二进制也是一样的，如果让这些二进制数据左移的话，那么相当于在进行乘2的操作。\n比如：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 6; a = a \u0026lt;\u0026lt; 2; //让a左移2位，实际上就是 a * 2 * 2，a * 2的平方（类比十进制，其实还是很好理解的） printf(\u0026#34;a = %d\u0026#34;, a); } 当然能左移那肯定也可以右移：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 6; a = a \u0026gt;\u0026gt; 1; //右移其实就是除以2的操作 printf(\u0026#34;a = %d\u0026#34;, a); } 当然除了移动操作之外，我们也可以进行按位比较操作，先来看看按位与操作：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 6, b = 4; int c = a \u0026amp; b; //按位与操作 printf(\u0026#34;c = %d\u0026#34;, c); } 按位与实际上也是根据每个bit位来进行计算的：\n4 = 00000100 6 = 00000110 按位与实际上就是让两个数的每一位都进行比较，如果两个数对应的bit位都是1，那么结果的对应bit位上就是1，其他情况一律为0 所以计算结果为：00000100 = 4 除了按位与之外，还有按位或运算：\nint a = 6, b = 4; int c = a | b; 4 = 00000100 6 = 00000110 按位与实际上也是让两个数的每一位都进行比较，如果两个数对应bit位上其中一个是1，那么结果的对应bit位上就是1，其他情况为0。 所以计算结果为：00000110 = 6 还有异或和按位非（按位否定）：\nint a = 6, b = 4; int c = a ^ b; //注意^不是指数运算，表示按位异或运算，让两个数的每一位都进行比较，如果两个数对应bit位上不同时为1或是同时为0，那么结果就是1，否则结果就是0，所以这里的结果就是2 a = ~a; //按位否定针对某个数进行操作，它会将这个数的每一个bit位都置反，0变成1，1变成0，猜猜会变成几 按位运算都是操作数据底层的二进制位来进行的。\n逻辑运算符 最后我们来看一下逻辑运算符，逻辑运算符主要用到下一节的流程控制语句中。\n逻辑运算符用于计算真和假，比如今天要么下雨要么不下雨，现在我们想要在程序中判断一下是否下雨了，这时就需要用到逻辑运算符，我们来举个例子：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; _Bool c = a \u0026lt; 0; //我们现在想要判断a的值是否小于0，我们可以直接使用小于符号进行判断，最后得到的结果只能是1或0 //虽然结果是一个整数，但是这里推荐使用_Bool类型进行接收，它只能表示0和1（更加专业一些） printf(\u0026#34;c = %d\u0026#34;, c); } 实际上在C语言中，0一般都表示为假，而非0的所有值（包括正数和负数）都表示为真，上面得到1表示真，0表示假。\n除了小于符号可以判断大小之外，还有：\u0026lt;、 \u0026lt;=、\u0026gt;=、\u0026gt;\n比如我们现在想要判断字符C是否为大写字母：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = \u0026#39;D\u0026#39;; printf(\u0026#34;c是否为大写字母：%d\u0026#34;, c \u0026gt;= \u0026#39;A\u0026#39;); //由于底层存储的就是ASCII码，这里可以比较ASCII码，也可以写成字符的形式 } 但是我们发现，现在我们的判断只能判断一个条件，也就是说只能判断c是否是大于等于\u0026rsquo;A\u0026rsquo;的，但是不能同时判断c的值是否是小于等于\u0026rsquo;Z\u0026rsquo;的，所以这时，我们就需要利用逻辑与和逻辑或来连接两个条件了：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = \u0026#39;D\u0026#39;; printf(\u0026#34;c是否为大写字母：%d\u0026#34;, c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;); //使用\u0026amp;\u0026amp;表示逻辑与，逻辑与要求两边都是真，结果才是真 } 又比如现在我们希望判断c是否不是大写字母：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = \u0026#39;D\u0026#39;; printf(\u0026#34;c是否不为大写字母：%d\u0026#34;, c \u0026lt; \u0026#39;A\u0026#39; || c \u0026gt; \u0026#39;Z\u0026#39;); //使用||表示逻辑或，只要两边其中一个为真或是都为真，结果就是真 } 当然我们也可以判断c是否为某个字母：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = \u0026#39;D\u0026#39;; printf(\u0026#34;c是否为字母A：%d\u0026#34;, c == \u0026#39;A\u0026#39;); //注意判断相等时使用==双等号 } 判断不相等也可以使用：\nprintf(\u0026#34;c是否不为字母A：%d\u0026#34;, c != \u0026#39;A\u0026#39;); 我们也可以对某个结果取反：\n#include \u0026lt;stdio.h\u0026gt; int main() { int i = 20; printf(\u0026#34;i是否不小于20：%d\u0026#34;, !(i \u0026lt; 20)); //使用!来对结果取反，注意!优先级很高，一定要括起来，不然会直接对i生效 } 这里要注意一下!如果直接作用于某个变量或是常量，那么会直接按照上面的规则（0表示假，非0表示真）非0一律转换为0，0一律转换为1。\n这里我们可以结合三目运算符来使用这些逻辑运算符：\n#include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; char c = i \u0026gt; 10 ? \u0026#39;A\u0026#39; : \u0026#39;B\u0026#39;; //三目运算符格式为：expression ? 值1 : 值2，返回的结果会根据前面判断的结果来的 //这里是判断i是否大于10，如果大于那么c的值就是A，否则就是B printf(\u0026#34;%d\u0026#34;, c); } 最后，我们来总结一下前面认识的所有运算符的优先级，从上往下依次降低：\n运算符 解释 结合方式 () 同数学中的括号，直接提升到最高优先级 由左向右 ! ~ ++ \u0026ndash; + - 否定，按位否定，增量，减量，正负号 由右向左 * / % 乘，除，取模 由左向右 + - 加，减 由左向右 \u0026laquo; \u0026raquo; 左移，右移 由左向右 \u0026lt; \u0026lt;= \u0026gt;= \u0026gt; 小于，小于等于，大于等于，大于 由左向右 == != 等于，不等于 由左向右 \u0026amp; 按位与 由左向右 ^ 按位异或 由左向右 | 按位或 由左向右 \u0026amp;\u0026amp; 逻辑与 由左向右 || 逻辑或 由左向右 ? : 条件 由右向左 = += -= *= /= \u0026amp;= ^= |= \u0026laquo;= \u0026raquo;= 各种赋值 由右向左 , 逗号（顺序） 由左向右 流程控制 前面我们学习了运算符，知道该如何使用运算符来计算我们想要的内容，但是仅仅依靠计算我们的程序还没办法实现丰富多样的功能，我们还得加点额外的控制操作。\n分支语句 - if 我们可能会有这样的一个需求，就是判断某个条件，当满足此条件时，才执行某些代码，那这个时候该怎么办呢？我们可以使用if语句来实现：\n#include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; if(i \u0026gt; 20) { //我们只希望i大于20的时候才执行下面的打印语句 printf(\u0026#34;Hello World!\u0026#34;); } printf(\u0026#34;Hello World?\u0026#34;); //后面的代码在if之外，无论是否满足if条件，都跟后面的代码无关，所以这里的代码任何情况下都会执行 } if语句的标准格式如下：\nif(判断条件) { 执行的代码 } 当然如果只需要执行一行代码的话，可以省略花括号：\nif(判断条件) 一行执行的代码 //注意这样只有后一行代码生效，其他的算作if之外的代码了 现在我们需求升级了，我们需要判断某个条件，当满足此条件时，执行某些代码，而不满足时，我们想要执行另一段代码，我们就可以结合else语句来实现：\n#include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; if(i \u0026gt; 20) { printf(\u0026#34;Hello World!\u0026#34;); //满足if条件才执行 } else { printf(\u0026#34;LBWNB\u0026#34;); //不满足if条件才执行 } } 但是这样可能还是不够用，比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用else-if来完成：\n#include \u0026lt;stdio.h\u0026gt; int main() { int score = 2; if(score \u0026gt;= 90) { printf(\u0026#34;优秀\u0026#34;); } else if (score \u0026gt;= 70) { printf(\u0026#34;良好\u0026#34;); } else if (score \u0026gt;= 60){ printf(\u0026#34;及格\u0026#34;); } else{ printf(\u0026#34;不及格\u0026#34;); } } if这类的语句（包括我们下面还要介绍的三种）都是支持嵌套使用的，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：\n#include \u0026lt;stdio.h\u0026gt; int main() { int score = 2; if(score \u0026lt; 60) { //先判断不及格 if(score \u0026gt; 30) { //在内层再嵌套一个if语句进行进一步的判断 printf(\u0026#34;学习C++\u0026#34;); } else{ printf(\u0026#34;学习Java\u0026#34;); } } } 分支语句 - switch 前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用switch语句来实现，它更适用于多分支的情况：\nswitch (目标) { //我们需要传入一个目标，比如变量，或是计算表达式等 case 匹配值: //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码 代码... break; //代码执行结束后需要使用break来结束，否则会继续溜到下一个case继续执行代码 } 比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = \u0026#39;A\u0026#39;; switch (c) { //这里目标就是变量c case \u0026#39;A\u0026#39;: //分别指定ABC三个匹配值，并且执行不同的代码 printf(\u0026#34;去尖子班！准备冲刺985大学！\u0026#34;); break; //执行完之后一定记得break，否则会继续向下执行下一个case中的代码 case \u0026#39;B\u0026#39;: printf(\u0026#34;去平行班！准备冲刺一本！\u0026#34;); break; case \u0026#39;C\u0026#39;: printf(\u0026#34;去职高深造。\u0026#34;); break; } } switch可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。\n当然除了精准匹配之外，其他的情况我们可以用default来表示：\nswitch (目标) { case: ... default: 其他情况下执行的代码 } 比如：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = \u0026#39;A\u0026#39;; switch (c) { case \u0026#39;A\u0026#39;: printf(\u0026#34;去尖子班！\u0026#34;); break; case \u0026#39;B\u0026#39;: printf(\u0026#34;去平行班！\u0026#34;); break; case \u0026#39;C\u0026#39;: printf(\u0026#34;去差生班！\u0026#34;); break; default: //其他情况一律就是下面的代码了 printf(\u0026#34;去读职高，分流\u0026#34;); } } 当然switch中可以继续嵌套其他的流程控制语句，比如if：\n#include \u0026lt;stdio.h\u0026gt; int main() { char c = \u0026#39;A\u0026#39;; switch (c) { case \u0026#39;A\u0026#39;: if(c == \u0026#39;A\u0026#39;) { //嵌套一个if语句 printf(\u0026#34;去尖子班！\u0026#34;); } break; case \u0026#39;B\u0026#39;: printf(\u0026#34;去平行班！\u0026#34;); break; } } 循环语句 - for 通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句，循环语句。\n我们在某些时候，可能需要批量执行某些代码：\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); //把这句话给我打印三遍 printf(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); printf(\u0026#34;伞兵一号卢本伟准备就绪！\u0026#34;); } 遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。现在我们可以使用for循环语句来多次执行：\nfor (表达式1表达式2;表达式3) { 循环体 } 我们来介绍一下：\n表达式1：在循环开始时仅执行一次。 表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。 表达式3：每次循环完成后会执行一次。 循环体：每次循环都会执行循环体里面的内容，直到循环结束。 一个标准的for循环语句写法如下：\n//比如现在我们希望循环4次 for (int i = 0; i \u0026lt; 4; ++i) { //首先定义一个变量i用于控制循环结束 //表达式2在循环开始之前判断是否小于4 //表达式3每次循环结束都让i自增一次，这样当自增4次之后不再满足条件，循环就会结束，正好4次循环 } 我们来看看按顺序打印的结果：\n#include \u0026lt;stdio.h\u0026gt; int main() { //比如现在我们希望循环4次 for (int i = 0; i \u0026lt; 4; ++i) { printf(\u0026#34;%d, \u0026#34;, i); } } 这样，利用循环我们就可以批量执行各种操作了。\n注意，如果表达式2我们什么都不写，那么会默认判定为真：\n#include \u0026lt;stdio.h\u0026gt; int main() { for (int i = 0; ; ++i) { //表达式2不编写任何内容，默认为真，这样的话循环永远都不会结束 printf(\u0026#34;%d, \u0026#34;, i); } } 所以，如果我们想要编写一个无限循环，其实什么都不用写就行了：\n#include \u0026lt;stdio.h\u0026gt; int main() { for (;;) { //什么都不写直接无限循环，但是注意，两个分号还是要写的 printf(\u0026#34;Hello World!\\n\u0026#34;); //这里用到了\\n表示换行 } } 当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：\nfor (int i = 0; i \u0026lt; 10; ++i) { if(i == 5) break; //比如现在我们希望在满足某个条件下提前终止循环，可以使用break关键字来跳出循环 printf(\u0026#34;%d\u0026#34;, i); } 可以看到，当满足条件时，会直接通过break跳出循环，循环不再继续下去，直接结束掉。\n我们也可以加速循环：\nfor (int i = 0; i \u0026lt; 10; ++i) { if(i == 5) continue; //使用continue关键字会加速循环，无论后面有没有未执行完的代码，都会直接开启下一轮循环 printf(\u0026#34;%d\u0026#34;, i); } 虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：\nfor (int i = 1; i \u0026lt; 4; ++i) { for (int j = 1; j \u0026lt; 4; ++j) { if(i == j) continue; //当i == j时加速循环 printf(\u0026#34;%d, %d\\n\u0026#34;, i, j); } } 可以看到，continue仅仅加速的是内层循环，而对外层循环没有任何效果，同样的，break也只会终结离它最近的：\nfor (int i = 1; i \u0026lt; 4; ++i) { for (int j = 1; j \u0026lt; 4; ++j) { if(i == j) break; //当i == j时终止循环 printf(\u0026#34;%d, %d\\n\u0026#34;, i, j); } } 循环语句 - while 前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：\n#include \u0026lt;stdio.h\u0026gt; int main() { while (1) { //每次循环开始之前都会判断括号内的内容是否为真，如果是就继续循环 printf(\u0026#34;Hello World!\\n\u0026#34;); //这里会无限循环 } } 相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当i大于10时需要结束循环，但是i在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。\n#include \u0026lt;stdio.h\u0026gt; int main() { int i = 100; //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 while (i \u0026gt; 0) { //现在唯一知道的是循环条件，只要大于0那么就可以继续除 printf(\u0026#34;%d, \u0026#34;, i); i /= 2; //每次循环都除以2 } } while也支持使用break和continue来进行循环的控制：\nint i = 100; while (i \u0026gt; 0) { if(i \u0026lt; 30) break; printf(\u0026#34;%d, \u0026#34;, i); i /= 2; } 我们可以反转循环判断的位置，可以先执行循环内容，然后再做循环条件判断，这里要用到do-while语句：\n#include \u0026lt;stdio.h\u0026gt; int main() { do { //无论满不满足循环条件，先执行循环体里面的内容 printf(\u0026#34;Hello World!\u0026#34;); } while (0); //再做判断，如果判断成功，开启下一轮循环，否则结束 } 实战：寻找水仙花数 “水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指**一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。**例如：1^3 + 5^3+ 3^3 = 153。”\n现在请你设计一个C语言程序，打印出所有1000以内的水仙花数。\n实战：打印九九乘法表 现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个C语言程序来实现它。\n实战：斐波那契数列解法其一 斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：**1、1、2、3、5、8、13、21、34、……*在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。\n斐波那契数列：1，1，2，3，5，8，13，21，34，55，89\u0026hellip;，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个C语言程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。\n#include \u0026lt;stdio.h\u0026gt; int main() { int target = 7, result; //target是要获取的数，result是结果 //请在这里实现算法 printf(\u0026#34;%d\u0026#34;, result); } 数组 现在我们有一个新的需求，我们需要存储2022年每个月都天数，那么此时，为了保存这12个月的天数，我们就得创建12个变量：\n#include \u0026lt;stdio.h\u0026gt; int main() { int january = 31, february = 28, march = 31 ... } 这样是不是太累了点？万一我们想保存100个商品的售价，那岂不是得创建100个变量？这肯定不行啊。\n数组的创建和使用 为了解决这种问题，我们可以使用数组，什么是数组呢？简单来说，就是存放数据的一个组，所有的数据都统一存放在这一个组中，一个数组可以同时存放多个数据。比如现在我们想保存12个月的天数，那么我们只需要创建一个int类型的数组就可以了，它可以保存很多个int类型的数据，这些保存在数组中的数据，称为“元素”：\nint arr[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; //12个月的数据全部保存在了一起 可以看到，数组的定义方式也比较简单：\n类型 数组名称[数组大小] = {数据1, 数据2...}; //后面的数据可以在一开始的时候不赋值，并且数组大小必须是整数 注意数组只能存放指定类型的数据，一旦确定是不能更改的，因为数组声明后，会在内存中开辟一块连续的区域，来存放这些数据，所以类型和长度必须在一开始就明确。\n创建数组的方式有很多种：\nint a[10]; //直接声明int类型数组，容量为10 int b[10] = {1, 2, 4}; //声明后，可以赋值初始值，使用{}囊括，不一定需要让10个位置都有初始值，比如这里仅仅是为前三个设定了初始值，注意，跟变量一样，如果不设定初始值，数组内的数据并不一定都是0 int c[10] = {1, 2, [4] = 777, [9] = 666}; //我们也可以通过 [下标] = 的形式来指定某一位的初始值，注意下标是从0开始的，第一个元素就是第0个下标位置，比如这里数组容量为10，那么最多到9 int c[] = {1, 2, 3}; //也可以根据后面的赋值来决定数组长度 基本类型都可以声明数组：\n#include \u0026lt;stdio.h\u0026gt; int main() { char str[] = {\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;}; //多个字符 char str2[] = \u0026#34;ABC\u0026#34;; //实际上字符串就是多个字符的数组形式，有关字符串我们会在下一节进行讲解 } 那么数组定义好了，如何去使用它呢？比如我们现在需要打印12个月的天数：\n#include \u0026lt;stdio.h\u0026gt; int main() { int arr[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; for (int i = 0; i \u0026lt; 12; ++i) { int days = arr[i]; //直接通过数组 名称[下标] 来访问对应的元素值，再次提醒，下标是从0开始的，不是1 printf(\u0026#34;2022年 %d 月的天数是：%d 天\\n\u0026#34;, (i + 1), days); } } 当然我们也可以对数组中的值进行修改：\n#include \u0026lt;stdio.h\u0026gt; int main() { int arr[] = {666, 777, 888}; arr[1] = 999; //比如我们现在想要让第二个元素的值变成999 printf(\u0026#34;%d\u0026#34;, arr[1]); //打印一下看看是不是变成了999 } 注意，和变量一样，如果只是创建数组但是不赋初始值的话，因为是在内存中随机申请的一块空间，有可能之前其他地方使用过，保存了一些数据，所以数组内部的元素值并不一定都是0：\n#include \u0026lt;stdio.h\u0026gt; int main() { int arr[10]; for (int i = 0; i \u0026lt; 10; ++i) { printf(\u0026#34;%d, \u0026#34;, arr[i]); } } 不要尝试去访问超出数组长度位置的数据，虽然可以编译通过，但是会给警告，这些数据是毫无意义的：\n#include \u0026lt;stdio.h\u0026gt; int main() { int arr[] = {111, 222, 333}; printf(\u0026#34;%d\u0026#34;, arr[3]); //不能去访问超出数组长度的元素，很明显这里根本就没有第四个元素 } 多维数组 数组不仅仅只可以有一个维度，我们可以创建二维甚至多维的数组，简单来说就是，存放数组的数组（套娃了属于是）：\nint arr[][2] = {{20, 10}, {18, 9}}; //可以看到，数组里面存放的居然是数组 //存放的内层数组的长度是需要确定的，存放数组的数组和之前一样，可以根据后面的值决定 比如现在我们要存放2020-2022年每个月的天数，那么此时用一维数组肯定是不方便了，我们就可以使用二维数组来处理：\nint arr[3][12] = {{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, //2020年是闰年，2月有29天 {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}}; 这样，我们就通过二维数组将这三年每个月的天数都保存下来了。\n那么二维数组又该如何去访问呢？\n#include \u0026lt;stdio.h\u0026gt; int main() { int arr[3][12] = {{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, //2020年是闰年，2月有29天 {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}}; printf(\u0026#34;%d\u0026#34;, arr[0][1]); //比如现在我们想要获取2020年2月的天数，首先第一个是[0]表示存放的第一个数组，第二个[1]表示数组中的第二个元素 } 当然除了二维还可以上升到三维、四维：\nint arr[2][2][2] = {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}}; 有关多维数组，暂时先介绍到这里。\n实战：冒泡排序算法 现在有一个int数组，但是数组内的数据是打乱的，现在请你通过C语言，实现将数组中的数据按从小到大的顺序进行排列：\n#include \u0026lt;stdio.h\u0026gt; int main() { int arr[10] = {3, 5, 7, 2, 9, 0, 6, 1, 8, 4}; //乱序的 //请编写代码对以上数组进行排序 } 这里我们使用冒泡排序算法来实现，此算法的核心思想是：\n假设数组长度为N 进行N轮循环，每轮循环都选出一个最大的数放到后面。 每次循环中，从第一个数开始，让其与后面的数两两比较，如果更大，就交换位置，如果更小，就不动。 动画演示：https://visualgo.net/zh/sorting?slide=2-2\n实战：斐波那契数列解法其二 学习了数组，我们来看看如何利用数组来计算斐波那契数列，这里采用动态规划的思想。\n动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。\n我们可以在一开始创建一个数组，然后从最开始的条件不断向后推导，从斐波那契数列的规律我们可以得知：\nfib[i] = fib[i - 1] + fib[i - 2]（这里fib代表斐波那契数列） 得到这样的一个关系（递推方程）就好办了，我们要求解数列第i个位置上的数，只需要知道i - 1和i - 2的值即可，这样，一个大问题，就分成了两个小问题，比如现在我们要求解斐波那契数列的第5个元素：\nfib[4] = fib[3] + fib[2]现在我们只需要知道fib[3]和fib[2]即可，那么我们接着来看： fib[3] = fib[2] + fib[1]以及fib[2] = fib[1] + fib[0] 由于fib[0]和fib[1]我们已经明确知道是1了，那么现在问题其实已经有结果了，把这些小问题的结果组合起来不就能得到原来大问题的结果了吗？ 现在请你设计一个C语言程序，利用动态规划的思想解决斐波那契数列问题。\n实战：打家劫舍 我们继续通过一道简单的算法题来强化动态规划思想。\n来源：力扣（LeetCode）No.198 打家劫舍：https://leetcode.cn/problems/house-robber/\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n示例 1：\n输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。\n示例 2：\n输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n这道题我们也可以很轻松地按照上面的动态规划思路来处理，首先我们可以将问题分为子问题，比如现在有[2,7,9,3,1]五个房屋，这个问题看起来比较复杂，我们不妨先将大问题先简化成小问题，我们来看看只有N个房屋的情况：\n假设现在只有[2]这一个房屋，那么很明显，我可以直接去偷一号房，得到2块钱，所以当有一个房子时最大能偷到2块钱。 假设现在有[2, 7]这两个房屋，那么很明显，我可以直接去偷二号房，得到7块钱，所以当有两个房子时最大能偷到7块钱。 假设现在只有[2, 7, 9]这三个房屋，我们就要来看看了，是先偷一号房再偷三号房好，还是只偷二号房好，根据前面的结论，如果我们偷了一号房，那么就可以继续偷三号房，并且得到的钱就是从一号房过来的钱+三号房的钱，也就是2+9块钱，但是如果只偷二号房的话，那么就只能得到7块钱，所以，三号房能够偷到的最大金额有以下关系（dp是我们求出的第i个房屋的最大偷钱数量，value表示房屋价值，max表示取括号中取最大的一个）： dp[i] = max(dp[i - 1], dp[i - 2] + value[i]) -\u0026gt; 递推方程已得到 这样就不难求出：dp[2] = max(dp[1], dp[0] + value[i]) = dp[2] = max(7, 2 + 9) = dp[2] = 11，所以有三个房屋时最大的金额是11块钱。 所以，实际上我们只需要关心前面计算出来的盗窃最大值即可，而不需要关心前面到底是怎么在偷。 我们以同样的方式来计算四个房屋[2, 7, 9, 3]的情况： dp[3] = max(dp[2], dp[1] + value[3]) = dp[3] = max(11, 7 + 3) = dp[3] = 11 所以，当有四个房屋时，我们依然采用先偷一后偷三的方案，不去偷四号，得到最大价值11块钱。 好了，现在思路已经出来了，我们直接上算法吧，现在请你实现下面的C语言程序：\n#include \u0026lt;stdio.h\u0026gt; int main() { int arr[] = {2,7,9,3,1}, size = 5, result; //请补充程序 printf(\u0026#34;%d\u0026#34;, result); } 力扣提交，建议各位小伙伴学习了函数和指针之后再回来看看，这里暂时可以跳过。\nint max(int a, int b) { return a \u0026gt; b ? a : b; } int rob(int* nums, int numsSize){ if(numsSize == 0) return 0; if(numsSize == 1) return nums[0]; if(numsSize == 2) return max(nums[1], nums[0]); int dp[numsSize]; dp[0] = nums[0]; dp[1] = max(nums[1], nums[0]); for (int i = 2; i \u0026lt; numsSize; ++i) { dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); } return dp[numsSize - 1]; } 字符串 前面我们学习了数组，而对于字符类型的数组，比较特殊，它实际上可以作为一个字符串（String）表示，字符串就是一个或多个字符的序列，比如我们在一开始认识的\u0026quot;Hello World!\u0026quot;，像这样的多个字符形成的一连串数据，就是一个字符串，而printf函数接受的第一个参数也是字符串。\n那么，我们就来认识一下字符串。\n字符串的创建和使用 在C语言中并没有直接提供存储字符串的类型，我们熟知的能够存储字符的只有char类型，但是它只能存储单个字符，而一连串的字符想要通过变量进行保存，那么就只能依靠数组了，char类型的数组允许我们存放多个字符，这样的话就可以表示字符串了。\n比如我们现在想要存储Hello这一连串字符：\nchar str[] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39;}; //直接保存单个字符，但是注意，无论内容是什么，字符串末尾必须添加一个‘\\0’字符（ASCII码为0）表示结束。 printf(\u0026#34;%s\u0026#34;, str); //用%s来作为一个字符串输出 不过这样写起来实在是太麻烦了，我们可以使用更加简便的写法：\nchar str[] = \u0026#34;Hello\u0026#34;; //直接使用双引号将所有的内容囊括起来，并且也不需要补充\\0（但是本质上是和上面一样的字符数组） //也可以添加 const char str[] = \u0026#34;Hello World!\u0026#34;; 双引号囊括的字符串实际上就是一个const char数组类型的值 printf(\u0026#34;%s\u0026#34;, str); 这下终于明白了，原来我们一直在写的双引号，其实表示的就是一个字符串。\n那么现在请各位小伙伴看看下面的写法有什么不同：\n\u0026#34;c\u0026#34; \u0026#39;c\u0026#39; 我们发现一个问题，char类型只能保存ASCII编码表中的字符，但是我们发现实际上中文也是可以正常打印的：\nprintf(\u0026#34;你这瓜保熟吗\u0026#34;); 这是什么情况？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。\n我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。\n10000011 10000110 //这就是一个连续出现都大于127的字节（注意这里是不考虑符号位的） 不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。\n虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode，规定每个字符必须使用俩个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）\n但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，但是又得这样去表示，这就导致某些字符浪费了很多空间。所以最后就有了UTF-8编码格式，区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：\nUnicode符号范围（十六进制） UTF-8编码方式(二进制) 0000 0000 ~ 0000 007F 0xxxxxxx 0000 0080 ~ 0000 07FF 110xxxxx 10xxxxxx 0000 0800 ~ 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 ~ 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式。\n简而言之，我们的中文实际上是依靠多个char来进行表示的。\n这样，我们就了解了字符串的使用。\nscanf、gets、puts函数 函数我们会在下一章详细介绍，不过这里还是要再提到一个比较重要的函数。\n前面我们认识了printf函数，实际上这个函数就是用于打印字符串到控制台，我们只需要填入一个字符串和后续的参数即可。\n#include \u0026lt;stdio.h\u0026gt; int main() { const char str[] = \u0026#34;Hello World!\u0026#34;; //注意printf需要填写一个const char数组进去，也就是字符串 printf(str); } 现在我们知道该如何输出，那么输入该如何实现呢，比如我们现在希望将我们想要说的话告诉程序，让程序从控制台读取我们输入的内容，这时我们就需要使用到scanf函数了：\n#include \u0026lt;stdio.h\u0026gt; int main() { char str[10]; scanf(\u0026#34;%s\u0026#34;, str); //使用scanf函数来接受控制台输入，并将输入的结果按照格式，分配给后续的变量 //比如这里我们想要输入一个字符串，那么依然是使用%s（和输出是一样的占位符），后面跟上我们要赋值的数组（存放输入的内容） printf(\u0026#34;输入的内容为：%s\u0026#34;, str); } 可以看到，成功接收到用户输入：\n当然除了能够扫描成字符串之外，我们也可以直接扫描为一个数字：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a, b; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); //连续扫描两个int数字 scanf(\u0026#34;%d\u0026#34;, \u0026amp;b); //注意，如果不是数组类型，那么这里在填写变量时一定要在前面添加一个\u0026amp;符号（至于为什么，下一章在指针小节中会详细介绍）这里的\u0026amp;不是做与运算，而是取地址操作。 printf(\u0026#34;a + b = %d\u0026#34;, a + b); //扫描成功后，我们来计算a + b的结果 } 除了使用scanf之外，我们也可以使用字符串专用的函数来接受字符串类型的输入和输出：\n#include \u0026lt;stdio.h\u0026gt; int main() { char str[10]; gets(str); //gets也是接收控制台输入，然后将结果丢给str数组中 puts(str); //puts其实就是直接打印字符串到控制台 } 当然也有专门用于字符输入输出的函数：\n#include \u0026lt;stdio.h\u0026gt; int main() { int c = getchar(); putchar(c); } 由于我们目前还没有学习函数，所以这里稍微提及一下即可。\n实战：回文串判断 “回文串”是一个正读和反读都一样的字符串，请你实现一个C语言程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。\nABCBA 就是一个回文串，因为正读反读都是一样的\nABCA 就不是一个回文串，因为反着读不一样\n实战：字符串匹配KMP算法 现在有两个字符串：\nstr1 = \u0026ldquo;abcdabbc\u0026rdquo;\nstr2 = \u0026ldquo;cda\u0026rdquo;\n现在请你设计一个C语言程序，判断第一个字符串中是否包含了第二个字符串，比如上面的例子中，很明显第一个字符串包含了第二个字符串。\n暴力解法 KMP算法 有关C语言的基础部分内容，我们就讲解到这里，从下一章开始，难度将会有一定的提升，所以请各位小伙伴务必将本章知识点梳理清楚，牢记心中。\n","permalink":"https://blog.l50.top/posts/c%E8%AF%AD%E8%A8%80%E4%BA%8C/","summary":"C语言基础 前面我们已经搭建好了基本的学习环境，现在就让我们开始C语言的学习吧！\nC语言的语法层面内容相比其他语言来说，其实算少的了，但是它的难点在于很多概念上的理解，这也是为什么上一章一直在说一些计算机基础相关内容（包括这一章还会继续补一点），这样会有助于各位对于语言的理解，C语言可以说是步入编程领域的分水岭，跨过了这道坎，后续其他编程语言的学习都会无比轻松。\n学习编程的过程可能会很枯燥，但是请各位一定不要心急，一步一个脚印，相信大家一定能通关。\nC程序基本格式 前面我们在创建项目之后自动生成了一个.c文件，这个就是我们编写的程序代码文件：\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World!\u0026#34;); return 0; } 操作系统需要执行我们的程序，但是我们的程序中可能写了很多很多的代码，那么肯定需要知道从哪里开始执行才可以，也就是程序的入口，所以我们需要提供一个入口点，我们的C语言程序入口点就是main函数（不过现在还没有讲到函数，所以各位就理解为固定模式即可）它的写法是：\nint main() { //所有的符号一律采用英文的，别用中文 程序代码... } 注意是int后面空格跟上main()，我们的程序代码使用花括号{}进行囊括（有的人为了方便查阅，会把前半个花括号写在下面）\n然后我们看到，如果我们需要打印一段话到控制台，那么就需要使用printf(内容)来完成，这其实就是一种函数调用，但是现在我们还没有接触到，我们注意到括号里面的内容就是我们要打印到控制台的内容：\nprintf(\u0026#34;Hello World!\u0026#34;); //注意最后需要添加;来结束这一行，注意是英文的分号，不是中文的！ 我们要打印的内容需要采用双引号进行囊括，被双引号囊括的这一端话，我们称为字符串，当然我们现在还没有学到，所以各位也是记固定模式就好，当我们需要向控制台打印一段话时，就要用双引号囊括这段话，然后放入printf即可。我们会在后续的学习中逐渐认识printf函数。\n最顶上还有一句：\n#include \u0026lt;stdio.h\u0026gt; 这个是引入系统库为我们提供的函数，包括printf在内，所以我们以后编写一个C语言程序，就按照固定模式：\n#include \u0026lt;stdio.h\u0026gt; int main() { 程序代码 } 除了程序代码部分我们会进行编写之外，其他的地方采用固定模式就好。\n我们在写代码的过程中可以添加一些注释文本，这些文本内容在编译时自动忽略，所以比如我们想边写边记点笔记，就可以添加注释，注释的格式为：\n#include \u0026lt;stdio.h\u0026gt; //引入标准库头文件 int main() { //主函数，程序的入口点 printf(\u0026#34;Hello World!\u0026#34;); //向控制台打印字符串 } 当然我们也可以添加多行注释：\n#include \u0026lt;stdio.h\u0026gt; /* * 这是由IDE自动生成的测试代码 * 还是可以的 */ int main() { printf(\u0026#34;Hello World!\u0026#34;); //最后还有一句 return 0; 但是我们可以不用写，编译器会自动添加，所以后面讲到之后我们再来说说这玩意。 } OK，基本的一些内容就讲解完毕了。","title":"C语言（二）"},{"content":" **温馨提示：**所有的笔记（需要使用Typora软件打开）在视频下方简介中直接获取，纯个人录制，不用加什么公众号这些，各位小伙伴直接网盘自取吧。\n计算机思维导论 计算机自1946年问世以来，几乎改变了整个世界。\n现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。各位可以看看最顶上的这张图片，如果你在小时候接触过计算机，那么一定对这张图片（照片拍摄于1996年，在美国加利福尼亚州加利福尼亚州的锁诺玛县）印象深刻，这张壁纸作为WindowsXP系统的默认壁纸，曾经展示在千家万户的电脑屏幕上。\n也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习C语言之前，先让我们来了解一下计算机的世界。\n计算机的世界 计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。\n这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。\n很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。\n用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的基本单元。\n计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。\n数字电路引入了逻辑判断，我们来看看简单的数字电路：\n数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。\n二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。\n比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）\n当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是与门、或门和非门，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了）\n比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用\u0026amp;表示）要求两个数参与进来，比如：\n1 \u0026amp; 1 = 1 必须两边都是真，结果才为真。 1 \u0026amp; 0 = 0 两边任意一个或者都不是真，结果为假。 或运算（用 | 表示）：\n1 | 0 = 1 两边只要有一个为真，结果就为真 0 | 0 = 0 两边同时为假，结果才是假 非运算实际上就是取反操作（可以是 ! 表示）\n!1 = 0 !0 = 1 非运算会将真变成假，假变成真 有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。\n前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。\n相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看：\n我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。\n当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone13 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G/6G/8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。\n计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。\n**问题：**我们上面提到的这些硬件设备哪些是属于外设？\n操作系统概述 前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。\n操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互操作的界面。\n一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。\n一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了：\n有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。\n不过操作系统最开始并不是图形化界面，它类似于Windows中的命令提示符：\n没有什么图标这些概念，只有一个简简单单的黑框让我们进行操作，通过输入命令来进行一些简单的使用，程序的运行结果也会在黑框框（命令行）中打印出来，不过虽然仅仅是一个黑框，但是能运行的程序可是非常非常多的，只需要运行我们编写好的程序，就能完成各种各样复杂的计算任务，并且计算机的计算速度远超我们的人脑。\n中国超级计算机系统天河二号，计算速度达到每秒5.49亿亿次。\n当然，除了我们常见的Windows和MacOS系统之外，还有我们以后需要经常打交道的Linux操作系统，这种操作系统是开源的，意思是所有的人都可以拿到源代码进行修改，于是就出现了很多发行版：\n这些发行版有带图形化界面的，也有不带图形化界面的，不带图形化界面的Linux将是我们以后学习的重点。\n不同操作系统之间的软件并不是通用的，比如Windows下我们的软件一般是.exe后缀名称，而MacOS下则不是，并且也无法直接运行.exe文件，这是因为不同操作系统的具体实现会存在一些不同，程序编译（我们之后会介绍到）之后的格式也会不同，所以是无法做到软件通用的。\n正是因为有了操作系统，才能够组织我们计算机的底层硬件（包括CPU、内存、输入输出设备等）进行有序工作，没有操作系统电脑就如同一堆废铁，只有躯壳没有灵魂。\n计算机编程语言 现在我们大致了解了我们的电脑的运作原理，实际上是一套完整的硬件+一个成形的操作系统共同存在的。接着我们就可以开始了解一下计算机的编程语言了。我们前面介绍的操作系统也是由编程语言写出来的，操作系统本身也算是一个软件。\n那么操作系统是如何让底层硬件进行工作的呢？实际上就是通过向CPU发送指令来完成的。\n计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。\n我们电脑中的CPU有多种多样的，不同的CPU之间可能也会存在不同的架构，比如现在最常用的是x86架构，还有我们手机平板这样的移动设备使用的arm架构，不同的架构指令集也会有不同。\n我们知道，计算机底层硬件都是采用的0和1这样的二进制表示，所以指令也是一样的，比如（这里随便写的）：\n000001 - 代表开机 000010 - 代表关机 000011 - 代表进行加法运算 当我们通过电路发送给CPU这样的二进制指令，CPU就能够根据我们的指令执行对应的任务，而我们编写的程序保存在硬盘中也是这样的二进制形式，我们只需要将这些指令组织好，按照我们的思路一条一条执行对应的命令，就能够让计算机计算任何我们需要的内容了，这其实就是机器语言。\n不过随着时代的进步，指令集越来越大，CPU支持的运算类型也越来越多，这样的纯二进制编写实在是太累了，并且越来越多的命令我们根本记不住，于是就有了汇编语言。汇编语言将这些二进制的操作码通过助记符来替换：\nMOV 传送字或字节。 MOVSX 先符号扩展,再传送。 MOVZX 先零扩展,再传送。 PUSH 把字压入堆栈。 把这些原有的二进制命令通过一个单词来代替，这样是不是就好记多了，在程序编写完成后，我们只需要最后将这些单词转换回二进制指令就可以了，这也是早期出现的低级编程语言。\n不过虽然通过这些助记符就能够很轻松地记住命令，但是还是不够方便，因为可能我们的程序需要完成一个很庞大的任务，但是如果还是这样一条一条指令进行编写，是不是太慢了点，有时候可能做一个简单的计算，都需要好几条指令来完成。于是，高级编程语言——C语言，终于诞生了。\nC语言诞生于美国的贝尔实验室，由丹尼斯·里奇（Dennis MacAlistair Ritchie）以肯尼斯·蓝·汤普森（Kenneth Lane Thompson）设计的B语言为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX操作系统，且随着UNIX操作系统的发展，C语言也得到了不断的完善。\n高级语言不同于低级语言，低级语言的主要操作对象是指令本身，而高级语言却更加符合我们人脑的认知，更像是通过我们人的思维，去告诉计算机你需要做什么，包括语法也会更加的简单易懂。下面是一段简单的C语言代码：\nint main() { int a = 10; //定义一个a等于10 int b = 10; //定义一个b等于10 int c = a + b; //语义非常明确，c就是a加上b计算出来的结果。 return 0; } 不过现在看不懂没关系，我们后面慢慢学。\nC语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。\n当然，除了C语言之外，还有很多其他的高级语言，比如Java、Python、C#、PHP等等，相比其他编程语言，C算是比较古老的一种了，但是时隔多年直至今日，其他编程语言也依然无法撼动它的王者地位：\n可以看到在2021年9月，依然排在编程语言排行榜的第一名（Python和Java紧随其后），可见这门语言是多么的不可撼动，很多操作系统、高级编程语言底层实现，几乎都是依靠C语言去编写的（包括Java的底层也是C/C++实现的）所以学习这一门语言，对于理工科尤其是计算机专业极为重要，学好C语言你甚至可以融汇贯通到其他语言，学起来也会轻松很多。\n那么从下节课开始，我们就先做好一些环境上的准备。\nC语言开发环境部署 完成开发环境部署之后，我们就可以使用C语言来将一句话输出到控制台了，成功编译运行下面的简单程序：\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, World!\\n\u0026#34;); return 0; } 首先，我们既然要将我们编写的C语言代码进行编译，那么肯定得找到一个合适的编译器才行，现代的集成开发环境IDE一般都包含了这些编译器，所以我们不需要进行单独的安装。\n我们只需要找一个集成开发环境去安装就行了，目前功能比较完善的集成开发环境有：\nCodeblocks（支持Windows、Linux、MacOS操作系统） Visual Studio（支持Windows、MacOS操作系统） CLion（支持Windows、Linux、MacOS操作系统） 这里我们就使用CLion作为我们的开发工具使用（这个IDE是收费的，但是学生可以申请免费使用，别担心，大学四年肯定是够你用了，选这个是考虑到后面同学们可能会继续学习Java，Java语言的推荐IDE也是同一个公司的产品，界面都长得差不多）当然如果你想要使用其他的开发工具，也可以，但是这里我们就不演示了。\n首先前往官网下载：CLion: A Cross-Platform IDE for C and C++ by JetBrains\n下载完成后我们直接点击安装：\n如果你不是很熟悉，建议直接点Next安装到C盘默认路径，不要去修改，当然如果确实C盘没有空间，那可以自行修改为其他路径，但是注意最好路径中不要出现中文。\n勾选一下创建快捷方式，然后继续点Next等待安装就行了：\n安装完成后，我们可以直接打开：\n这里会提示我们激活，点击按钮去官网注册一个账号。注册完成后，推荐去申请一下学生授权，因为试用只有30天：Jetbrains学生授权获取指南 - 知乎 (zhihu.com)\n这里我们点击开始试用，然后就可以点击Continue了，现在成功来到主界面：\n由于是英文，使用不太方便，所以我们安装一下中文插件：\n现在我们就成功安装好CLion集成开发环境了。\n现在我们来创建我们的第一个C语言项目（我们的程序是以一个项目的形式进行管理的，这里知道怎么创建就行了）：\n这里选择C可执行文件，然后项目的保存位置可以自行修改，配置完成后点击创建：\n可以看到，在创建之后，会自动为我们生成一段示例代码，而之后我们要编写的代码，都在生成的main.c中进行编写，除了这个文件，其他的全部不要去修改，也不用管是什么意思，后面我们会慢慢介绍。\n接着我们需要配置一下工具链，选择捆绑的MinGW（如果已经有了就不需要配置了）\n那么这段示例代码有了，我们如何编译运行呢？\n我们可以点击代码旁边的绿色三角形符号或是右上角的绿色三角形，就可以直接编译运行我们的代码了。运行的结果是在控制台输出一个“HelloWorld！”，当然我们也可以直接运行编译出来的可执行文件：\n我们可以看到，这里生成了一个项目名称.exe文件，这种就是Windows环境下可以直接运行的应用程序，我们可以打开这个文件夹，直接使用cmd来运行：\n运行出来的效果是一样的，这种程序实际上就是最原始的命令行程序，输入和输出都是在这种黑框框中进行的，而我们的主要学习目标也是这种命令行程序。\n这样我们就配置好了开发环境，然后就不要去动其他的东西了，一般新手最容易遇到一些奇奇怪怪的问题。\n","permalink":"https://blog.l50.top/posts/c%E8%AF%AD%E8%A8%80%E4%B8%80/","summary":"**温馨提示：**所有的笔记（需要使用Typora软件打开）在视频下方简介中直接获取，纯个人录制，不用加什么公众号这些，各位小伙伴直接网盘自取吧。\n计算机思维导论 计算机自1946年问世以来，几乎改变了整个世界。\n现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。各位可以看看最顶上的这张图片，如果你在小时候接触过计算机，那么一定对这张图片（照片拍摄于1996年，在美国加利福尼亚州加利福尼亚州的锁诺玛县）印象深刻，这张壁纸作为WindowsXP系统的默认壁纸，曾经展示在千家万户的电脑屏幕上。\n也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习C语言之前，先让我们来了解一下计算机的世界。\n计算机的世界 计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。\n这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。\n很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。\n用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的基本单元。\n计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。\n数字电路引入了逻辑判断，我们来看看简单的数字电路：\n数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。\n二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。\n比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）\n当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是与门、或门和非门，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了）\n比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用\u0026amp;表示）要求两个数参与进来，比如：\n1 \u0026amp; 1 = 1 必须两边都是真，结果才为真。 1 \u0026amp; 0 = 0 两边任意一个或者都不是真，结果为假。 或运算（用 | 表示）：\n1 | 0 = 1 两边只要有一个为真，结果就为真 0 | 0 = 0 两边同时为假，结果才是假 非运算实际上就是取反操作（可以是 ! 表示）\n!1 = 0 !0 = 1 非运算会将真变成假，假变成真 有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。\n前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。\n相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看：\n我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。\n当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone13 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G/6G/8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。\n计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。\n**问题：**我们上面提到的这些硬件设备哪些是属于外设？\n操作系统概述 前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。\n操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互操作的界面。\n一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。\n一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了：\n有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。","title":"C语言（一）"},{"content":"java的jdk环境变量手动配置（Windows11）\n参考：https://blog.csdn.net/JUSTLOVEBOY/article/details/119373550\n由于经常要配置环境变量那些，由于冲突或者不小心，可能会把原来配置的弄掉，又要重新配置，所以索性记录一下 第一次没有配置好不要着急，多试几次就好了，多配置几次你就会很熟悉了，正所谓万事开头难不用担心，仅仅配置了JDK，没有JRE！\n以下是步骤： 鼠标右键 “此电脑” 选择属性，之后会出现一个弹窗，点击 “高级系统设置”\n如下图：\n点击 “环境变量” 然后会看到这样的画面： 关键是下面的内容，用户变量可以不用管：\n至此你已经完成了所有的准备步骤，接下来就是环境配置了： 1.点击“新建”会出现一个弹窗： 变量名：JAVA_HOME 变量值：C:\\Program Files\\Java\\jdk1.8.0_162(JDK的安装路径，这里以你自己的安装路径为准) 输入完成之后点确认，第一项配置就完成了，接下来进行第二步\n2.新建CLASSPATH 变量，变量值为： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar(注意前面是有一个点的)，配置好之后如下图，这里是可以复制粘贴的。 然后点确定保存变量，进入第三步\n3.配置path,找到path，双击或者点编辑 然后可以看到path里面已经有很多内容了，我们在最后面新建一个： 输入 %JAVA_HOME%\\bin 然后点确定保存，出去之后再点确定，然后再点确定，至此环境变量配置完毕，接下来就是测试环境变量配置有没有问题了。注意：一定是三次点击确认\n","permalink":"https://blog.l50.top/posts/java%E7%9A%84jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE/","summary":"java的jdk环境变量手动配置（Windows11）\n参考：https://blog.csdn.net/JUSTLOVEBOY/article/details/119373550\n由于经常要配置环境变量那些，由于冲突或者不小心，可能会把原来配置的弄掉，又要重新配置，所以索性记录一下 第一次没有配置好不要着急，多试几次就好了，多配置几次你就会很熟悉了，正所谓万事开头难不用担心，仅仅配置了JDK，没有JRE！\n以下是步骤： 鼠标右键 “此电脑” 选择属性，之后会出现一个弹窗，点击 “高级系统设置”\n如下图：\n点击 “环境变量” 然后会看到这样的画面： 关键是下面的内容，用户变量可以不用管：\n至此你已经完成了所有的准备步骤，接下来就是环境配置了： 1.点击“新建”会出现一个弹窗： 变量名：JAVA_HOME 变量值：C:\\Program Files\\Java\\jdk1.8.0_162(JDK的安装路径，这里以你自己的安装路径为准) 输入完成之后点确认，第一项配置就完成了，接下来进行第二步\n2.新建CLASSPATH 变量，变量值为： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar(注意前面是有一个点的)，配置好之后如下图，这里是可以复制粘贴的。 然后点确定保存变量，进入第三步\n3.配置path,找到path，双击或者点编辑 然后可以看到path里面已经有很多内容了，我们在最后面新建一个： 输入 %JAVA_HOME%\\bin 然后点确定保存，出去之后再点确定，然后再点确定，至此环境变量配置完毕，接下来就是测试环境变量配置有没有问题了。注意：一定是三次点击确认","title":"Java的jdk环境变量手动配置"},{"content":"Hello,world!\n","permalink":"https://blog.l50.top/posts/helloworld/","summary":"Hello,world!","title":"Hello,world"},{"content":"This is a testing web page.\n这是一个测试页面，还没想好要写什么。\n","permalink":"https://blog.l50.top/about/","summary":"This is a testing web page.\n这是一个测试页面，还没想好要写什么。","title":"About"}]